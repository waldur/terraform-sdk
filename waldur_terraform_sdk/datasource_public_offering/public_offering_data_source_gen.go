// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_public_offering

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func PublicOfferingDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"access_url": schema.StringAttribute{
				Computed:            true,
				Description:         "Publicly accessible offering access URL",
				MarkdownDescription: "Publicly accessible offering access URL",
			},
			"backend_id": schema.StringAttribute{
				Computed: true,
			},
			"billable": schema.BoolAttribute{
				Computed:            true,
				Description:         "Purchase and usage is invoiced.",
				MarkdownDescription: "Purchase and usage is invoiced.",
			},
			"category": schema.StringAttribute{
				Computed: true,
			},
			"category_title": schema.StringAttribute{
				Computed: true,
			},
			"category_uuid": schema.StringAttribute{
				Computed: true,
			},
			"citation_count": schema.Int64Attribute{
				Computed:            true,
				Description:         "Number of citations of a DOI",
				MarkdownDescription: "Number of citations of a DOI",
			},
			"components": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"article_code": schema.StringAttribute{
							Computed: true,
						},
						"billing_type": schema.StringAttribute{
							Computed: true,
						},
						"default_limit": schema.Int64Attribute{
							Computed: true,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"factor": schema.Int64Attribute{
							Computed: true,
						},
						"is_boolean": schema.BoolAttribute{
							Computed: true,
						},
						"is_builtin": schema.BoolAttribute{
							Computed: true,
						},
						"limit_amount": schema.Int64Attribute{
							Computed: true,
						},
						"max_available_limit": schema.Int64Attribute{
							Computed: true,
						},
						"max_value": schema.Int64Attribute{
							Computed: true,
						},
						"measured_unit": schema.StringAttribute{
							Computed:            true,
							Description:         "Unit of measurement, for example, GB.",
							MarkdownDescription: "Unit of measurement, for example, GB.",
						},
						"min_value": schema.Int64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "Display name for the measured unit, for example, Floating IP.",
							MarkdownDescription: "Display name for the measured unit, for example, Floating IP.",
						},
						"type": schema.StringAttribute{
							Computed:            true,
							Description:         "Unique internal name of the measured unit, for example floating_ip.",
							MarkdownDescription: "Unique internal name of the measured unit, for example floating_ip.",
						},
						"unit_factor": schema.Int64Attribute{
							Computed:            true,
							Description:         "The conversion factor from backend units to measured_unit",
							MarkdownDescription: "The conversion factor from backend units to measured_unit",
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: ComponentsType{
						ObjectType: types.ObjectType{
							AttrTypes: ComponentsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"created": schema.StringAttribute{
				Computed: true,
			},
			"customer": schema.StringAttribute{
				Computed: true,
			},
			"customer_name": schema.StringAttribute{
				Computed: true,
			},
			"customer_uuid": schema.StringAttribute{
				Computed: true,
			},
			"datacite_doi": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Computed: true,
			},
			"endpoints": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: EndpointsType{
						ObjectType: types.ObjectType{
							AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"field": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"files": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created": schema.StringAttribute{
							Computed: true,
						},
						"file": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: FilesType{
						ObjectType: types.ObjectType{
							AttrTypes: FilesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"full_description": schema.StringAttribute{
				Computed: true,
			},
			"getting_started": schema.StringAttribute{
				Computed: true,
			},
			"google_calendar_is_public": schema.BoolAttribute{
				Computed: true,
			},
			"google_calendar_link": schema.StringAttribute{
				Computed: true,
			},
			"image": schema.StringAttribute{
				Computed: true,
			},
			"integration_guide": schema.StringAttribute{
				Computed: true,
			},
			"latitude": schema.Float64Attribute{
				Computed: true,
			},
			"longitude": schema.Float64Attribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"options": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"choices": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"default": schema.StringAttribute{
									Computed: true,
								},
								"help_text": schema.StringAttribute{
									Computed: true,
								},
								"label": schema.StringAttribute{
									Computed: true,
								},
								"max": schema.Int64Attribute{
									Computed: true,
								},
								"min": schema.Int64Attribute{
									Computed: true,
								},
								"required": schema.BoolAttribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: OptionsType{
								ObjectType: types.ObjectType{
									AttrTypes: OptionsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed: true,
					},
					"order": schema.ListAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
				},
				CustomType: OptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: OptionsValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"order_count": schema.Int64Attribute{
				Computed: true,
			},
			"organization_groups": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"customers_count": schema.Int64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"parent": schema.StringAttribute{
							Computed: true,
						},
						"parent_name": schema.StringAttribute{
							Computed: true,
						},
						"parent_uuid": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: OrganizationGroupsType{
						ObjectType: types.ObjectType{
							AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"parent_description": schema.StringAttribute{
				Computed: true,
			},
			"parent_name": schema.StringAttribute{
				Computed: true,
			},
			"parent_uuid": schema.StringAttribute{
				Computed: true,
			},
			"paused_reason": schema.StringAttribute{
				Computed: true,
			},
			"plans": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"archived": schema.BoolAttribute{
							Computed:            true,
							Description:         "Forbids creation of new resources.",
							MarkdownDescription: "Forbids creation of new resources.",
						},
						"article_code": schema.StringAttribute{
							Computed: true,
						},
						"backend_id": schema.StringAttribute{
							Computed: true,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"future_prices": schema.MapAttribute{
							ElementType: types.Float64Type,
							Computed:    true,
						},
						"init_price": schema.Float64Attribute{
							Computed: true,
						},
						"is_active": schema.BoolAttribute{
							Computed: true,
						},
						"max_amount": schema.Int64Attribute{
							Computed:            true,
							Description:         "Maximum number of plans that could be active. Plan is disabled when maximum amount is reached.",
							MarkdownDescription: "Maximum number of plans that could be active. Plan is disabled when maximum amount is reached.",
						},
						"minimal_price": schema.Float64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"organization_groups": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"customers_count": schema.Int64Attribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"parent": schema.StringAttribute{
										Computed: true,
									},
									"parent_name": schema.StringAttribute{
										Computed: true,
									},
									"parent_uuid": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: OrganizationGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"plan_type": schema.StringAttribute{
							Computed: true,
						},
						"prices": schema.MapAttribute{
							ElementType: types.Float64Type,
							Computed:    true,
						},
						"quotas": schema.MapAttribute{
							ElementType: types.Float64Type,
							Computed:    true,
						},
						"resources_count": schema.Int64Attribute{
							Computed: true,
						},
						"switch_price": schema.Float64Attribute{
							Computed: true,
						},
						"unit": schema.StringAttribute{
							Computed: true,
						},
						"unit_price": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: PlansType{
						ObjectType: types.ObjectType{
							AttrTypes: PlansValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"plugin_options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"auto_approve_in_service_provider_projects": schema.BoolAttribute{
						Computed:            true,
						Description:         "Skip approval of public offering belonging to the same organization under which the request is done",
						MarkdownDescription: "Skip approval of public offering belonging to the same organization under which the request is done",
					},
					"auto_approve_remote_orders": schema.BoolAttribute{
						Computed:            true,
						Description:         "If set to True, an order can be processed without approval",
						MarkdownDescription: "If set to True, an order can be processed without approval",
					},
					"default_internal_network_mtu": schema.Int64Attribute{
						Computed:            true,
						Description:         "If set, it will be used as a default MTU for the first network in a tenant",
						MarkdownDescription: "If set, it will be used as a default MTU for the first network in a tenant",
					},
					"default_resource_termination_offset_in_days": schema.Int64Attribute{
						Computed:            true,
						Description:         "If set, it will be used as a default resource termination offset in days",
						MarkdownDescription: "If set, it will be used as a default resource termination offset in days",
					},
					"enable_issues_for_membership_changes": schema.BoolAttribute{
						Computed:            true,
						Description:         "Enable issues for membership changes",
						MarkdownDescription: "Enable issues for membership changes",
					},
					"flavors_regex": schema.StringAttribute{
						Computed:            true,
						Description:         "Regular expression to limit flavors list",
						MarkdownDescription: "Regular expression to limit flavors list",
					},
					"heappe_cluster_id": schema.StringAttribute{
						Computed:            true,
						Description:         "HEAppE cluster id",
						MarkdownDescription: "HEAppE cluster id",
					},
					"heappe_local_base_path": schema.StringAttribute{
						Computed:            true,
						Description:         "HEAppE local base path",
						MarkdownDescription: "HEAppE local base path",
					},
					"heappe_url": schema.StringAttribute{
						Computed:            true,
						Description:         "HEAppE url",
						MarkdownDescription: "HEAppE url",
					},
					"heappe_username": schema.StringAttribute{
						Computed:            true,
						Description:         "HEAppE username",
						MarkdownDescription: "HEAppE username",
					},
					"homedir_prefix": schema.StringAttribute{
						Computed:            true,
						Description:         "GLAuth homedir prefix",
						MarkdownDescription: "GLAuth homedir prefix",
					},
					"initial_primarygroup_number": schema.Int64Attribute{
						Computed:            true,
						Description:         "GLAuth initial primary group number",
						MarkdownDescription: "GLAuth initial primary group number",
					},
					"initial_uidnumber": schema.Int64Attribute{
						Computed:            true,
						Description:         "GLAuth initial uidnumber",
						MarkdownDescription: "GLAuth initial uidnumber",
					},
					"initial_usergroup_number": schema.Int64Attribute{
						Computed:            true,
						Description:         "GLAuth initial usergroup number",
						MarkdownDescription: "GLAuth initial usergroup number",
					},
					"is_resource_termination_date_required": schema.BoolAttribute{
						Computed:            true,
						Description:         "If set to True, resource termination date is required",
						MarkdownDescription: "If set to True, resource termination date is required",
					},
					"latest_date_for_resource_termination": schema.StringAttribute{
						Computed:            true,
						Description:         "If set, it will be used as a latest date for resource termination",
						MarkdownDescription: "If set, it will be used as a latest date for resource termination",
					},
					"managed_rancher_load_balancer_cloud_init_template": schema.StringAttribute{
						Computed: true,
					},
					"managed_rancher_load_balancer_data_volume_size_gb": schema.Int64Attribute{
						Computed: true,
					},
					"managed_rancher_load_balancer_data_volume_type_name": schema.StringAttribute{
						Computed: true,
					},
					"managed_rancher_load_balancer_flavor_name": schema.StringAttribute{
						Computed: true,
					},
					"managed_rancher_load_balancer_system_volume_size_gb": schema.Int64Attribute{
						Computed: true,
					},
					"managed_rancher_load_balancer_system_volume_type_name": schema.StringAttribute{
						Computed: true,
					},
					"managed_rancher_server_data_volume_size_gb": schema.Int64Attribute{
						Computed: true,
					},
					"managed_rancher_server_data_volume_type_name": schema.StringAttribute{
						Computed: true,
					},
					"managed_rancher_server_flavor_name": schema.StringAttribute{
						Computed: true,
					},
					"managed_rancher_server_system_volume_size_gb": schema.Int64Attribute{
						Computed: true,
					},
					"managed_rancher_server_system_volume_type_name": schema.StringAttribute{
						Computed: true,
					},
					"managed_rancher_worker_system_volume_size_gb": schema.Int64Attribute{
						Computed: true,
					},
					"managed_rancher_worker_system_volume_type_name": schema.StringAttribute{
						Computed: true,
					},
					"max_instances": schema.Int64Attribute{
						Computed:            true,
						Description:         "Default limit for number of instances in OpenStack tenant",
						MarkdownDescription: "Default limit for number of instances in OpenStack tenant",
					},
					"max_resource_termination_offset_in_days": schema.Int64Attribute{
						Computed:            true,
						Description:         "Maximum resource termination offset in days",
						MarkdownDescription: "Maximum resource termination offset in days",
					},
					"max_volumes": schema.Int64Attribute{
						Computed:            true,
						Description:         "Default limit for number of volumes in OpenStack tenant",
						MarkdownDescription: "Default limit for number of volumes in OpenStack tenant",
					},
					"openstack_offering_uuid_list": schema.ListAttribute{
						ElementType:         types.StringType,
						Computed:            true,
						Description:         "List of UUID of OpenStack offerings where tenant can be created",
						MarkdownDescription: "List of UUID of OpenStack offerings where tenant can be created",
					},
					"service_provider_can_create_offering_user": schema.BoolAttribute{
						Computed:            true,
						Description:         "Service provider can create offering user",
						MarkdownDescription: "Service provider can create offering user",
					},
					"snapshot_size_limit_gb": schema.Int64Attribute{
						Computed:            true,
						Description:         "Default limit for snapshot size in GB",
						MarkdownDescription: "Default limit for snapshot size in GB",
					},
					"storage_mode": schema.StringAttribute{
						Computed:            true,
						Description:         "Storage mode for OpenStack offering",
						MarkdownDescription: "Storage mode for OpenStack offering",
					},
					"supports_downscaling": schema.BoolAttribute{
						Computed:            true,
						Description:         "If set to True, it will be possible to downscale resources",
						MarkdownDescription: "If set to True, it will be possible to downscale resources",
					},
					"supports_pausing": schema.BoolAttribute{
						Computed:            true,
						Description:         "If set to True, it will be possible to pause resources",
						MarkdownDescription: "If set to True, it will be possible to pause resources",
					},
					"username_anonymized_prefix": schema.StringAttribute{
						Computed:            true,
						Description:         "GLAuth prefix for anonymized usernames",
						MarkdownDescription: "GLAuth prefix for anonymized usernames",
					},
					"username_generation_policy": schema.StringAttribute{
						Computed:            true,
						Description:         "GLAuth username generation policy",
						MarkdownDescription: "GLAuth username generation policy",
					},
				},
				CustomType: PluginOptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: PluginOptionsValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"privacy_policy_link": schema.StringAttribute{
				Computed: true,
			},
			"project": schema.StringAttribute{
				Computed: true,
			},
			"project_name": schema.StringAttribute{
				Computed: true,
			},
			"project_uuid": schema.StringAttribute{
				Computed: true,
			},
			"promotion_campaigns": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Computed: true,
						},
						"discount": schema.Int64Attribute{
							Computed: true,
						},
						"discount_type": schema.StringAttribute{
							Computed: true,
						},
						"end_date": schema.StringAttribute{
							Computed:            true,
							Description:         "The last day the campaign is active.",
							MarkdownDescription: "The last day the campaign is active.",
						},
						"months": schema.Int64Attribute{
							Computed:            true,
							Description:         "How many months in a row should the related service (when activated) get special deal (0 for indefinitely until active)",
							MarkdownDescription: "How many months in a row should the related service (when activated) get special deal (0 for indefinitely until active)",
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"service_provider": schema.StringAttribute{
							Computed: true,
						},
						"start_date": schema.StringAttribute{
							Computed:            true,
							Description:         "Starting from this date, the campaign is active.",
							MarkdownDescription: "Starting from this date, the campaign is active.",
						},
						"stock": schema.Int64Attribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: PromotionCampaignsType{
						ObjectType: types.ObjectType{
							AttrTypes: PromotionCampaignsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"quotas": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"limit": schema.Int64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"usage": schema.Int64Attribute{
							Computed: true,
						},
					},
					CustomType: QuotasType{
						ObjectType: types.ObjectType{
							AttrTypes: QuotasValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"resource_options": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"options": schema.MapNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"choices": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"default": schema.StringAttribute{
									Computed: true,
								},
								"help_text": schema.StringAttribute{
									Computed: true,
								},
								"label": schema.StringAttribute{
									Computed: true,
								},
								"max": schema.Int64Attribute{
									Computed: true,
								},
								"min": schema.Int64Attribute{
									Computed: true,
								},
								"required": schema.BoolAttribute{
									Computed: true,
								},
								"type": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: OptionsType{
								ObjectType: types.ObjectType{
									AttrTypes: OptionsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed: true,
					},
					"order": schema.ListAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
				},
				CustomType: ResourceOptionsType{
					ObjectType: types.ObjectType{
						AttrTypes: ResourceOptionsValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"roles": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: RolesType{
						ObjectType: types.ObjectType{
							AttrTypes: RolesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"scope": schema.StringAttribute{
				Computed: true,
			},
			"scope_error_message": schema.StringAttribute{
				Computed: true,
			},
			"scope_name": schema.StringAttribute{
				Computed: true,
			},
			"scope_state": schema.StringAttribute{
				Computed: true,
			},
			"scope_uuid": schema.StringAttribute{
				Computed: true,
			},
			"screenshots": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created": schema.StringAttribute{
							Computed: true,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"image": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"thumbnail": schema.StringAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: ScreenshotsType{
						ObjectType: types.ObjectType{
							AttrTypes: ScreenshotsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"shared": schema.BoolAttribute{
				Computed:            true,
				Description:         "Accessible to all customers.",
				MarkdownDescription: "Accessible to all customers.",
			},
			"slug": schema.StringAttribute{
				Computed: true,
			},
			"state": schema.StringAttribute{
				Computed: true,
			},
			"terms_of_service": schema.StringAttribute{
				Computed: true,
			},
			"terms_of_service_link": schema.StringAttribute{
				Computed: true,
			},
			"thumbnail": schema.StringAttribute{
				Computed: true,
			},
			"total_cost": schema.Int64Attribute{
				Computed: true,
			},
			"total_cost_estimated": schema.Int64Attribute{
				Computed: true,
			},
			"total_customers": schema.Int64Attribute{
				Computed: true,
			},
			"type": schema.StringAttribute{
				Computed: true,
			},
			"url": schema.StringAttribute{
				Computed: true,
			},
			"uuid": schema.StringAttribute{
				Required: true,
			},
			"vendor_details": schema.StringAttribute{
				Computed: true,
			},
		},
	}
}

type PublicOfferingModel struct {
	AccessUrl              types.String         `tfsdk:"access_url"`
	BackendId              types.String         `tfsdk:"backend_id"`
	Billable               types.Bool           `tfsdk:"billable"`
	Category               types.String         `tfsdk:"category"`
	CategoryTitle          types.String         `tfsdk:"category_title"`
	CategoryUuid           types.String         `tfsdk:"category_uuid"`
	CitationCount          types.Int64          `tfsdk:"citation_count"`
	Components             types.List           `tfsdk:"components"`
	Created                types.String         `tfsdk:"created"`
	Customer               types.String         `tfsdk:"customer"`
	CustomerName           types.String         `tfsdk:"customer_name"`
	CustomerUuid           types.String         `tfsdk:"customer_uuid"`
	DataciteDoi            types.String         `tfsdk:"datacite_doi"`
	Description            types.String         `tfsdk:"description"`
	Endpoints              types.List           `tfsdk:"endpoints"`
	Field                  types.List           `tfsdk:"field"`
	Files                  types.List           `tfsdk:"files"`
	FullDescription        types.String         `tfsdk:"full_description"`
	GettingStarted         types.String         `tfsdk:"getting_started"`
	GoogleCalendarIsPublic types.Bool           `tfsdk:"google_calendar_is_public"`
	GoogleCalendarLink     types.String         `tfsdk:"google_calendar_link"`
	Image                  types.String         `tfsdk:"image"`
	IntegrationGuide       types.String         `tfsdk:"integration_guide"`
	Latitude               types.Float64        `tfsdk:"latitude"`
	Longitude              types.Float64        `tfsdk:"longitude"`
	Name                   types.String         `tfsdk:"name"`
	Options                OptionsValue         `tfsdk:"options"`
	OrderCount             types.Int64          `tfsdk:"order_count"`
	OrganizationGroups     types.List           `tfsdk:"organization_groups"`
	ParentDescription      types.String         `tfsdk:"parent_description"`
	ParentName             types.String         `tfsdk:"parent_name"`
	ParentUuid             types.String         `tfsdk:"parent_uuid"`
	PausedReason           types.String         `tfsdk:"paused_reason"`
	Plans                  types.List           `tfsdk:"plans"`
	PluginOptions          PluginOptionsValue   `tfsdk:"plugin_options"`
	PrivacyPolicyLink      types.String         `tfsdk:"privacy_policy_link"`
	Project                types.String         `tfsdk:"project"`
	ProjectName            types.String         `tfsdk:"project_name"`
	ProjectUuid            types.String         `tfsdk:"project_uuid"`
	PromotionCampaigns     types.List           `tfsdk:"promotion_campaigns"`
	Quotas                 types.List           `tfsdk:"quotas"`
	ResourceOptions        ResourceOptionsValue `tfsdk:"resource_options"`
	Roles                  types.List           `tfsdk:"roles"`
	Scope                  types.String         `tfsdk:"scope"`
	ScopeErrorMessage      types.String         `tfsdk:"scope_error_message"`
	ScopeName              types.String         `tfsdk:"scope_name"`
	ScopeState             types.String         `tfsdk:"scope_state"`
	ScopeUuid              types.String         `tfsdk:"scope_uuid"`
	Screenshots            types.List           `tfsdk:"screenshots"`
	Shared                 types.Bool           `tfsdk:"shared"`
	Slug                   types.String         `tfsdk:"slug"`
	State                  types.String         `tfsdk:"state"`
	TermsOfService         types.String         `tfsdk:"terms_of_service"`
	TermsOfServiceLink     types.String         `tfsdk:"terms_of_service_link"`
	Thumbnail              types.String         `tfsdk:"thumbnail"`
	TotalCost              types.Int64          `tfsdk:"total_cost"`
	TotalCostEstimated     types.Int64          `tfsdk:"total_cost_estimated"`
	TotalCustomers         types.Int64          `tfsdk:"total_customers"`
	Type                   types.String         `tfsdk:"type"`
	Url                    types.String         `tfsdk:"url"`
	Uuid                   types.String         `tfsdk:"uuid"`
	VendorDetails          types.String         `tfsdk:"vendor_details"`
}

var _ basetypes.ObjectTypable = ComponentsType{}

type ComponentsType struct {
	basetypes.ObjectType
}

func (t ComponentsType) Equal(o attr.Type) bool {
	other, ok := o.(ComponentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ComponentsType) String() string {
	return "ComponentsType"
}

func (t ComponentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	articleCodeAttribute, ok := attributes["article_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`article_code is missing from object`)

		return nil, diags
	}

	articleCodeVal, ok := articleCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`article_code expected to be basetypes.StringValue, was: %T`, articleCodeAttribute))
	}

	billingTypeAttribute, ok := attributes["billing_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_type is missing from object`)

		return nil, diags
	}

	billingTypeVal, ok := billingTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_type expected to be basetypes.StringValue, was: %T`, billingTypeAttribute))
	}

	defaultLimitAttribute, ok := attributes["default_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_limit is missing from object`)

		return nil, diags
	}

	defaultLimitVal, ok := defaultLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_limit expected to be basetypes.Int64Value, was: %T`, defaultLimitAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	factorAttribute, ok := attributes["factor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`factor is missing from object`)

		return nil, diags
	}

	factorVal, ok := factorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`factor expected to be basetypes.Int64Value, was: %T`, factorAttribute))
	}

	isBooleanAttribute, ok := attributes["is_boolean"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_boolean is missing from object`)

		return nil, diags
	}

	isBooleanVal, ok := isBooleanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_boolean expected to be basetypes.BoolValue, was: %T`, isBooleanAttribute))
	}

	isBuiltinAttribute, ok := attributes["is_builtin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_builtin is missing from object`)

		return nil, diags
	}

	isBuiltinVal, ok := isBuiltinAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_builtin expected to be basetypes.BoolValue, was: %T`, isBuiltinAttribute))
	}

	limitAmountAttribute, ok := attributes["limit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_amount is missing from object`)

		return nil, diags
	}

	limitAmountVal, ok := limitAmountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_amount expected to be basetypes.Int64Value, was: %T`, limitAmountAttribute))
	}

	maxAvailableLimitAttribute, ok := attributes["max_available_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_available_limit is missing from object`)

		return nil, diags
	}

	maxAvailableLimitVal, ok := maxAvailableLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_available_limit expected to be basetypes.Int64Value, was: %T`, maxAvailableLimitAttribute))
	}

	maxValueAttribute, ok := attributes["max_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_value is missing from object`)

		return nil, diags
	}

	maxValueVal, ok := maxValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_value expected to be basetypes.Int64Value, was: %T`, maxValueAttribute))
	}

	measuredUnitAttribute, ok := attributes["measured_unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`measured_unit is missing from object`)

		return nil, diags
	}

	measuredUnitVal, ok := measuredUnitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`measured_unit expected to be basetypes.StringValue, was: %T`, measuredUnitAttribute))
	}

	minValueAttribute, ok := attributes["min_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_value is missing from object`)

		return nil, diags
	}

	minValueVal, ok := minValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_value expected to be basetypes.Int64Value, was: %T`, minValueAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	unitFactorAttribute, ok := attributes["unit_factor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_factor is missing from object`)

		return nil, diags
	}

	unitFactorVal, ok := unitFactorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_factor expected to be basetypes.Int64Value, was: %T`, unitFactorAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ComponentsValue{
		ArticleCode:       articleCodeVal,
		BillingType:       billingTypeVal,
		DefaultLimit:      defaultLimitVal,
		Description:       descriptionVal,
		Factor:            factorVal,
		IsBoolean:         isBooleanVal,
		IsBuiltin:         isBuiltinVal,
		LimitAmount:       limitAmountVal,
		MaxAvailableLimit: maxAvailableLimitVal,
		MaxValue:          maxValueVal,
		MeasuredUnit:      measuredUnitVal,
		MinValue:          minValueVal,
		Name:              nameVal,
		ComponentsType:    typeVal,
		UnitFactor:        unitFactorVal,
		Uuid:              uuidVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewComponentsValueNull() ComponentsValue {
	return ComponentsValue{
		state: attr.ValueStateNull,
	}
}

func NewComponentsValueUnknown() ComponentsValue {
	return ComponentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewComponentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ComponentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ComponentsValue Attribute Value",
				"While creating a ComponentsValue value, a missing attribute value was detected. "+
					"A ComponentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ComponentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ComponentsValue Attribute Type",
				"While creating a ComponentsValue value, an invalid attribute value was detected. "+
					"A ComponentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ComponentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ComponentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ComponentsValue Attribute Value",
				"While creating a ComponentsValue value, an extra attribute value was detected. "+
					"A ComponentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ComponentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewComponentsValueUnknown(), diags
	}

	articleCodeAttribute, ok := attributes["article_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`article_code is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	articleCodeVal, ok := articleCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`article_code expected to be basetypes.StringValue, was: %T`, articleCodeAttribute))
	}

	billingTypeAttribute, ok := attributes["billing_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_type is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	billingTypeVal, ok := billingTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_type expected to be basetypes.StringValue, was: %T`, billingTypeAttribute))
	}

	defaultLimitAttribute, ok := attributes["default_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_limit is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	defaultLimitVal, ok := defaultLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_limit expected to be basetypes.Int64Value, was: %T`, defaultLimitAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	factorAttribute, ok := attributes["factor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`factor is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	factorVal, ok := factorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`factor expected to be basetypes.Int64Value, was: %T`, factorAttribute))
	}

	isBooleanAttribute, ok := attributes["is_boolean"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_boolean is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	isBooleanVal, ok := isBooleanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_boolean expected to be basetypes.BoolValue, was: %T`, isBooleanAttribute))
	}

	isBuiltinAttribute, ok := attributes["is_builtin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_builtin is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	isBuiltinVal, ok := isBuiltinAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_builtin expected to be basetypes.BoolValue, was: %T`, isBuiltinAttribute))
	}

	limitAmountAttribute, ok := attributes["limit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_amount is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	limitAmountVal, ok := limitAmountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_amount expected to be basetypes.Int64Value, was: %T`, limitAmountAttribute))
	}

	maxAvailableLimitAttribute, ok := attributes["max_available_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_available_limit is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	maxAvailableLimitVal, ok := maxAvailableLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_available_limit expected to be basetypes.Int64Value, was: %T`, maxAvailableLimitAttribute))
	}

	maxValueAttribute, ok := attributes["max_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_value is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	maxValueVal, ok := maxValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_value expected to be basetypes.Int64Value, was: %T`, maxValueAttribute))
	}

	measuredUnitAttribute, ok := attributes["measured_unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`measured_unit is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	measuredUnitVal, ok := measuredUnitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`measured_unit expected to be basetypes.StringValue, was: %T`, measuredUnitAttribute))
	}

	minValueAttribute, ok := attributes["min_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_value is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	minValueVal, ok := minValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_value expected to be basetypes.Int64Value, was: %T`, minValueAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	unitFactorAttribute, ok := attributes["unit_factor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_factor is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	unitFactorVal, ok := unitFactorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_factor expected to be basetypes.Int64Value, was: %T`, unitFactorAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewComponentsValueUnknown(), diags
	}

	return ComponentsValue{
		ArticleCode:       articleCodeVal,
		BillingType:       billingTypeVal,
		DefaultLimit:      defaultLimitVal,
		Description:       descriptionVal,
		Factor:            factorVal,
		IsBoolean:         isBooleanVal,
		IsBuiltin:         isBuiltinVal,
		LimitAmount:       limitAmountVal,
		MaxAvailableLimit: maxAvailableLimitVal,
		MaxValue:          maxValueVal,
		MeasuredUnit:      measuredUnitVal,
		MinValue:          minValueVal,
		Name:              nameVal,
		ComponentsType:    typeVal,
		UnitFactor:        unitFactorVal,
		Uuid:              uuidVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewComponentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ComponentsValue {
	object, diags := NewComponentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewComponentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ComponentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewComponentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewComponentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewComponentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewComponentsValueMust(ComponentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ComponentsType) ValueType(ctx context.Context) attr.Value {
	return ComponentsValue{}
}

var _ basetypes.ObjectValuable = ComponentsValue{}

type ComponentsValue struct {
	ArticleCode       basetypes.StringValue `tfsdk:"article_code"`
	BillingType       basetypes.StringValue `tfsdk:"billing_type"`
	DefaultLimit      basetypes.Int64Value  `tfsdk:"default_limit"`
	Description       basetypes.StringValue `tfsdk:"description"`
	Factor            basetypes.Int64Value  `tfsdk:"factor"`
	IsBoolean         basetypes.BoolValue   `tfsdk:"is_boolean"`
	IsBuiltin         basetypes.BoolValue   `tfsdk:"is_builtin"`
	LimitAmount       basetypes.Int64Value  `tfsdk:"limit_amount"`
	MaxAvailableLimit basetypes.Int64Value  `tfsdk:"max_available_limit"`
	MaxValue          basetypes.Int64Value  `tfsdk:"max_value"`
	MeasuredUnit      basetypes.StringValue `tfsdk:"measured_unit"`
	MinValue          basetypes.Int64Value  `tfsdk:"min_value"`
	Name              basetypes.StringValue `tfsdk:"name"`
	ComponentsType    basetypes.StringValue `tfsdk:"type"`
	UnitFactor        basetypes.Int64Value  `tfsdk:"unit_factor"`
	Uuid              basetypes.StringValue `tfsdk:"uuid"`
	state             attr.ValueState
}

func (v ComponentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["article_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["billing_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["default_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["factor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_boolean"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_builtin"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["limit_amount"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_available_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["measured_unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["min_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unit_factor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.ArticleCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["article_code"] = val

		val, err = v.BillingType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billing_type"] = val

		val, err = v.DefaultLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_limit"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Factor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["factor"] = val

		val, err = v.IsBoolean.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_boolean"] = val

		val, err = v.IsBuiltin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_builtin"] = val

		val, err = v.LimitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit_amount"] = val

		val, err = v.MaxAvailableLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_available_limit"] = val

		val, err = v.MaxValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_value"] = val

		val, err = v.MeasuredUnit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["measured_unit"] = val

		val, err = v.MinValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_value"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ComponentsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UnitFactor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit_factor"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ComponentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ComponentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ComponentsValue) String() string {
	return "ComponentsValue"
}

func (v ComponentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"article_code":        basetypes.StringType{},
		"billing_type":        basetypes.StringType{},
		"default_limit":       basetypes.Int64Type{},
		"description":         basetypes.StringType{},
		"factor":              basetypes.Int64Type{},
		"is_boolean":          basetypes.BoolType{},
		"is_builtin":          basetypes.BoolType{},
		"limit_amount":        basetypes.Int64Type{},
		"max_available_limit": basetypes.Int64Type{},
		"max_value":           basetypes.Int64Type{},
		"measured_unit":       basetypes.StringType{},
		"min_value":           basetypes.Int64Type{},
		"name":                basetypes.StringType{},
		"type":                basetypes.StringType{},
		"unit_factor":         basetypes.Int64Type{},
		"uuid":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"article_code":        v.ArticleCode,
			"billing_type":        v.BillingType,
			"default_limit":       v.DefaultLimit,
			"description":         v.Description,
			"factor":              v.Factor,
			"is_boolean":          v.IsBoolean,
			"is_builtin":          v.IsBuiltin,
			"limit_amount":        v.LimitAmount,
			"max_available_limit": v.MaxAvailableLimit,
			"max_value":           v.MaxValue,
			"measured_unit":       v.MeasuredUnit,
			"min_value":           v.MinValue,
			"name":                v.Name,
			"type":                v.ComponentsType,
			"unit_factor":         v.UnitFactor,
			"uuid":                v.Uuid,
		})

	return objVal, diags
}

func (v ComponentsValue) Equal(o attr.Value) bool {
	other, ok := o.(ComponentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArticleCode.Equal(other.ArticleCode) {
		return false
	}

	if !v.BillingType.Equal(other.BillingType) {
		return false
	}

	if !v.DefaultLimit.Equal(other.DefaultLimit) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Factor.Equal(other.Factor) {
		return false
	}

	if !v.IsBoolean.Equal(other.IsBoolean) {
		return false
	}

	if !v.IsBuiltin.Equal(other.IsBuiltin) {
		return false
	}

	if !v.LimitAmount.Equal(other.LimitAmount) {
		return false
	}

	if !v.MaxAvailableLimit.Equal(other.MaxAvailableLimit) {
		return false
	}

	if !v.MaxValue.Equal(other.MaxValue) {
		return false
	}

	if !v.MeasuredUnit.Equal(other.MeasuredUnit) {
		return false
	}

	if !v.MinValue.Equal(other.MinValue) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ComponentsType.Equal(other.ComponentsType) {
		return false
	}

	if !v.UnitFactor.Equal(other.UnitFactor) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v ComponentsValue) Type(ctx context.Context) attr.Type {
	return ComponentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ComponentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"article_code":        basetypes.StringType{},
		"billing_type":        basetypes.StringType{},
		"default_limit":       basetypes.Int64Type{},
		"description":         basetypes.StringType{},
		"factor":              basetypes.Int64Type{},
		"is_boolean":          basetypes.BoolType{},
		"is_builtin":          basetypes.BoolType{},
		"limit_amount":        basetypes.Int64Type{},
		"max_available_limit": basetypes.Int64Type{},
		"max_value":           basetypes.Int64Type{},
		"measured_unit":       basetypes.StringType{},
		"min_value":           basetypes.Int64Type{},
		"name":                basetypes.StringType{},
		"type":                basetypes.StringType{},
		"unit_factor":         basetypes.Int64Type{},
		"uuid":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EndpointsType{}

type EndpointsType struct {
	basetypes.ObjectType
}

func (t EndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(EndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EndpointsType) String() string {
	return "EndpointsType"
}

func (t EndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EndpointsValue{
		Name:  nameVal,
		Url:   urlVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewEndpointsValueNull() EndpointsValue {
	return EndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewEndpointsValueUnknown() EndpointsValue {
	return EndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EndpointsValue Attribute Value",
				"While creating a EndpointsValue value, a missing attribute value was detected. "+
					"A EndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EndpointsValue Attribute Type",
				"While creating a EndpointsValue value, an invalid attribute value was detected. "+
					"A EndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EndpointsValue Attribute Value",
				"While creating a EndpointsValue value, an extra attribute value was detected. "+
					"A EndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEndpointsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewEndpointsValueUnknown(), diags
	}

	return EndpointsValue{
		Name:  nameVal,
		Url:   urlVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EndpointsValue {
	object, diags := NewEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEndpointsValueMust(EndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EndpointsType) ValueType(ctx context.Context) attr.Value {
	return EndpointsValue{}
}

var _ basetypes.ObjectValuable = EndpointsValue{}

type EndpointsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Url   basetypes.StringValue `tfsdk:"url"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v EndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EndpointsValue) String() string {
	return "EndpointsValue"
}

func (v EndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"url":  basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"url":  v.Url,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v EndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(EndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v EndpointsValue) Type(ctx context.Context) attr.Type {
	return EndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"url":  basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FilesType{}

type FilesType struct {
	basetypes.ObjectType
}

func (t FilesType) Equal(o attr.Type) bool {
	other, ok := o.(FilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FilesType) String() string {
	return "FilesType"
}

func (t FilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return nil, diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FilesValue{
		Created: createdVal,
		File:    fileVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFilesValueNull() FilesValue {
	return FilesValue{
		state: attr.ValueStateNull,
	}
}

func NewFilesValueUnknown() FilesValue {
	return FilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FilesValue Attribute Value",
				"While creating a FilesValue value, a missing attribute value was detected. "+
					"A FilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FilesValue Attribute Type",
				"While creating a FilesValue value, an invalid attribute value was detected. "+
					"A FilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FilesValue Attribute Value",
				"While creating a FilesValue value, an extra attribute value was detected. "+
					"A FilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	return FilesValue{
		Created: createdVal,
		File:    fileVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FilesValue {
	object, diags := NewFilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFilesValueMust(FilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FilesType) ValueType(ctx context.Context) attr.Value {
	return FilesValue{}
}

var _ basetypes.ObjectValuable = FilesValue{}

type FilesValue struct {
	Created basetypes.StringValue `tfsdk:"created"`
	File    basetypes.StringValue `tfsdk:"file"`
	Name    basetypes.StringValue `tfsdk:"name"`
	state   attr.ValueState
}

func (v FilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.File.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["file"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FilesValue) String() string {
	return "FilesValue"
}

func (v FilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created": basetypes.StringType{},
		"file":    basetypes.StringType{},
		"name":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created": v.Created,
			"file":    v.File,
			"name":    v.Name,
		})

	return objVal, diags
}

func (v FilesValue) Equal(o attr.Value) bool {
	other, ok := o.(FilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.File.Equal(other.File) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v FilesValue) Type(ctx context.Context) attr.Type {
	return FilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.StringType{},
		"file":    basetypes.StringType{},
		"name":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	orderAttribute, ok := attributes["order"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order is missing from object`)

		return nil, diags
	}

	orderVal, ok := orderAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order expected to be basetypes.ListValue, was: %T`, orderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		Options: optionsVal,
		Order:   orderVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	orderAttribute, ok := attributes["order"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	orderVal, ok := orderAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order expected to be basetypes.ListValue, was: %T`, orderAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		Options: optionsVal,
		Order:   orderVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	Options basetypes.MapValue  `tfsdk:"options"`
	Order   basetypes.ListValue `tfsdk:"order"`
	state   attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["options"] = basetypes.MapType{
		ElemType: OptionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["order"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.Order.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["order"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	options := types.MapValueMust(
		OptionsType{
			basetypes.ObjectType{
				AttrTypes: OptionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Options.Elements(),
	)

	if v.Options.IsNull() {
		options = types.MapNull(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Options.IsUnknown() {
		options = types.MapUnknown(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var orderVal basetypes.ListValue
	switch {
	case v.Order.IsUnknown():
		orderVal = types.ListUnknown(types.StringType)
	case v.Order.IsNull():
		orderVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		orderVal, d = types.ListValue(types.StringType, v.Order.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"order": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"order": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"options": options,
			"order":   orderVal,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.Order.Equal(other.Order) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"order": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	choicesAttribute, ok := attributes["choices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`choices is missing from object`)

		return nil, diags
	}

	choicesVal, ok := choicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`choices expected to be basetypes.ListValue, was: %T`, choicesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return nil, diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	helpTextAttribute, ok := attributes["help_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`help_text is missing from object`)

		return nil, diags
	}

	helpTextVal, ok := helpTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`help_text expected to be basetypes.StringValue, was: %T`, helpTextAttribute))
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return nil, diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return nil, diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return nil, diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return nil, diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		Choices:     choicesVal,
		Default:     defaultVal,
		HelpText:    helpTextVal,
		Label:       labelVal,
		Max:         maxVal,
		Min:         minVal,
		Required:    requiredVal,
		OptionsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	choicesAttribute, ok := attributes["choices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`choices is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	choicesVal, ok := choicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`choices expected to be basetypes.ListValue, was: %T`, choicesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	helpTextAttribute, ok := attributes["help_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`help_text is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	helpTextVal, ok := helpTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`help_text expected to be basetypes.StringValue, was: %T`, helpTextAttribute))
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		Choices:     choicesVal,
		Default:     defaultVal,
		HelpText:    helpTextVal,
		Label:       labelVal,
		Max:         maxVal,
		Min:         minVal,
		Required:    requiredVal,
		OptionsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	Choices     basetypes.ListValue   `tfsdk:"choices"`
	Default     basetypes.StringValue `tfsdk:"default"`
	HelpText    basetypes.StringValue `tfsdk:"help_text"`
	Label       basetypes.StringValue `tfsdk:"label"`
	Max         basetypes.Int64Value  `tfsdk:"max"`
	Min         basetypes.Int64Value  `tfsdk:"min"`
	Required    basetypes.BoolValue   `tfsdk:"required"`
	OptionsType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["choices"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["help_text"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Choices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["choices"] = val

		val, err = v.Default.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default"] = val

		val, err = v.HelpText.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["help_text"] = val

		val, err = v.Label.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label"] = val

		val, err = v.Max.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max"] = val

		val, err = v.Min.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min"] = val

		val, err = v.Required.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required"] = val

		val, err = v.OptionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var choicesVal basetypes.ListValue
	switch {
	case v.Choices.IsUnknown():
		choicesVal = types.ListUnknown(types.StringType)
	case v.Choices.IsNull():
		choicesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		choicesVal, d = types.ListValue(types.StringType, v.Choices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"choices": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default":   basetypes.StringType{},
			"help_text": basetypes.StringType{},
			"label":     basetypes.StringType{},
			"max":       basetypes.Int64Type{},
			"min":       basetypes.Int64Type{},
			"required":  basetypes.BoolType{},
			"type":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"choices": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default":   basetypes.StringType{},
		"help_text": basetypes.StringType{},
		"label":     basetypes.StringType{},
		"max":       basetypes.Int64Type{},
		"min":       basetypes.Int64Type{},
		"required":  basetypes.BoolType{},
		"type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"choices":   choicesVal,
			"default":   v.Default,
			"help_text": v.HelpText,
			"label":     v.Label,
			"max":       v.Max,
			"min":       v.Min,
			"required":  v.Required,
			"type":      v.OptionsType,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Choices.Equal(other.Choices) {
		return false
	}

	if !v.Default.Equal(other.Default) {
		return false
	}

	if !v.HelpText.Equal(other.HelpText) {
		return false
	}

	if !v.Label.Equal(other.Label) {
		return false
	}

	if !v.Max.Equal(other.Max) {
		return false
	}

	if !v.Min.Equal(other.Min) {
		return false
	}

	if !v.Required.Equal(other.Required) {
		return false
	}

	if !v.OptionsType.Equal(other.OptionsType) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"choices": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default":   basetypes.StringType{},
		"help_text": basetypes.StringType{},
		"label":     basetypes.StringType{},
		"max":       basetypes.Int64Type{},
		"min":       basetypes.Int64Type{},
		"required":  basetypes.BoolType{},
		"type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OrganizationGroupsType{}

type OrganizationGroupsType struct {
	basetypes.ObjectType
}

func (t OrganizationGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(OrganizationGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrganizationGroupsType) String() string {
	return "OrganizationGroupsType"
}

func (t OrganizationGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customersCountAttribute, ok := attributes["customers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customers_count is missing from object`)

		return nil, diags
	}

	customersCountVal, ok := customersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customers_count expected to be basetypes.Int64Value, was: %T`, customersCountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	parentAttribute, ok := attributes["parent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent is missing from object`)

		return nil, diags
	}

	parentVal, ok := parentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent expected to be basetypes.StringValue, was: %T`, parentAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return nil, diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return nil, diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrganizationGroupsValue{
		CustomersCount: customersCountVal,
		Name:           nameVal,
		Parent:         parentVal,
		ParentName:     parentNameVal,
		ParentUuid:     parentUuidVal,
		Url:            urlVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrganizationGroupsValueNull() OrganizationGroupsValue {
	return OrganizationGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewOrganizationGroupsValueUnknown() OrganizationGroupsValue {
	return OrganizationGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrganizationGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrganizationGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrganizationGroupsValue Attribute Value",
				"While creating a OrganizationGroupsValue value, a missing attribute value was detected. "+
					"A OrganizationGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrganizationGroupsValue Attribute Type",
				"While creating a OrganizationGroupsValue value, an invalid attribute value was detected. "+
					"A OrganizationGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrganizationGroupsValue Attribute Value",
				"While creating a OrganizationGroupsValue value, an extra attribute value was detected. "+
					"A OrganizationGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrganizationGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrganizationGroupsValueUnknown(), diags
	}

	customersCountAttribute, ok := attributes["customers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customers_count is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	customersCountVal, ok := customersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customers_count expected to be basetypes.Int64Value, was: %T`, customersCountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	parentAttribute, ok := attributes["parent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentVal, ok := parentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent expected to be basetypes.StringValue, was: %T`, parentAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewOrganizationGroupsValueUnknown(), diags
	}

	return OrganizationGroupsValue{
		CustomersCount: customersCountVal,
		Name:           nameVal,
		Parent:         parentVal,
		ParentName:     parentNameVal,
		ParentUuid:     parentUuidVal,
		Url:            urlVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrganizationGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrganizationGroupsValue {
	object, diags := NewOrganizationGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrganizationGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrganizationGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrganizationGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrganizationGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrganizationGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrganizationGroupsValueMust(OrganizationGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrganizationGroupsType) ValueType(ctx context.Context) attr.Value {
	return OrganizationGroupsValue{}
}

var _ basetypes.ObjectValuable = OrganizationGroupsValue{}

type OrganizationGroupsValue struct {
	CustomersCount basetypes.Int64Value  `tfsdk:"customers_count"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Parent         basetypes.StringValue `tfsdk:"parent"`
	ParentName     basetypes.StringValue `tfsdk:"parent_name"`
	ParentUuid     basetypes.StringValue `tfsdk:"parent_uuid"`
	Url            basetypes.StringValue `tfsdk:"url"`
	Uuid           basetypes.StringValue `tfsdk:"uuid"`
	state          attr.ValueState
}

func (v OrganizationGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["customers_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CustomersCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customers_count"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Parent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent"] = val

		val, err = v.ParentName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_name"] = val

		val, err = v.ParentUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrganizationGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrganizationGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrganizationGroupsValue) String() string {
	return "OrganizationGroupsValue"
}

func (v OrganizationGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"customers_count": basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"parent":          basetypes.StringType{},
		"parent_name":     basetypes.StringType{},
		"parent_uuid":     basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"customers_count": v.CustomersCount,
			"name":            v.Name,
			"parent":          v.Parent,
			"parent_name":     v.ParentName,
			"parent_uuid":     v.ParentUuid,
			"url":             v.Url,
			"uuid":            v.Uuid,
		})

	return objVal, diags
}

func (v OrganizationGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(OrganizationGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomersCount.Equal(other.CustomersCount) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Parent.Equal(other.Parent) {
		return false
	}

	if !v.ParentName.Equal(other.ParentName) {
		return false
	}

	if !v.ParentUuid.Equal(other.ParentUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v OrganizationGroupsValue) Type(ctx context.Context) attr.Type {
	return OrganizationGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrganizationGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"customers_count": basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"parent":          basetypes.StringType{},
		"parent_name":     basetypes.StringType{},
		"parent_uuid":     basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PlansType{}

type PlansType struct {
	basetypes.ObjectType
}

func (t PlansType) Equal(o attr.Type) bool {
	other, ok := o.(PlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlansType) String() string {
	return "PlansType"
}

func (t PlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archivedAttribute, ok := attributes["archived"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archived is missing from object`)

		return nil, diags
	}

	archivedVal, ok := archivedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archived expected to be basetypes.BoolValue, was: %T`, archivedAttribute))
	}

	articleCodeAttribute, ok := attributes["article_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`article_code is missing from object`)

		return nil, diags
	}

	articleCodeVal, ok := articleCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`article_code expected to be basetypes.StringValue, was: %T`, articleCodeAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return nil, diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	futurePricesAttribute, ok := attributes["future_prices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`future_prices is missing from object`)

		return nil, diags
	}

	futurePricesVal, ok := futurePricesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`future_prices expected to be basetypes.MapValue, was: %T`, futurePricesAttribute))
	}

	initPriceAttribute, ok := attributes["init_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`init_price is missing from object`)

		return nil, diags
	}

	initPriceVal, ok := initPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`init_price expected to be basetypes.Float64Value, was: %T`, initPriceAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return nil, diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	maxAmountAttribute, ok := attributes["max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_amount is missing from object`)

		return nil, diags
	}

	maxAmountVal, ok := maxAmountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_amount expected to be basetypes.Int64Value, was: %T`, maxAmountAttribute))
	}

	minimalPriceAttribute, ok := attributes["minimal_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimal_price is missing from object`)

		return nil, diags
	}

	minimalPriceVal, ok := minimalPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimal_price expected to be basetypes.Float64Value, was: %T`, minimalPriceAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	organizationGroupsAttribute, ok := attributes["organization_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_groups is missing from object`)

		return nil, diags
	}

	organizationGroupsVal, ok := organizationGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_groups expected to be basetypes.ListValue, was: %T`, organizationGroupsAttribute))
	}

	planTypeAttribute, ok := attributes["plan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_type is missing from object`)

		return nil, diags
	}

	planTypeVal, ok := planTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_type expected to be basetypes.StringValue, was: %T`, planTypeAttribute))
	}

	pricesAttribute, ok := attributes["prices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prices is missing from object`)

		return nil, diags
	}

	pricesVal, ok := pricesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prices expected to be basetypes.MapValue, was: %T`, pricesAttribute))
	}

	quotasAttribute, ok := attributes["quotas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quotas is missing from object`)

		return nil, diags
	}

	quotasVal, ok := quotasAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quotas expected to be basetypes.MapValue, was: %T`, quotasAttribute))
	}

	resourcesCountAttribute, ok := attributes["resources_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resources_count is missing from object`)

		return nil, diags
	}

	resourcesCountVal, ok := resourcesCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resources_count expected to be basetypes.Int64Value, was: %T`, resourcesCountAttribute))
	}

	switchPriceAttribute, ok := attributes["switch_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_price is missing from object`)

		return nil, diags
	}

	switchPriceVal, ok := switchPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_price expected to be basetypes.Float64Value, was: %T`, switchPriceAttribute))
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be basetypes.StringValue, was: %T`, unitAttribute))
	}

	unitPriceAttribute, ok := attributes["unit_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_price is missing from object`)

		return nil, diags
	}

	unitPriceVal, ok := unitPriceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_price expected to be basetypes.StringValue, was: %T`, unitPriceAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlansValue{
		Archived:           archivedVal,
		ArticleCode:        articleCodeVal,
		BackendId:          backendIdVal,
		Description:        descriptionVal,
		FuturePrices:       futurePricesVal,
		InitPrice:          initPriceVal,
		IsActive:           isActiveVal,
		MaxAmount:          maxAmountVal,
		MinimalPrice:       minimalPriceVal,
		Name:               nameVal,
		OrganizationGroups: organizationGroupsVal,
		PlanType:           planTypeVal,
		Prices:             pricesVal,
		Quotas:             quotasVal,
		ResourcesCount:     resourcesCountVal,
		SwitchPrice:        switchPriceVal,
		Unit:               unitVal,
		UnitPrice:          unitPriceVal,
		Url:                urlVal,
		Uuid:               uuidVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPlansValueNull() PlansValue {
	return PlansValue{
		state: attr.ValueStateNull,
	}
}

func NewPlansValueUnknown() PlansValue {
	return PlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlansValue Attribute Value",
				"While creating a PlansValue value, a missing attribute value was detected. "+
					"A PlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlansValue Attribute Type",
				"While creating a PlansValue value, an invalid attribute value was detected. "+
					"A PlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlansValue Attribute Value",
				"While creating a PlansValue value, an extra attribute value was detected. "+
					"A PlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlansValueUnknown(), diags
	}

	archivedAttribute, ok := attributes["archived"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archived is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	archivedVal, ok := archivedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archived expected to be basetypes.BoolValue, was: %T`, archivedAttribute))
	}

	articleCodeAttribute, ok := attributes["article_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`article_code is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	articleCodeVal, ok := articleCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`article_code expected to be basetypes.StringValue, was: %T`, articleCodeAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	futurePricesAttribute, ok := attributes["future_prices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`future_prices is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	futurePricesVal, ok := futurePricesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`future_prices expected to be basetypes.MapValue, was: %T`, futurePricesAttribute))
	}

	initPriceAttribute, ok := attributes["init_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`init_price is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	initPriceVal, ok := initPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`init_price expected to be basetypes.Float64Value, was: %T`, initPriceAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	maxAmountAttribute, ok := attributes["max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_amount is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	maxAmountVal, ok := maxAmountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_amount expected to be basetypes.Int64Value, was: %T`, maxAmountAttribute))
	}

	minimalPriceAttribute, ok := attributes["minimal_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimal_price is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	minimalPriceVal, ok := minimalPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimal_price expected to be basetypes.Float64Value, was: %T`, minimalPriceAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	organizationGroupsAttribute, ok := attributes["organization_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_groups is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	organizationGroupsVal, ok := organizationGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_groups expected to be basetypes.ListValue, was: %T`, organizationGroupsAttribute))
	}

	planTypeAttribute, ok := attributes["plan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_type is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	planTypeVal, ok := planTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_type expected to be basetypes.StringValue, was: %T`, planTypeAttribute))
	}

	pricesAttribute, ok := attributes["prices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prices is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	pricesVal, ok := pricesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prices expected to be basetypes.MapValue, was: %T`, pricesAttribute))
	}

	quotasAttribute, ok := attributes["quotas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quotas is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	quotasVal, ok := quotasAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quotas expected to be basetypes.MapValue, was: %T`, quotasAttribute))
	}

	resourcesCountAttribute, ok := attributes["resources_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resources_count is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	resourcesCountVal, ok := resourcesCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resources_count expected to be basetypes.Int64Value, was: %T`, resourcesCountAttribute))
	}

	switchPriceAttribute, ok := attributes["switch_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_price is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	switchPriceVal, ok := switchPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_price expected to be basetypes.Float64Value, was: %T`, switchPriceAttribute))
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be basetypes.StringValue, was: %T`, unitAttribute))
	}

	unitPriceAttribute, ok := attributes["unit_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_price is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	unitPriceVal, ok := unitPriceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_price expected to be basetypes.StringValue, was: %T`, unitPriceAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewPlansValueUnknown(), diags
	}

	return PlansValue{
		Archived:           archivedVal,
		ArticleCode:        articleCodeVal,
		BackendId:          backendIdVal,
		Description:        descriptionVal,
		FuturePrices:       futurePricesVal,
		InitPrice:          initPriceVal,
		IsActive:           isActiveVal,
		MaxAmount:          maxAmountVal,
		MinimalPrice:       minimalPriceVal,
		Name:               nameVal,
		OrganizationGroups: organizationGroupsVal,
		PlanType:           planTypeVal,
		Prices:             pricesVal,
		Quotas:             quotasVal,
		ResourcesCount:     resourcesCountVal,
		SwitchPrice:        switchPriceVal,
		Unit:               unitVal,
		UnitPrice:          unitPriceVal,
		Url:                urlVal,
		Uuid:               uuidVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlansValue {
	object, diags := NewPlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlansValueMust(PlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlansType) ValueType(ctx context.Context) attr.Value {
	return PlansValue{}
}

var _ basetypes.ObjectValuable = PlansValue{}

type PlansValue struct {
	Archived           basetypes.BoolValue    `tfsdk:"archived"`
	ArticleCode        basetypes.StringValue  `tfsdk:"article_code"`
	BackendId          basetypes.StringValue  `tfsdk:"backend_id"`
	Description        basetypes.StringValue  `tfsdk:"description"`
	FuturePrices       basetypes.MapValue     `tfsdk:"future_prices"`
	InitPrice          basetypes.Float64Value `tfsdk:"init_price"`
	IsActive           basetypes.BoolValue    `tfsdk:"is_active"`
	MaxAmount          basetypes.Int64Value   `tfsdk:"max_amount"`
	MinimalPrice       basetypes.Float64Value `tfsdk:"minimal_price"`
	Name               basetypes.StringValue  `tfsdk:"name"`
	OrganizationGroups basetypes.ListValue    `tfsdk:"organization_groups"`
	PlanType           basetypes.StringValue  `tfsdk:"plan_type"`
	Prices             basetypes.MapValue     `tfsdk:"prices"`
	Quotas             basetypes.MapValue     `tfsdk:"quotas"`
	ResourcesCount     basetypes.Int64Value   `tfsdk:"resources_count"`
	SwitchPrice        basetypes.Float64Value `tfsdk:"switch_price"`
	Unit               basetypes.StringValue  `tfsdk:"unit"`
	UnitPrice          basetypes.StringValue  `tfsdk:"unit_price"`
	Url                basetypes.StringValue  `tfsdk:"url"`
	Uuid               basetypes.StringValue  `tfsdk:"uuid"`
	state              attr.ValueState
}

func (v PlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 20)

	var val tftypes.Value
	var err error

	attrTypes["archived"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["article_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backend_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["future_prices"] = basetypes.MapType{
		ElemType: types.Float64Type,
	}.TerraformType(ctx)
	attrTypes["init_price"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["is_active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_amount"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimal_price"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["organization_groups"] = basetypes.ListType{
		ElemType: OrganizationGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["plan_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prices"] = basetypes.MapType{
		ElemType: types.Float64Type,
	}.TerraformType(ctx)
	attrTypes["quotas"] = basetypes.MapType{
		ElemType: types.Float64Type,
	}.TerraformType(ctx)
	attrTypes["resources_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["switch_price"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unit_price"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 20)

		val, err = v.Archived.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archived"] = val

		val, err = v.ArticleCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["article_code"] = val

		val, err = v.BackendId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_id"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.FuturePrices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["future_prices"] = val

		val, err = v.InitPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["init_price"] = val

		val, err = v.IsActive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_active"] = val

		val, err = v.MaxAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_amount"] = val

		val, err = v.MinimalPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimal_price"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrganizationGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["organization_groups"] = val

		val, err = v.PlanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_type"] = val

		val, err = v.Prices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prices"] = val

		val, err = v.Quotas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quotas"] = val

		val, err = v.ResourcesCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resources_count"] = val

		val, err = v.SwitchPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["switch_price"] = val

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.UnitPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit_price"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlansValue) String() string {
	return "PlansValue"
}

func (v PlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	organizationGroups := types.ListValueMust(
		OrganizationGroupsType{
			basetypes.ObjectType{
				AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.OrganizationGroups.Elements(),
	)

	if v.OrganizationGroups.IsNull() {
		organizationGroups = types.ListNull(
			OrganizationGroupsType{
				basetypes.ObjectType{
					AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OrganizationGroups.IsUnknown() {
		organizationGroups = types.ListUnknown(
			OrganizationGroupsType{
				basetypes.ObjectType{
					AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var futurePricesVal basetypes.MapValue
	switch {
	case v.FuturePrices.IsUnknown():
		futurePricesVal = types.MapUnknown(types.Float64Type)
	case v.FuturePrices.IsNull():
		futurePricesVal = types.MapNull(types.Float64Type)
	default:
		var d diag.Diagnostics
		futurePricesVal, d = types.MapValue(types.Float64Type, v.FuturePrices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"archived":     basetypes.BoolType{},
			"article_code": basetypes.StringType{},
			"backend_id":   basetypes.StringType{},
			"description":  basetypes.StringType{},
			"future_prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"init_price":    basetypes.Float64Type{},
			"is_active":     basetypes.BoolType{},
			"max_amount":    basetypes.Int64Type{},
			"minimal_price": basetypes.Float64Type{},
			"name":          basetypes.StringType{},
			"organization_groups": basetypes.ListType{
				ElemType: OrganizationGroupsValue{}.Type(ctx),
			},
			"plan_type": basetypes.StringType{},
			"prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"quotas": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"resources_count": basetypes.Int64Type{},
			"switch_price":    basetypes.Float64Type{},
			"unit":            basetypes.StringType{},
			"unit_price":      basetypes.StringType{},
			"url":             basetypes.StringType{},
			"uuid":            basetypes.StringType{},
		}), diags
	}

	var pricesVal basetypes.MapValue
	switch {
	case v.Prices.IsUnknown():
		pricesVal = types.MapUnknown(types.Float64Type)
	case v.Prices.IsNull():
		pricesVal = types.MapNull(types.Float64Type)
	default:
		var d diag.Diagnostics
		pricesVal, d = types.MapValue(types.Float64Type, v.Prices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"archived":     basetypes.BoolType{},
			"article_code": basetypes.StringType{},
			"backend_id":   basetypes.StringType{},
			"description":  basetypes.StringType{},
			"future_prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"init_price":    basetypes.Float64Type{},
			"is_active":     basetypes.BoolType{},
			"max_amount":    basetypes.Int64Type{},
			"minimal_price": basetypes.Float64Type{},
			"name":          basetypes.StringType{},
			"organization_groups": basetypes.ListType{
				ElemType: OrganizationGroupsValue{}.Type(ctx),
			},
			"plan_type": basetypes.StringType{},
			"prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"quotas": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"resources_count": basetypes.Int64Type{},
			"switch_price":    basetypes.Float64Type{},
			"unit":            basetypes.StringType{},
			"unit_price":      basetypes.StringType{},
			"url":             basetypes.StringType{},
			"uuid":            basetypes.StringType{},
		}), diags
	}

	var quotasVal basetypes.MapValue
	switch {
	case v.Quotas.IsUnknown():
		quotasVal = types.MapUnknown(types.Float64Type)
	case v.Quotas.IsNull():
		quotasVal = types.MapNull(types.Float64Type)
	default:
		var d diag.Diagnostics
		quotasVal, d = types.MapValue(types.Float64Type, v.Quotas.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"archived":     basetypes.BoolType{},
			"article_code": basetypes.StringType{},
			"backend_id":   basetypes.StringType{},
			"description":  basetypes.StringType{},
			"future_prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"init_price":    basetypes.Float64Type{},
			"is_active":     basetypes.BoolType{},
			"max_amount":    basetypes.Int64Type{},
			"minimal_price": basetypes.Float64Type{},
			"name":          basetypes.StringType{},
			"organization_groups": basetypes.ListType{
				ElemType: OrganizationGroupsValue{}.Type(ctx),
			},
			"plan_type": basetypes.StringType{},
			"prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"quotas": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"resources_count": basetypes.Int64Type{},
			"switch_price":    basetypes.Float64Type{},
			"unit":            basetypes.StringType{},
			"unit_price":      basetypes.StringType{},
			"url":             basetypes.StringType{},
			"uuid":            basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"archived":     basetypes.BoolType{},
		"article_code": basetypes.StringType{},
		"backend_id":   basetypes.StringType{},
		"description":  basetypes.StringType{},
		"future_prices": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"init_price":    basetypes.Float64Type{},
		"is_active":     basetypes.BoolType{},
		"max_amount":    basetypes.Int64Type{},
		"minimal_price": basetypes.Float64Type{},
		"name":          basetypes.StringType{},
		"organization_groups": basetypes.ListType{
			ElemType: OrganizationGroupsValue{}.Type(ctx),
		},
		"plan_type": basetypes.StringType{},
		"prices": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"quotas": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"resources_count": basetypes.Int64Type{},
		"switch_price":    basetypes.Float64Type{},
		"unit":            basetypes.StringType{},
		"unit_price":      basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"archived":            v.Archived,
			"article_code":        v.ArticleCode,
			"backend_id":          v.BackendId,
			"description":         v.Description,
			"future_prices":       futurePricesVal,
			"init_price":          v.InitPrice,
			"is_active":           v.IsActive,
			"max_amount":          v.MaxAmount,
			"minimal_price":       v.MinimalPrice,
			"name":                v.Name,
			"organization_groups": organizationGroups,
			"plan_type":           v.PlanType,
			"prices":              pricesVal,
			"quotas":              quotasVal,
			"resources_count":     v.ResourcesCount,
			"switch_price":        v.SwitchPrice,
			"unit":                v.Unit,
			"unit_price":          v.UnitPrice,
			"url":                 v.Url,
			"uuid":                v.Uuid,
		})

	return objVal, diags
}

func (v PlansValue) Equal(o attr.Value) bool {
	other, ok := o.(PlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archived.Equal(other.Archived) {
		return false
	}

	if !v.ArticleCode.Equal(other.ArticleCode) {
		return false
	}

	if !v.BackendId.Equal(other.BackendId) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.FuturePrices.Equal(other.FuturePrices) {
		return false
	}

	if !v.InitPrice.Equal(other.InitPrice) {
		return false
	}

	if !v.IsActive.Equal(other.IsActive) {
		return false
	}

	if !v.MaxAmount.Equal(other.MaxAmount) {
		return false
	}

	if !v.MinimalPrice.Equal(other.MinimalPrice) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrganizationGroups.Equal(other.OrganizationGroups) {
		return false
	}

	if !v.PlanType.Equal(other.PlanType) {
		return false
	}

	if !v.Prices.Equal(other.Prices) {
		return false
	}

	if !v.Quotas.Equal(other.Quotas) {
		return false
	}

	if !v.ResourcesCount.Equal(other.ResourcesCount) {
		return false
	}

	if !v.SwitchPrice.Equal(other.SwitchPrice) {
		return false
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.UnitPrice.Equal(other.UnitPrice) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v PlansValue) Type(ctx context.Context) attr.Type {
	return PlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archived":     basetypes.BoolType{},
		"article_code": basetypes.StringType{},
		"backend_id":   basetypes.StringType{},
		"description":  basetypes.StringType{},
		"future_prices": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"init_price":    basetypes.Float64Type{},
		"is_active":     basetypes.BoolType{},
		"max_amount":    basetypes.Int64Type{},
		"minimal_price": basetypes.Float64Type{},
		"name":          basetypes.StringType{},
		"organization_groups": basetypes.ListType{
			ElemType: OrganizationGroupsValue{}.Type(ctx),
		},
		"plan_type": basetypes.StringType{},
		"prices": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"quotas": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"resources_count": basetypes.Int64Type{},
		"switch_price":    basetypes.Float64Type{},
		"unit":            basetypes.StringType{},
		"unit_price":      basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OrganizationGroupsType{}

type OrganizationGroupsType struct {
	basetypes.ObjectType
}

func (t OrganizationGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(OrganizationGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrganizationGroupsType) String() string {
	return "OrganizationGroupsType"
}

func (t OrganizationGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customersCountAttribute, ok := attributes["customers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customers_count is missing from object`)

		return nil, diags
	}

	customersCountVal, ok := customersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customers_count expected to be basetypes.Int64Value, was: %T`, customersCountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	parentAttribute, ok := attributes["parent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent is missing from object`)

		return nil, diags
	}

	parentVal, ok := parentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent expected to be basetypes.StringValue, was: %T`, parentAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return nil, diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return nil, diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrganizationGroupsValue{
		CustomersCount: customersCountVal,
		Name:           nameVal,
		Parent:         parentVal,
		ParentName:     parentNameVal,
		ParentUuid:     parentUuidVal,
		Url:            urlVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrganizationGroupsValueNull() OrganizationGroupsValue {
	return OrganizationGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewOrganizationGroupsValueUnknown() OrganizationGroupsValue {
	return OrganizationGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrganizationGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrganizationGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrganizationGroupsValue Attribute Value",
				"While creating a OrganizationGroupsValue value, a missing attribute value was detected. "+
					"A OrganizationGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrganizationGroupsValue Attribute Type",
				"While creating a OrganizationGroupsValue value, an invalid attribute value was detected. "+
					"A OrganizationGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrganizationGroupsValue Attribute Value",
				"While creating a OrganizationGroupsValue value, an extra attribute value was detected. "+
					"A OrganizationGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrganizationGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrganizationGroupsValueUnknown(), diags
	}

	customersCountAttribute, ok := attributes["customers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customers_count is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	customersCountVal, ok := customersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customers_count expected to be basetypes.Int64Value, was: %T`, customersCountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	parentAttribute, ok := attributes["parent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentVal, ok := parentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent expected to be basetypes.StringValue, was: %T`, parentAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewOrganizationGroupsValueUnknown(), diags
	}

	return OrganizationGroupsValue{
		CustomersCount: customersCountVal,
		Name:           nameVal,
		Parent:         parentVal,
		ParentName:     parentNameVal,
		ParentUuid:     parentUuidVal,
		Url:            urlVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrganizationGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrganizationGroupsValue {
	object, diags := NewOrganizationGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrganizationGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrganizationGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrganizationGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrganizationGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrganizationGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrganizationGroupsValueMust(OrganizationGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrganizationGroupsType) ValueType(ctx context.Context) attr.Value {
	return OrganizationGroupsValue{}
}

var _ basetypes.ObjectValuable = OrganizationGroupsValue{}

type OrganizationGroupsValue struct {
	CustomersCount basetypes.Int64Value  `tfsdk:"customers_count"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Parent         basetypes.StringValue `tfsdk:"parent"`
	ParentName     basetypes.StringValue `tfsdk:"parent_name"`
	ParentUuid     basetypes.StringValue `tfsdk:"parent_uuid"`
	Url            basetypes.StringValue `tfsdk:"url"`
	Uuid           basetypes.StringValue `tfsdk:"uuid"`
	state          attr.ValueState
}

func (v OrganizationGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["customers_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CustomersCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customers_count"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Parent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent"] = val

		val, err = v.ParentName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_name"] = val

		val, err = v.ParentUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrganizationGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrganizationGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrganizationGroupsValue) String() string {
	return "OrganizationGroupsValue"
}

func (v OrganizationGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"customers_count": basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"parent":          basetypes.StringType{},
		"parent_name":     basetypes.StringType{},
		"parent_uuid":     basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"customers_count": v.CustomersCount,
			"name":            v.Name,
			"parent":          v.Parent,
			"parent_name":     v.ParentName,
			"parent_uuid":     v.ParentUuid,
			"url":             v.Url,
			"uuid":            v.Uuid,
		})

	return objVal, diags
}

func (v OrganizationGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(OrganizationGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomersCount.Equal(other.CustomersCount) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Parent.Equal(other.Parent) {
		return false
	}

	if !v.ParentName.Equal(other.ParentName) {
		return false
	}

	if !v.ParentUuid.Equal(other.ParentUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v OrganizationGroupsValue) Type(ctx context.Context) attr.Type {
	return OrganizationGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrganizationGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"customers_count": basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"parent":          basetypes.StringType{},
		"parent_name":     basetypes.StringType{},
		"parent_uuid":     basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PluginOptionsType{}

type PluginOptionsType struct {
	basetypes.ObjectType
}

func (t PluginOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(PluginOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PluginOptionsType) String() string {
	return "PluginOptionsType"
}

func (t PluginOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoApproveInServiceProviderProjectsAttribute, ok := attributes["auto_approve_in_service_provider_projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_in_service_provider_projects is missing from object`)

		return nil, diags
	}

	autoApproveInServiceProviderProjectsVal, ok := autoApproveInServiceProviderProjectsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_in_service_provider_projects expected to be basetypes.BoolValue, was: %T`, autoApproveInServiceProviderProjectsAttribute))
	}

	autoApproveRemoteOrdersAttribute, ok := attributes["auto_approve_remote_orders"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_remote_orders is missing from object`)

		return nil, diags
	}

	autoApproveRemoteOrdersVal, ok := autoApproveRemoteOrdersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_remote_orders expected to be basetypes.BoolValue, was: %T`, autoApproveRemoteOrdersAttribute))
	}

	defaultInternalNetworkMtuAttribute, ok := attributes["default_internal_network_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_internal_network_mtu is missing from object`)

		return nil, diags
	}

	defaultInternalNetworkMtuVal, ok := defaultInternalNetworkMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_internal_network_mtu expected to be basetypes.Int64Value, was: %T`, defaultInternalNetworkMtuAttribute))
	}

	defaultResourceTerminationOffsetInDaysAttribute, ok := attributes["default_resource_termination_offset_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_resource_termination_offset_in_days is missing from object`)

		return nil, diags
	}

	defaultResourceTerminationOffsetInDaysVal, ok := defaultResourceTerminationOffsetInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_resource_termination_offset_in_days expected to be basetypes.Int64Value, was: %T`, defaultResourceTerminationOffsetInDaysAttribute))
	}

	enableIssuesForMembershipChangesAttribute, ok := attributes["enable_issues_for_membership_changes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_issues_for_membership_changes is missing from object`)

		return nil, diags
	}

	enableIssuesForMembershipChangesVal, ok := enableIssuesForMembershipChangesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_issues_for_membership_changes expected to be basetypes.BoolValue, was: %T`, enableIssuesForMembershipChangesAttribute))
	}

	flavorsRegexAttribute, ok := attributes["flavors_regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavors_regex is missing from object`)

		return nil, diags
	}

	flavorsRegexVal, ok := flavorsRegexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavors_regex expected to be basetypes.StringValue, was: %T`, flavorsRegexAttribute))
	}

	heappeClusterIdAttribute, ok := attributes["heappe_cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_cluster_id is missing from object`)

		return nil, diags
	}

	heappeClusterIdVal, ok := heappeClusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_cluster_id expected to be basetypes.StringValue, was: %T`, heappeClusterIdAttribute))
	}

	heappeLocalBasePathAttribute, ok := attributes["heappe_local_base_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_local_base_path is missing from object`)

		return nil, diags
	}

	heappeLocalBasePathVal, ok := heappeLocalBasePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_local_base_path expected to be basetypes.StringValue, was: %T`, heappeLocalBasePathAttribute))
	}

	heappeUrlAttribute, ok := attributes["heappe_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_url is missing from object`)

		return nil, diags
	}

	heappeUrlVal, ok := heappeUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_url expected to be basetypes.StringValue, was: %T`, heappeUrlAttribute))
	}

	heappeUsernameAttribute, ok := attributes["heappe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_username is missing from object`)

		return nil, diags
	}

	heappeUsernameVal, ok := heappeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_username expected to be basetypes.StringValue, was: %T`, heappeUsernameAttribute))
	}

	homedirPrefixAttribute, ok := attributes["homedir_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`homedir_prefix is missing from object`)

		return nil, diags
	}

	homedirPrefixVal, ok := homedirPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`homedir_prefix expected to be basetypes.StringValue, was: %T`, homedirPrefixAttribute))
	}

	initialPrimarygroupNumberAttribute, ok := attributes["initial_primarygroup_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_primarygroup_number is missing from object`)

		return nil, diags
	}

	initialPrimarygroupNumberVal, ok := initialPrimarygroupNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_primarygroup_number expected to be basetypes.Int64Value, was: %T`, initialPrimarygroupNumberAttribute))
	}

	initialUidnumberAttribute, ok := attributes["initial_uidnumber"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_uidnumber is missing from object`)

		return nil, diags
	}

	initialUidnumberVal, ok := initialUidnumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_uidnumber expected to be basetypes.Int64Value, was: %T`, initialUidnumberAttribute))
	}

	initialUsergroupNumberAttribute, ok := attributes["initial_usergroup_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_usergroup_number is missing from object`)

		return nil, diags
	}

	initialUsergroupNumberVal, ok := initialUsergroupNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_usergroup_number expected to be basetypes.Int64Value, was: %T`, initialUsergroupNumberAttribute))
	}

	isResourceTerminationDateRequiredAttribute, ok := attributes["is_resource_termination_date_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_resource_termination_date_required is missing from object`)

		return nil, diags
	}

	isResourceTerminationDateRequiredVal, ok := isResourceTerminationDateRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_resource_termination_date_required expected to be basetypes.BoolValue, was: %T`, isResourceTerminationDateRequiredAttribute))
	}

	latestDateForResourceTerminationAttribute, ok := attributes["latest_date_for_resource_termination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_date_for_resource_termination is missing from object`)

		return nil, diags
	}

	latestDateForResourceTerminationVal, ok := latestDateForResourceTerminationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_date_for_resource_termination expected to be basetypes.StringValue, was: %T`, latestDateForResourceTerminationAttribute))
	}

	managedRancherLoadBalancerCloudInitTemplateAttribute, ok := attributes["managed_rancher_load_balancer_cloud_init_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_cloud_init_template is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerCloudInitTemplateVal, ok := managedRancherLoadBalancerCloudInitTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_cloud_init_template expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerCloudInitTemplateAttribute))
	}

	managedRancherLoadBalancerDataVolumeSizeGbAttribute, ok := attributes["managed_rancher_load_balancer_data_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_data_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerDataVolumeSizeGbVal, ok := managedRancherLoadBalancerDataVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_data_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherLoadBalancerDataVolumeSizeGbAttribute))
	}

	managedRancherLoadBalancerDataVolumeTypeNameAttribute, ok := attributes["managed_rancher_load_balancer_data_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_data_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerDataVolumeTypeNameVal, ok := managedRancherLoadBalancerDataVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_data_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerDataVolumeTypeNameAttribute))
	}

	managedRancherLoadBalancerFlavorNameAttribute, ok := attributes["managed_rancher_load_balancer_flavor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_flavor_name is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerFlavorNameVal, ok := managedRancherLoadBalancerFlavorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_flavor_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerFlavorNameAttribute))
	}

	managedRancherLoadBalancerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_load_balancer_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_system_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerSystemVolumeSizeGbVal, ok := managedRancherLoadBalancerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherLoadBalancerSystemVolumeSizeGbAttribute))
	}

	managedRancherLoadBalancerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_load_balancer_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_system_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerSystemVolumeTypeNameVal, ok := managedRancherLoadBalancerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerSystemVolumeTypeNameAttribute))
	}

	managedRancherServerDataVolumeSizeGbAttribute, ok := attributes["managed_rancher_server_data_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_data_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherServerDataVolumeSizeGbVal, ok := managedRancherServerDataVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_data_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherServerDataVolumeSizeGbAttribute))
	}

	managedRancherServerDataVolumeTypeNameAttribute, ok := attributes["managed_rancher_server_data_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_data_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherServerDataVolumeTypeNameVal, ok := managedRancherServerDataVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_data_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherServerDataVolumeTypeNameAttribute))
	}

	managedRancherServerFlavorNameAttribute, ok := attributes["managed_rancher_server_flavor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_flavor_name is missing from object`)

		return nil, diags
	}

	managedRancherServerFlavorNameVal, ok := managedRancherServerFlavorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_flavor_name expected to be basetypes.StringValue, was: %T`, managedRancherServerFlavorNameAttribute))
	}

	managedRancherServerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_server_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_system_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherServerSystemVolumeSizeGbVal, ok := managedRancherServerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherServerSystemVolumeSizeGbAttribute))
	}

	managedRancherServerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_server_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_system_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherServerSystemVolumeTypeNameVal, ok := managedRancherServerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherServerSystemVolumeTypeNameAttribute))
	}

	managedRancherWorkerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_worker_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_worker_system_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherWorkerSystemVolumeSizeGbVal, ok := managedRancherWorkerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_worker_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherWorkerSystemVolumeSizeGbAttribute))
	}

	managedRancherWorkerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_worker_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_worker_system_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherWorkerSystemVolumeTypeNameVal, ok := managedRancherWorkerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_worker_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherWorkerSystemVolumeTypeNameAttribute))
	}

	maxInstancesAttribute, ok := attributes["max_instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_instances is missing from object`)

		return nil, diags
	}

	maxInstancesVal, ok := maxInstancesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_instances expected to be basetypes.Int64Value, was: %T`, maxInstancesAttribute))
	}

	maxResourceTerminationOffsetInDaysAttribute, ok := attributes["max_resource_termination_offset_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_resource_termination_offset_in_days is missing from object`)

		return nil, diags
	}

	maxResourceTerminationOffsetInDaysVal, ok := maxResourceTerminationOffsetInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_resource_termination_offset_in_days expected to be basetypes.Int64Value, was: %T`, maxResourceTerminationOffsetInDaysAttribute))
	}

	maxVolumesAttribute, ok := attributes["max_volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_volumes is missing from object`)

		return nil, diags
	}

	maxVolumesVal, ok := maxVolumesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_volumes expected to be basetypes.Int64Value, was: %T`, maxVolumesAttribute))
	}

	openstackOfferingUuidListAttribute, ok := attributes["openstack_offering_uuid_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`openstack_offering_uuid_list is missing from object`)

		return nil, diags
	}

	openstackOfferingUuidListVal, ok := openstackOfferingUuidListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`openstack_offering_uuid_list expected to be basetypes.ListValue, was: %T`, openstackOfferingUuidListAttribute))
	}

	serviceProviderCanCreateOfferingUserAttribute, ok := attributes["service_provider_can_create_offering_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_provider_can_create_offering_user is missing from object`)

		return nil, diags
	}

	serviceProviderCanCreateOfferingUserVal, ok := serviceProviderCanCreateOfferingUserAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_provider_can_create_offering_user expected to be basetypes.BoolValue, was: %T`, serviceProviderCanCreateOfferingUserAttribute))
	}

	snapshotSizeLimitGbAttribute, ok := attributes["snapshot_size_limit_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot_size_limit_gb is missing from object`)

		return nil, diags
	}

	snapshotSizeLimitGbVal, ok := snapshotSizeLimitGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot_size_limit_gb expected to be basetypes.Int64Value, was: %T`, snapshotSizeLimitGbAttribute))
	}

	storageModeAttribute, ok := attributes["storage_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_mode is missing from object`)

		return nil, diags
	}

	storageModeVal, ok := storageModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_mode expected to be basetypes.StringValue, was: %T`, storageModeAttribute))
	}

	supportsDownscalingAttribute, ok := attributes["supports_downscaling"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supports_downscaling is missing from object`)

		return nil, diags
	}

	supportsDownscalingVal, ok := supportsDownscalingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supports_downscaling expected to be basetypes.BoolValue, was: %T`, supportsDownscalingAttribute))
	}

	supportsPausingAttribute, ok := attributes["supports_pausing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supports_pausing is missing from object`)

		return nil, diags
	}

	supportsPausingVal, ok := supportsPausingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supports_pausing expected to be basetypes.BoolValue, was: %T`, supportsPausingAttribute))
	}

	usernameAnonymizedPrefixAttribute, ok := attributes["username_anonymized_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_anonymized_prefix is missing from object`)

		return nil, diags
	}

	usernameAnonymizedPrefixVal, ok := usernameAnonymizedPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_anonymized_prefix expected to be basetypes.StringValue, was: %T`, usernameAnonymizedPrefixAttribute))
	}

	usernameGenerationPolicyAttribute, ok := attributes["username_generation_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_generation_policy is missing from object`)

		return nil, diags
	}

	usernameGenerationPolicyVal, ok := usernameGenerationPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_generation_policy expected to be basetypes.StringValue, was: %T`, usernameGenerationPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PluginOptionsValue{
		AutoApproveInServiceProviderProjects:           autoApproveInServiceProviderProjectsVal,
		AutoApproveRemoteOrders:                        autoApproveRemoteOrdersVal,
		DefaultInternalNetworkMtu:                      defaultInternalNetworkMtuVal,
		DefaultResourceTerminationOffsetInDays:         defaultResourceTerminationOffsetInDaysVal,
		EnableIssuesForMembershipChanges:               enableIssuesForMembershipChangesVal,
		FlavorsRegex:                                   flavorsRegexVal,
		HeappeClusterId:                                heappeClusterIdVal,
		HeappeLocalBasePath:                            heappeLocalBasePathVal,
		HeappeUrl:                                      heappeUrlVal,
		HeappeUsername:                                 heappeUsernameVal,
		HomedirPrefix:                                  homedirPrefixVal,
		InitialPrimarygroupNumber:                      initialPrimarygroupNumberVal,
		InitialUidnumber:                               initialUidnumberVal,
		InitialUsergroupNumber:                         initialUsergroupNumberVal,
		IsResourceTerminationDateRequired:              isResourceTerminationDateRequiredVal,
		LatestDateForResourceTermination:               latestDateForResourceTerminationVal,
		ManagedRancherLoadBalancerCloudInitTemplate:    managedRancherLoadBalancerCloudInitTemplateVal,
		ManagedRancherLoadBalancerDataVolumeSizeGb:     managedRancherLoadBalancerDataVolumeSizeGbVal,
		ManagedRancherLoadBalancerDataVolumeTypeName:   managedRancherLoadBalancerDataVolumeTypeNameVal,
		ManagedRancherLoadBalancerFlavorName:           managedRancherLoadBalancerFlavorNameVal,
		ManagedRancherLoadBalancerSystemVolumeSizeGb:   managedRancherLoadBalancerSystemVolumeSizeGbVal,
		ManagedRancherLoadBalancerSystemVolumeTypeName: managedRancherLoadBalancerSystemVolumeTypeNameVal,
		ManagedRancherServerDataVolumeSizeGb:           managedRancherServerDataVolumeSizeGbVal,
		ManagedRancherServerDataVolumeTypeName:         managedRancherServerDataVolumeTypeNameVal,
		ManagedRancherServerFlavorName:                 managedRancherServerFlavorNameVal,
		ManagedRancherServerSystemVolumeSizeGb:         managedRancherServerSystemVolumeSizeGbVal,
		ManagedRancherServerSystemVolumeTypeName:       managedRancherServerSystemVolumeTypeNameVal,
		ManagedRancherWorkerSystemVolumeSizeGb:         managedRancherWorkerSystemVolumeSizeGbVal,
		ManagedRancherWorkerSystemVolumeTypeName:       managedRancherWorkerSystemVolumeTypeNameVal,
		MaxInstances:                                   maxInstancesVal,
		MaxResourceTerminationOffsetInDays:             maxResourceTerminationOffsetInDaysVal,
		MaxVolumes:                                     maxVolumesVal,
		OpenstackOfferingUuidList:                      openstackOfferingUuidListVal,
		ServiceProviderCanCreateOfferingUser:           serviceProviderCanCreateOfferingUserVal,
		SnapshotSizeLimitGb:                            snapshotSizeLimitGbVal,
		StorageMode:                                    storageModeVal,
		SupportsDownscaling:                            supportsDownscalingVal,
		SupportsPausing:                                supportsPausingVal,
		UsernameAnonymizedPrefix:                       usernameAnonymizedPrefixVal,
		UsernameGenerationPolicy:                       usernameGenerationPolicyVal,
		state:                                          attr.ValueStateKnown,
	}, diags
}

func NewPluginOptionsValueNull() PluginOptionsValue {
	return PluginOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewPluginOptionsValueUnknown() PluginOptionsValue {
	return PluginOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPluginOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PluginOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PluginOptionsValue Attribute Value",
				"While creating a PluginOptionsValue value, a missing attribute value was detected. "+
					"A PluginOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PluginOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PluginOptionsValue Attribute Type",
				"While creating a PluginOptionsValue value, an invalid attribute value was detected. "+
					"A PluginOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PluginOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PluginOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PluginOptionsValue Attribute Value",
				"While creating a PluginOptionsValue value, an extra attribute value was detected. "+
					"A PluginOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PluginOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPluginOptionsValueUnknown(), diags
	}

	autoApproveInServiceProviderProjectsAttribute, ok := attributes["auto_approve_in_service_provider_projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_in_service_provider_projects is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	autoApproveInServiceProviderProjectsVal, ok := autoApproveInServiceProviderProjectsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_in_service_provider_projects expected to be basetypes.BoolValue, was: %T`, autoApproveInServiceProviderProjectsAttribute))
	}

	autoApproveRemoteOrdersAttribute, ok := attributes["auto_approve_remote_orders"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_remote_orders is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	autoApproveRemoteOrdersVal, ok := autoApproveRemoteOrdersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_remote_orders expected to be basetypes.BoolValue, was: %T`, autoApproveRemoteOrdersAttribute))
	}

	defaultInternalNetworkMtuAttribute, ok := attributes["default_internal_network_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_internal_network_mtu is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	defaultInternalNetworkMtuVal, ok := defaultInternalNetworkMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_internal_network_mtu expected to be basetypes.Int64Value, was: %T`, defaultInternalNetworkMtuAttribute))
	}

	defaultResourceTerminationOffsetInDaysAttribute, ok := attributes["default_resource_termination_offset_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_resource_termination_offset_in_days is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	defaultResourceTerminationOffsetInDaysVal, ok := defaultResourceTerminationOffsetInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_resource_termination_offset_in_days expected to be basetypes.Int64Value, was: %T`, defaultResourceTerminationOffsetInDaysAttribute))
	}

	enableIssuesForMembershipChangesAttribute, ok := attributes["enable_issues_for_membership_changes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_issues_for_membership_changes is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	enableIssuesForMembershipChangesVal, ok := enableIssuesForMembershipChangesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_issues_for_membership_changes expected to be basetypes.BoolValue, was: %T`, enableIssuesForMembershipChangesAttribute))
	}

	flavorsRegexAttribute, ok := attributes["flavors_regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavors_regex is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	flavorsRegexVal, ok := flavorsRegexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavors_regex expected to be basetypes.StringValue, was: %T`, flavorsRegexAttribute))
	}

	heappeClusterIdAttribute, ok := attributes["heappe_cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_cluster_id is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	heappeClusterIdVal, ok := heappeClusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_cluster_id expected to be basetypes.StringValue, was: %T`, heappeClusterIdAttribute))
	}

	heappeLocalBasePathAttribute, ok := attributes["heappe_local_base_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_local_base_path is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	heappeLocalBasePathVal, ok := heappeLocalBasePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_local_base_path expected to be basetypes.StringValue, was: %T`, heappeLocalBasePathAttribute))
	}

	heappeUrlAttribute, ok := attributes["heappe_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_url is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	heappeUrlVal, ok := heappeUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_url expected to be basetypes.StringValue, was: %T`, heappeUrlAttribute))
	}

	heappeUsernameAttribute, ok := attributes["heappe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_username is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	heappeUsernameVal, ok := heappeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_username expected to be basetypes.StringValue, was: %T`, heappeUsernameAttribute))
	}

	homedirPrefixAttribute, ok := attributes["homedir_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`homedir_prefix is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	homedirPrefixVal, ok := homedirPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`homedir_prefix expected to be basetypes.StringValue, was: %T`, homedirPrefixAttribute))
	}

	initialPrimarygroupNumberAttribute, ok := attributes["initial_primarygroup_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_primarygroup_number is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	initialPrimarygroupNumberVal, ok := initialPrimarygroupNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_primarygroup_number expected to be basetypes.Int64Value, was: %T`, initialPrimarygroupNumberAttribute))
	}

	initialUidnumberAttribute, ok := attributes["initial_uidnumber"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_uidnumber is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	initialUidnumberVal, ok := initialUidnumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_uidnumber expected to be basetypes.Int64Value, was: %T`, initialUidnumberAttribute))
	}

	initialUsergroupNumberAttribute, ok := attributes["initial_usergroup_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_usergroup_number is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	initialUsergroupNumberVal, ok := initialUsergroupNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_usergroup_number expected to be basetypes.Int64Value, was: %T`, initialUsergroupNumberAttribute))
	}

	isResourceTerminationDateRequiredAttribute, ok := attributes["is_resource_termination_date_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_resource_termination_date_required is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	isResourceTerminationDateRequiredVal, ok := isResourceTerminationDateRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_resource_termination_date_required expected to be basetypes.BoolValue, was: %T`, isResourceTerminationDateRequiredAttribute))
	}

	latestDateForResourceTerminationAttribute, ok := attributes["latest_date_for_resource_termination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_date_for_resource_termination is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	latestDateForResourceTerminationVal, ok := latestDateForResourceTerminationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_date_for_resource_termination expected to be basetypes.StringValue, was: %T`, latestDateForResourceTerminationAttribute))
	}

	managedRancherLoadBalancerCloudInitTemplateAttribute, ok := attributes["managed_rancher_load_balancer_cloud_init_template"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_cloud_init_template is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerCloudInitTemplateVal, ok := managedRancherLoadBalancerCloudInitTemplateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_cloud_init_template expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerCloudInitTemplateAttribute))
	}

	managedRancherLoadBalancerDataVolumeSizeGbAttribute, ok := attributes["managed_rancher_load_balancer_data_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_data_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerDataVolumeSizeGbVal, ok := managedRancherLoadBalancerDataVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_data_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherLoadBalancerDataVolumeSizeGbAttribute))
	}

	managedRancherLoadBalancerDataVolumeTypeNameAttribute, ok := attributes["managed_rancher_load_balancer_data_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_data_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerDataVolumeTypeNameVal, ok := managedRancherLoadBalancerDataVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_data_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerDataVolumeTypeNameAttribute))
	}

	managedRancherLoadBalancerFlavorNameAttribute, ok := attributes["managed_rancher_load_balancer_flavor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_flavor_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerFlavorNameVal, ok := managedRancherLoadBalancerFlavorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_flavor_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerFlavorNameAttribute))
	}

	managedRancherLoadBalancerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_load_balancer_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_system_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerSystemVolumeSizeGbVal, ok := managedRancherLoadBalancerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherLoadBalancerSystemVolumeSizeGbAttribute))
	}

	managedRancherLoadBalancerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_load_balancer_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_system_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerSystemVolumeTypeNameVal, ok := managedRancherLoadBalancerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerSystemVolumeTypeNameAttribute))
	}

	managedRancherServerDataVolumeSizeGbAttribute, ok := attributes["managed_rancher_server_data_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_data_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerDataVolumeSizeGbVal, ok := managedRancherServerDataVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_data_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherServerDataVolumeSizeGbAttribute))
	}

	managedRancherServerDataVolumeTypeNameAttribute, ok := attributes["managed_rancher_server_data_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_data_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerDataVolumeTypeNameVal, ok := managedRancherServerDataVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_data_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherServerDataVolumeTypeNameAttribute))
	}

	managedRancherServerFlavorNameAttribute, ok := attributes["managed_rancher_server_flavor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_flavor_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerFlavorNameVal, ok := managedRancherServerFlavorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_flavor_name expected to be basetypes.StringValue, was: %T`, managedRancherServerFlavorNameAttribute))
	}

	managedRancherServerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_server_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_system_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerSystemVolumeSizeGbVal, ok := managedRancherServerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherServerSystemVolumeSizeGbAttribute))
	}

	managedRancherServerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_server_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_system_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerSystemVolumeTypeNameVal, ok := managedRancherServerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherServerSystemVolumeTypeNameAttribute))
	}

	managedRancherWorkerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_worker_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_worker_system_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherWorkerSystemVolumeSizeGbVal, ok := managedRancherWorkerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_worker_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherWorkerSystemVolumeSizeGbAttribute))
	}

	managedRancherWorkerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_worker_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_worker_system_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherWorkerSystemVolumeTypeNameVal, ok := managedRancherWorkerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_worker_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherWorkerSystemVolumeTypeNameAttribute))
	}

	maxInstancesAttribute, ok := attributes["max_instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_instances is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	maxInstancesVal, ok := maxInstancesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_instances expected to be basetypes.Int64Value, was: %T`, maxInstancesAttribute))
	}

	maxResourceTerminationOffsetInDaysAttribute, ok := attributes["max_resource_termination_offset_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_resource_termination_offset_in_days is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	maxResourceTerminationOffsetInDaysVal, ok := maxResourceTerminationOffsetInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_resource_termination_offset_in_days expected to be basetypes.Int64Value, was: %T`, maxResourceTerminationOffsetInDaysAttribute))
	}

	maxVolumesAttribute, ok := attributes["max_volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_volumes is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	maxVolumesVal, ok := maxVolumesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_volumes expected to be basetypes.Int64Value, was: %T`, maxVolumesAttribute))
	}

	openstackOfferingUuidListAttribute, ok := attributes["openstack_offering_uuid_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`openstack_offering_uuid_list is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	openstackOfferingUuidListVal, ok := openstackOfferingUuidListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`openstack_offering_uuid_list expected to be basetypes.ListValue, was: %T`, openstackOfferingUuidListAttribute))
	}

	serviceProviderCanCreateOfferingUserAttribute, ok := attributes["service_provider_can_create_offering_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_provider_can_create_offering_user is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	serviceProviderCanCreateOfferingUserVal, ok := serviceProviderCanCreateOfferingUserAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_provider_can_create_offering_user expected to be basetypes.BoolValue, was: %T`, serviceProviderCanCreateOfferingUserAttribute))
	}

	snapshotSizeLimitGbAttribute, ok := attributes["snapshot_size_limit_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot_size_limit_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	snapshotSizeLimitGbVal, ok := snapshotSizeLimitGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot_size_limit_gb expected to be basetypes.Int64Value, was: %T`, snapshotSizeLimitGbAttribute))
	}

	storageModeAttribute, ok := attributes["storage_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_mode is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	storageModeVal, ok := storageModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_mode expected to be basetypes.StringValue, was: %T`, storageModeAttribute))
	}

	supportsDownscalingAttribute, ok := attributes["supports_downscaling"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supports_downscaling is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	supportsDownscalingVal, ok := supportsDownscalingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supports_downscaling expected to be basetypes.BoolValue, was: %T`, supportsDownscalingAttribute))
	}

	supportsPausingAttribute, ok := attributes["supports_pausing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supports_pausing is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	supportsPausingVal, ok := supportsPausingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supports_pausing expected to be basetypes.BoolValue, was: %T`, supportsPausingAttribute))
	}

	usernameAnonymizedPrefixAttribute, ok := attributes["username_anonymized_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_anonymized_prefix is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	usernameAnonymizedPrefixVal, ok := usernameAnonymizedPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_anonymized_prefix expected to be basetypes.StringValue, was: %T`, usernameAnonymizedPrefixAttribute))
	}

	usernameGenerationPolicyAttribute, ok := attributes["username_generation_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_generation_policy is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	usernameGenerationPolicyVal, ok := usernameGenerationPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_generation_policy expected to be basetypes.StringValue, was: %T`, usernameGenerationPolicyAttribute))
	}

	if diags.HasError() {
		return NewPluginOptionsValueUnknown(), diags
	}

	return PluginOptionsValue{
		AutoApproveInServiceProviderProjects:           autoApproveInServiceProviderProjectsVal,
		AutoApproveRemoteOrders:                        autoApproveRemoteOrdersVal,
		DefaultInternalNetworkMtu:                      defaultInternalNetworkMtuVal,
		DefaultResourceTerminationOffsetInDays:         defaultResourceTerminationOffsetInDaysVal,
		EnableIssuesForMembershipChanges:               enableIssuesForMembershipChangesVal,
		FlavorsRegex:                                   flavorsRegexVal,
		HeappeClusterId:                                heappeClusterIdVal,
		HeappeLocalBasePath:                            heappeLocalBasePathVal,
		HeappeUrl:                                      heappeUrlVal,
		HeappeUsername:                                 heappeUsernameVal,
		HomedirPrefix:                                  homedirPrefixVal,
		InitialPrimarygroupNumber:                      initialPrimarygroupNumberVal,
		InitialUidnumber:                               initialUidnumberVal,
		InitialUsergroupNumber:                         initialUsergroupNumberVal,
		IsResourceTerminationDateRequired:              isResourceTerminationDateRequiredVal,
		LatestDateForResourceTermination:               latestDateForResourceTerminationVal,
		ManagedRancherLoadBalancerCloudInitTemplate:    managedRancherLoadBalancerCloudInitTemplateVal,
		ManagedRancherLoadBalancerDataVolumeSizeGb:     managedRancherLoadBalancerDataVolumeSizeGbVal,
		ManagedRancherLoadBalancerDataVolumeTypeName:   managedRancherLoadBalancerDataVolumeTypeNameVal,
		ManagedRancherLoadBalancerFlavorName:           managedRancherLoadBalancerFlavorNameVal,
		ManagedRancherLoadBalancerSystemVolumeSizeGb:   managedRancherLoadBalancerSystemVolumeSizeGbVal,
		ManagedRancherLoadBalancerSystemVolumeTypeName: managedRancherLoadBalancerSystemVolumeTypeNameVal,
		ManagedRancherServerDataVolumeSizeGb:           managedRancherServerDataVolumeSizeGbVal,
		ManagedRancherServerDataVolumeTypeName:         managedRancherServerDataVolumeTypeNameVal,
		ManagedRancherServerFlavorName:                 managedRancherServerFlavorNameVal,
		ManagedRancherServerSystemVolumeSizeGb:         managedRancherServerSystemVolumeSizeGbVal,
		ManagedRancherServerSystemVolumeTypeName:       managedRancherServerSystemVolumeTypeNameVal,
		ManagedRancherWorkerSystemVolumeSizeGb:         managedRancherWorkerSystemVolumeSizeGbVal,
		ManagedRancherWorkerSystemVolumeTypeName:       managedRancherWorkerSystemVolumeTypeNameVal,
		MaxInstances:                                   maxInstancesVal,
		MaxResourceTerminationOffsetInDays:             maxResourceTerminationOffsetInDaysVal,
		MaxVolumes:                                     maxVolumesVal,
		OpenstackOfferingUuidList:                      openstackOfferingUuidListVal,
		ServiceProviderCanCreateOfferingUser:           serviceProviderCanCreateOfferingUserVal,
		SnapshotSizeLimitGb:                            snapshotSizeLimitGbVal,
		StorageMode:                                    storageModeVal,
		SupportsDownscaling:                            supportsDownscalingVal,
		SupportsPausing:                                supportsPausingVal,
		UsernameAnonymizedPrefix:                       usernameAnonymizedPrefixVal,
		UsernameGenerationPolicy:                       usernameGenerationPolicyVal,
		state:                                          attr.ValueStateKnown,
	}, diags
}

func NewPluginOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PluginOptionsValue {
	object, diags := NewPluginOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPluginOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PluginOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPluginOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPluginOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPluginOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPluginOptionsValueMust(PluginOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PluginOptionsType) ValueType(ctx context.Context) attr.Value {
	return PluginOptionsValue{}
}

var _ basetypes.ObjectValuable = PluginOptionsValue{}

type PluginOptionsValue struct {
	AutoApproveInServiceProviderProjects           basetypes.BoolValue   `tfsdk:"auto_approve_in_service_provider_projects"`
	AutoApproveRemoteOrders                        basetypes.BoolValue   `tfsdk:"auto_approve_remote_orders"`
	DefaultInternalNetworkMtu                      basetypes.Int64Value  `tfsdk:"default_internal_network_mtu"`
	DefaultResourceTerminationOffsetInDays         basetypes.Int64Value  `tfsdk:"default_resource_termination_offset_in_days"`
	EnableIssuesForMembershipChanges               basetypes.BoolValue   `tfsdk:"enable_issues_for_membership_changes"`
	FlavorsRegex                                   basetypes.StringValue `tfsdk:"flavors_regex"`
	HeappeClusterId                                basetypes.StringValue `tfsdk:"heappe_cluster_id"`
	HeappeLocalBasePath                            basetypes.StringValue `tfsdk:"heappe_local_base_path"`
	HeappeUrl                                      basetypes.StringValue `tfsdk:"heappe_url"`
	HeappeUsername                                 basetypes.StringValue `tfsdk:"heappe_username"`
	HomedirPrefix                                  basetypes.StringValue `tfsdk:"homedir_prefix"`
	InitialPrimarygroupNumber                      basetypes.Int64Value  `tfsdk:"initial_primarygroup_number"`
	InitialUidnumber                               basetypes.Int64Value  `tfsdk:"initial_uidnumber"`
	InitialUsergroupNumber                         basetypes.Int64Value  `tfsdk:"initial_usergroup_number"`
	IsResourceTerminationDateRequired              basetypes.BoolValue   `tfsdk:"is_resource_termination_date_required"`
	LatestDateForResourceTermination               basetypes.StringValue `tfsdk:"latest_date_for_resource_termination"`
	ManagedRancherLoadBalancerCloudInitTemplate    basetypes.StringValue `tfsdk:"managed_rancher_load_balancer_cloud_init_template"`
	ManagedRancherLoadBalancerDataVolumeSizeGb     basetypes.Int64Value  `tfsdk:"managed_rancher_load_balancer_data_volume_size_gb"`
	ManagedRancherLoadBalancerDataVolumeTypeName   basetypes.StringValue `tfsdk:"managed_rancher_load_balancer_data_volume_type_name"`
	ManagedRancherLoadBalancerFlavorName           basetypes.StringValue `tfsdk:"managed_rancher_load_balancer_flavor_name"`
	ManagedRancherLoadBalancerSystemVolumeSizeGb   basetypes.Int64Value  `tfsdk:"managed_rancher_load_balancer_system_volume_size_gb"`
	ManagedRancherLoadBalancerSystemVolumeTypeName basetypes.StringValue `tfsdk:"managed_rancher_load_balancer_system_volume_type_name"`
	ManagedRancherServerDataVolumeSizeGb           basetypes.Int64Value  `tfsdk:"managed_rancher_server_data_volume_size_gb"`
	ManagedRancherServerDataVolumeTypeName         basetypes.StringValue `tfsdk:"managed_rancher_server_data_volume_type_name"`
	ManagedRancherServerFlavorName                 basetypes.StringValue `tfsdk:"managed_rancher_server_flavor_name"`
	ManagedRancherServerSystemVolumeSizeGb         basetypes.Int64Value  `tfsdk:"managed_rancher_server_system_volume_size_gb"`
	ManagedRancherServerSystemVolumeTypeName       basetypes.StringValue `tfsdk:"managed_rancher_server_system_volume_type_name"`
	ManagedRancherWorkerSystemVolumeSizeGb         basetypes.Int64Value  `tfsdk:"managed_rancher_worker_system_volume_size_gb"`
	ManagedRancherWorkerSystemVolumeTypeName       basetypes.StringValue `tfsdk:"managed_rancher_worker_system_volume_type_name"`
	MaxInstances                                   basetypes.Int64Value  `tfsdk:"max_instances"`
	MaxResourceTerminationOffsetInDays             basetypes.Int64Value  `tfsdk:"max_resource_termination_offset_in_days"`
	MaxVolumes                                     basetypes.Int64Value  `tfsdk:"max_volumes"`
	OpenstackOfferingUuidList                      basetypes.ListValue   `tfsdk:"openstack_offering_uuid_list"`
	ServiceProviderCanCreateOfferingUser           basetypes.BoolValue   `tfsdk:"service_provider_can_create_offering_user"`
	SnapshotSizeLimitGb                            basetypes.Int64Value  `tfsdk:"snapshot_size_limit_gb"`
	StorageMode                                    basetypes.StringValue `tfsdk:"storage_mode"`
	SupportsDownscaling                            basetypes.BoolValue   `tfsdk:"supports_downscaling"`
	SupportsPausing                                basetypes.BoolValue   `tfsdk:"supports_pausing"`
	UsernameAnonymizedPrefix                       basetypes.StringValue `tfsdk:"username_anonymized_prefix"`
	UsernameGenerationPolicy                       basetypes.StringValue `tfsdk:"username_generation_policy"`
	state                                          attr.ValueState
}

func (v PluginOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 40)

	var val tftypes.Value
	var err error

	attrTypes["auto_approve_in_service_provider_projects"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_approve_remote_orders"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["default_internal_network_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["default_resource_termination_offset_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enable_issues_for_membership_changes"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["flavors_regex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["heappe_cluster_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["heappe_local_base_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["heappe_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["heappe_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["homedir_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["initial_primarygroup_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["initial_uidnumber"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["initial_usergroup_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_resource_termination_date_required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["latest_date_for_resource_termination"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_cloud_init_template"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_data_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_data_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_flavor_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_system_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_system_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_data_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_data_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_flavor_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_system_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_system_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_worker_system_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_worker_system_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_instances"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_resource_termination_offset_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_volumes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["openstack_offering_uuid_list"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["service_provider_can_create_offering_user"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["snapshot_size_limit_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["supports_downscaling"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["supports_pausing"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["username_anonymized_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username_generation_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 40)

		val, err = v.AutoApproveInServiceProviderProjects.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_approve_in_service_provider_projects"] = val

		val, err = v.AutoApproveRemoteOrders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_approve_remote_orders"] = val

		val, err = v.DefaultInternalNetworkMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_internal_network_mtu"] = val

		val, err = v.DefaultResourceTerminationOffsetInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_resource_termination_offset_in_days"] = val

		val, err = v.EnableIssuesForMembershipChanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_issues_for_membership_changes"] = val

		val, err = v.FlavorsRegex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flavors_regex"] = val

		val, err = v.HeappeClusterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["heappe_cluster_id"] = val

		val, err = v.HeappeLocalBasePath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["heappe_local_base_path"] = val

		val, err = v.HeappeUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["heappe_url"] = val

		val, err = v.HeappeUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["heappe_username"] = val

		val, err = v.HomedirPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["homedir_prefix"] = val

		val, err = v.InitialPrimarygroupNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initial_primarygroup_number"] = val

		val, err = v.InitialUidnumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initial_uidnumber"] = val

		val, err = v.InitialUsergroupNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initial_usergroup_number"] = val

		val, err = v.IsResourceTerminationDateRequired.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_resource_termination_date_required"] = val

		val, err = v.LatestDateForResourceTermination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latest_date_for_resource_termination"] = val

		val, err = v.ManagedRancherLoadBalancerCloudInitTemplate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_cloud_init_template"] = val

		val, err = v.ManagedRancherLoadBalancerDataVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_data_volume_size_gb"] = val

		val, err = v.ManagedRancherLoadBalancerDataVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_data_volume_type_name"] = val

		val, err = v.ManagedRancherLoadBalancerFlavorName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_flavor_name"] = val

		val, err = v.ManagedRancherLoadBalancerSystemVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_system_volume_size_gb"] = val

		val, err = v.ManagedRancherLoadBalancerSystemVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_system_volume_type_name"] = val

		val, err = v.ManagedRancherServerDataVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_data_volume_size_gb"] = val

		val, err = v.ManagedRancherServerDataVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_data_volume_type_name"] = val

		val, err = v.ManagedRancherServerFlavorName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_flavor_name"] = val

		val, err = v.ManagedRancherServerSystemVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_system_volume_size_gb"] = val

		val, err = v.ManagedRancherServerSystemVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_system_volume_type_name"] = val

		val, err = v.ManagedRancherWorkerSystemVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_worker_system_volume_size_gb"] = val

		val, err = v.ManagedRancherWorkerSystemVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_worker_system_volume_type_name"] = val

		val, err = v.MaxInstances.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_instances"] = val

		val, err = v.MaxResourceTerminationOffsetInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_resource_termination_offset_in_days"] = val

		val, err = v.MaxVolumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_volumes"] = val

		val, err = v.OpenstackOfferingUuidList.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["openstack_offering_uuid_list"] = val

		val, err = v.ServiceProviderCanCreateOfferingUser.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_provider_can_create_offering_user"] = val

		val, err = v.SnapshotSizeLimitGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["snapshot_size_limit_gb"] = val

		val, err = v.StorageMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_mode"] = val

		val, err = v.SupportsDownscaling.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["supports_downscaling"] = val

		val, err = v.SupportsPausing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["supports_pausing"] = val

		val, err = v.UsernameAnonymizedPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username_anonymized_prefix"] = val

		val, err = v.UsernameGenerationPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username_generation_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PluginOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PluginOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PluginOptionsValue) String() string {
	return "PluginOptionsValue"
}

func (v PluginOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var openstackOfferingUuidListVal basetypes.ListValue
	switch {
	case v.OpenstackOfferingUuidList.IsUnknown():
		openstackOfferingUuidListVal = types.ListUnknown(types.StringType)
	case v.OpenstackOfferingUuidList.IsNull():
		openstackOfferingUuidListVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		openstackOfferingUuidListVal, d = types.ListValue(types.StringType, v.OpenstackOfferingUuidList.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_approve_in_service_provider_projects":             basetypes.BoolType{},
			"auto_approve_remote_orders":                            basetypes.BoolType{},
			"default_internal_network_mtu":                          basetypes.Int64Type{},
			"default_resource_termination_offset_in_days":           basetypes.Int64Type{},
			"enable_issues_for_membership_changes":                  basetypes.BoolType{},
			"flavors_regex":                                         basetypes.StringType{},
			"heappe_cluster_id":                                     basetypes.StringType{},
			"heappe_local_base_path":                                basetypes.StringType{},
			"heappe_url":                                            basetypes.StringType{},
			"heappe_username":                                       basetypes.StringType{},
			"homedir_prefix":                                        basetypes.StringType{},
			"initial_primarygroup_number":                           basetypes.Int64Type{},
			"initial_uidnumber":                                     basetypes.Int64Type{},
			"initial_usergroup_number":                              basetypes.Int64Type{},
			"is_resource_termination_date_required":                 basetypes.BoolType{},
			"latest_date_for_resource_termination":                  basetypes.StringType{},
			"managed_rancher_load_balancer_cloud_init_template":     basetypes.StringType{},
			"managed_rancher_load_balancer_data_volume_size_gb":     basetypes.Int64Type{},
			"managed_rancher_load_balancer_data_volume_type_name":   basetypes.StringType{},
			"managed_rancher_load_balancer_flavor_name":             basetypes.StringType{},
			"managed_rancher_load_balancer_system_volume_size_gb":   basetypes.Int64Type{},
			"managed_rancher_load_balancer_system_volume_type_name": basetypes.StringType{},
			"managed_rancher_server_data_volume_size_gb":            basetypes.Int64Type{},
			"managed_rancher_server_data_volume_type_name":          basetypes.StringType{},
			"managed_rancher_server_flavor_name":                    basetypes.StringType{},
			"managed_rancher_server_system_volume_size_gb":          basetypes.Int64Type{},
			"managed_rancher_server_system_volume_type_name":        basetypes.StringType{},
			"managed_rancher_worker_system_volume_size_gb":          basetypes.Int64Type{},
			"managed_rancher_worker_system_volume_type_name":        basetypes.StringType{},
			"max_instances":                                         basetypes.Int64Type{},
			"max_resource_termination_offset_in_days":               basetypes.Int64Type{},
			"max_volumes": basetypes.Int64Type{},
			"openstack_offering_uuid_list": basetypes.ListType{
				ElemType: types.StringType,
			},
			"service_provider_can_create_offering_user": basetypes.BoolType{},
			"snapshot_size_limit_gb":                    basetypes.Int64Type{},
			"storage_mode":                              basetypes.StringType{},
			"supports_downscaling":                      basetypes.BoolType{},
			"supports_pausing":                          basetypes.BoolType{},
			"username_anonymized_prefix":                basetypes.StringType{},
			"username_generation_policy":                basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auto_approve_in_service_provider_projects":             basetypes.BoolType{},
		"auto_approve_remote_orders":                            basetypes.BoolType{},
		"default_internal_network_mtu":                          basetypes.Int64Type{},
		"default_resource_termination_offset_in_days":           basetypes.Int64Type{},
		"enable_issues_for_membership_changes":                  basetypes.BoolType{},
		"flavors_regex":                                         basetypes.StringType{},
		"heappe_cluster_id":                                     basetypes.StringType{},
		"heappe_local_base_path":                                basetypes.StringType{},
		"heappe_url":                                            basetypes.StringType{},
		"heappe_username":                                       basetypes.StringType{},
		"homedir_prefix":                                        basetypes.StringType{},
		"initial_primarygroup_number":                           basetypes.Int64Type{},
		"initial_uidnumber":                                     basetypes.Int64Type{},
		"initial_usergroup_number":                              basetypes.Int64Type{},
		"is_resource_termination_date_required":                 basetypes.BoolType{},
		"latest_date_for_resource_termination":                  basetypes.StringType{},
		"managed_rancher_load_balancer_cloud_init_template":     basetypes.StringType{},
		"managed_rancher_load_balancer_data_volume_size_gb":     basetypes.Int64Type{},
		"managed_rancher_load_balancer_data_volume_type_name":   basetypes.StringType{},
		"managed_rancher_load_balancer_flavor_name":             basetypes.StringType{},
		"managed_rancher_load_balancer_system_volume_size_gb":   basetypes.Int64Type{},
		"managed_rancher_load_balancer_system_volume_type_name": basetypes.StringType{},
		"managed_rancher_server_data_volume_size_gb":            basetypes.Int64Type{},
		"managed_rancher_server_data_volume_type_name":          basetypes.StringType{},
		"managed_rancher_server_flavor_name":                    basetypes.StringType{},
		"managed_rancher_server_system_volume_size_gb":          basetypes.Int64Type{},
		"managed_rancher_server_system_volume_type_name":        basetypes.StringType{},
		"managed_rancher_worker_system_volume_size_gb":          basetypes.Int64Type{},
		"managed_rancher_worker_system_volume_type_name":        basetypes.StringType{},
		"max_instances":                                         basetypes.Int64Type{},
		"max_resource_termination_offset_in_days":               basetypes.Int64Type{},
		"max_volumes": basetypes.Int64Type{},
		"openstack_offering_uuid_list": basetypes.ListType{
			ElemType: types.StringType,
		},
		"service_provider_can_create_offering_user": basetypes.BoolType{},
		"snapshot_size_limit_gb":                    basetypes.Int64Type{},
		"storage_mode":                              basetypes.StringType{},
		"supports_downscaling":                      basetypes.BoolType{},
		"supports_pausing":                          basetypes.BoolType{},
		"username_anonymized_prefix":                basetypes.StringType{},
		"username_generation_policy":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_approve_in_service_provider_projects":             v.AutoApproveInServiceProviderProjects,
			"auto_approve_remote_orders":                            v.AutoApproveRemoteOrders,
			"default_internal_network_mtu":                          v.DefaultInternalNetworkMtu,
			"default_resource_termination_offset_in_days":           v.DefaultResourceTerminationOffsetInDays,
			"enable_issues_for_membership_changes":                  v.EnableIssuesForMembershipChanges,
			"flavors_regex":                                         v.FlavorsRegex,
			"heappe_cluster_id":                                     v.HeappeClusterId,
			"heappe_local_base_path":                                v.HeappeLocalBasePath,
			"heappe_url":                                            v.HeappeUrl,
			"heappe_username":                                       v.HeappeUsername,
			"homedir_prefix":                                        v.HomedirPrefix,
			"initial_primarygroup_number":                           v.InitialPrimarygroupNumber,
			"initial_uidnumber":                                     v.InitialUidnumber,
			"initial_usergroup_number":                              v.InitialUsergroupNumber,
			"is_resource_termination_date_required":                 v.IsResourceTerminationDateRequired,
			"latest_date_for_resource_termination":                  v.LatestDateForResourceTermination,
			"managed_rancher_load_balancer_cloud_init_template":     v.ManagedRancherLoadBalancerCloudInitTemplate,
			"managed_rancher_load_balancer_data_volume_size_gb":     v.ManagedRancherLoadBalancerDataVolumeSizeGb,
			"managed_rancher_load_balancer_data_volume_type_name":   v.ManagedRancherLoadBalancerDataVolumeTypeName,
			"managed_rancher_load_balancer_flavor_name":             v.ManagedRancherLoadBalancerFlavorName,
			"managed_rancher_load_balancer_system_volume_size_gb":   v.ManagedRancherLoadBalancerSystemVolumeSizeGb,
			"managed_rancher_load_balancer_system_volume_type_name": v.ManagedRancherLoadBalancerSystemVolumeTypeName,
			"managed_rancher_server_data_volume_size_gb":            v.ManagedRancherServerDataVolumeSizeGb,
			"managed_rancher_server_data_volume_type_name":          v.ManagedRancherServerDataVolumeTypeName,
			"managed_rancher_server_flavor_name":                    v.ManagedRancherServerFlavorName,
			"managed_rancher_server_system_volume_size_gb":          v.ManagedRancherServerSystemVolumeSizeGb,
			"managed_rancher_server_system_volume_type_name":        v.ManagedRancherServerSystemVolumeTypeName,
			"managed_rancher_worker_system_volume_size_gb":          v.ManagedRancherWorkerSystemVolumeSizeGb,
			"managed_rancher_worker_system_volume_type_name":        v.ManagedRancherWorkerSystemVolumeTypeName,
			"max_instances":                                         v.MaxInstances,
			"max_resource_termination_offset_in_days":               v.MaxResourceTerminationOffsetInDays,
			"max_volumes":                               v.MaxVolumes,
			"openstack_offering_uuid_list":              openstackOfferingUuidListVal,
			"service_provider_can_create_offering_user": v.ServiceProviderCanCreateOfferingUser,
			"snapshot_size_limit_gb":                    v.SnapshotSizeLimitGb,
			"storage_mode":                              v.StorageMode,
			"supports_downscaling":                      v.SupportsDownscaling,
			"supports_pausing":                          v.SupportsPausing,
			"username_anonymized_prefix":                v.UsernameAnonymizedPrefix,
			"username_generation_policy":                v.UsernameGenerationPolicy,
		})

	return objVal, diags
}

func (v PluginOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(PluginOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoApproveInServiceProviderProjects.Equal(other.AutoApproveInServiceProviderProjects) {
		return false
	}

	if !v.AutoApproveRemoteOrders.Equal(other.AutoApproveRemoteOrders) {
		return false
	}

	if !v.DefaultInternalNetworkMtu.Equal(other.DefaultInternalNetworkMtu) {
		return false
	}

	if !v.DefaultResourceTerminationOffsetInDays.Equal(other.DefaultResourceTerminationOffsetInDays) {
		return false
	}

	if !v.EnableIssuesForMembershipChanges.Equal(other.EnableIssuesForMembershipChanges) {
		return false
	}

	if !v.FlavorsRegex.Equal(other.FlavorsRegex) {
		return false
	}

	if !v.HeappeClusterId.Equal(other.HeappeClusterId) {
		return false
	}

	if !v.HeappeLocalBasePath.Equal(other.HeappeLocalBasePath) {
		return false
	}

	if !v.HeappeUrl.Equal(other.HeappeUrl) {
		return false
	}

	if !v.HeappeUsername.Equal(other.HeappeUsername) {
		return false
	}

	if !v.HomedirPrefix.Equal(other.HomedirPrefix) {
		return false
	}

	if !v.InitialPrimarygroupNumber.Equal(other.InitialPrimarygroupNumber) {
		return false
	}

	if !v.InitialUidnumber.Equal(other.InitialUidnumber) {
		return false
	}

	if !v.InitialUsergroupNumber.Equal(other.InitialUsergroupNumber) {
		return false
	}

	if !v.IsResourceTerminationDateRequired.Equal(other.IsResourceTerminationDateRequired) {
		return false
	}

	if !v.LatestDateForResourceTermination.Equal(other.LatestDateForResourceTermination) {
		return false
	}

	if !v.ManagedRancherLoadBalancerCloudInitTemplate.Equal(other.ManagedRancherLoadBalancerCloudInitTemplate) {
		return false
	}

	if !v.ManagedRancherLoadBalancerDataVolumeSizeGb.Equal(other.ManagedRancherLoadBalancerDataVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherLoadBalancerDataVolumeTypeName.Equal(other.ManagedRancherLoadBalancerDataVolumeTypeName) {
		return false
	}

	if !v.ManagedRancherLoadBalancerFlavorName.Equal(other.ManagedRancherLoadBalancerFlavorName) {
		return false
	}

	if !v.ManagedRancherLoadBalancerSystemVolumeSizeGb.Equal(other.ManagedRancherLoadBalancerSystemVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherLoadBalancerSystemVolumeTypeName.Equal(other.ManagedRancherLoadBalancerSystemVolumeTypeName) {
		return false
	}

	if !v.ManagedRancherServerDataVolumeSizeGb.Equal(other.ManagedRancherServerDataVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherServerDataVolumeTypeName.Equal(other.ManagedRancherServerDataVolumeTypeName) {
		return false
	}

	if !v.ManagedRancherServerFlavorName.Equal(other.ManagedRancherServerFlavorName) {
		return false
	}

	if !v.ManagedRancherServerSystemVolumeSizeGb.Equal(other.ManagedRancherServerSystemVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherServerSystemVolumeTypeName.Equal(other.ManagedRancherServerSystemVolumeTypeName) {
		return false
	}

	if !v.ManagedRancherWorkerSystemVolumeSizeGb.Equal(other.ManagedRancherWorkerSystemVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherWorkerSystemVolumeTypeName.Equal(other.ManagedRancherWorkerSystemVolumeTypeName) {
		return false
	}

	if !v.MaxInstances.Equal(other.MaxInstances) {
		return false
	}

	if !v.MaxResourceTerminationOffsetInDays.Equal(other.MaxResourceTerminationOffsetInDays) {
		return false
	}

	if !v.MaxVolumes.Equal(other.MaxVolumes) {
		return false
	}

	if !v.OpenstackOfferingUuidList.Equal(other.OpenstackOfferingUuidList) {
		return false
	}

	if !v.ServiceProviderCanCreateOfferingUser.Equal(other.ServiceProviderCanCreateOfferingUser) {
		return false
	}

	if !v.SnapshotSizeLimitGb.Equal(other.SnapshotSizeLimitGb) {
		return false
	}

	if !v.StorageMode.Equal(other.StorageMode) {
		return false
	}

	if !v.SupportsDownscaling.Equal(other.SupportsDownscaling) {
		return false
	}

	if !v.SupportsPausing.Equal(other.SupportsPausing) {
		return false
	}

	if !v.UsernameAnonymizedPrefix.Equal(other.UsernameAnonymizedPrefix) {
		return false
	}

	if !v.UsernameGenerationPolicy.Equal(other.UsernameGenerationPolicy) {
		return false
	}

	return true
}

func (v PluginOptionsValue) Type(ctx context.Context) attr.Type {
	return PluginOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PluginOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_approve_in_service_provider_projects":             basetypes.BoolType{},
		"auto_approve_remote_orders":                            basetypes.BoolType{},
		"default_internal_network_mtu":                          basetypes.Int64Type{},
		"default_resource_termination_offset_in_days":           basetypes.Int64Type{},
		"enable_issues_for_membership_changes":                  basetypes.BoolType{},
		"flavors_regex":                                         basetypes.StringType{},
		"heappe_cluster_id":                                     basetypes.StringType{},
		"heappe_local_base_path":                                basetypes.StringType{},
		"heappe_url":                                            basetypes.StringType{},
		"heappe_username":                                       basetypes.StringType{},
		"homedir_prefix":                                        basetypes.StringType{},
		"initial_primarygroup_number":                           basetypes.Int64Type{},
		"initial_uidnumber":                                     basetypes.Int64Type{},
		"initial_usergroup_number":                              basetypes.Int64Type{},
		"is_resource_termination_date_required":                 basetypes.BoolType{},
		"latest_date_for_resource_termination":                  basetypes.StringType{},
		"managed_rancher_load_balancer_cloud_init_template":     basetypes.StringType{},
		"managed_rancher_load_balancer_data_volume_size_gb":     basetypes.Int64Type{},
		"managed_rancher_load_balancer_data_volume_type_name":   basetypes.StringType{},
		"managed_rancher_load_balancer_flavor_name":             basetypes.StringType{},
		"managed_rancher_load_balancer_system_volume_size_gb":   basetypes.Int64Type{},
		"managed_rancher_load_balancer_system_volume_type_name": basetypes.StringType{},
		"managed_rancher_server_data_volume_size_gb":            basetypes.Int64Type{},
		"managed_rancher_server_data_volume_type_name":          basetypes.StringType{},
		"managed_rancher_server_flavor_name":                    basetypes.StringType{},
		"managed_rancher_server_system_volume_size_gb":          basetypes.Int64Type{},
		"managed_rancher_server_system_volume_type_name":        basetypes.StringType{},
		"managed_rancher_worker_system_volume_size_gb":          basetypes.Int64Type{},
		"managed_rancher_worker_system_volume_type_name":        basetypes.StringType{},
		"max_instances":                                         basetypes.Int64Type{},
		"max_resource_termination_offset_in_days":               basetypes.Int64Type{},
		"max_volumes": basetypes.Int64Type{},
		"openstack_offering_uuid_list": basetypes.ListType{
			ElemType: types.StringType,
		},
		"service_provider_can_create_offering_user": basetypes.BoolType{},
		"snapshot_size_limit_gb":                    basetypes.Int64Type{},
		"storage_mode":                              basetypes.StringType{},
		"supports_downscaling":                      basetypes.BoolType{},
		"supports_pausing":                          basetypes.BoolType{},
		"username_anonymized_prefix":                basetypes.StringType{},
		"username_generation_policy":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PromotionCampaignsType{}

type PromotionCampaignsType struct {
	basetypes.ObjectType
}

func (t PromotionCampaignsType) Equal(o attr.Type) bool {
	other, ok := o.(PromotionCampaignsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PromotionCampaignsType) String() string {
	return "PromotionCampaignsType"
}

func (t PromotionCampaignsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	discountAttribute, ok := attributes["discount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount is missing from object`)

		return nil, diags
	}

	discountVal, ok := discountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount expected to be basetypes.Int64Value, was: %T`, discountAttribute))
	}

	discountTypeAttribute, ok := attributes["discount_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount_type is missing from object`)

		return nil, diags
	}

	discountTypeVal, ok := discountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount_type expected to be basetypes.StringValue, was: %T`, discountTypeAttribute))
	}

	endDateAttribute, ok := attributes["end_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_date is missing from object`)

		return nil, diags
	}

	endDateVal, ok := endDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_date expected to be basetypes.StringValue, was: %T`, endDateAttribute))
	}

	monthsAttribute, ok := attributes["months"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`months is missing from object`)

		return nil, diags
	}

	monthsVal, ok := monthsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`months expected to be basetypes.Int64Value, was: %T`, monthsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	serviceProviderAttribute, ok := attributes["service_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_provider is missing from object`)

		return nil, diags
	}

	serviceProviderVal, ok := serviceProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_provider expected to be basetypes.StringValue, was: %T`, serviceProviderAttribute))
	}

	startDateAttribute, ok := attributes["start_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_date is missing from object`)

		return nil, diags
	}

	startDateVal, ok := startDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_date expected to be basetypes.StringValue, was: %T`, startDateAttribute))
	}

	stockAttribute, ok := attributes["stock"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stock is missing from object`)

		return nil, diags
	}

	stockVal, ok := stockAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stock expected to be basetypes.Int64Value, was: %T`, stockAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PromotionCampaignsValue{
		Description:     descriptionVal,
		Discount:        discountVal,
		DiscountType:    discountTypeVal,
		EndDate:         endDateVal,
		Months:          monthsVal,
		Name:            nameVal,
		ServiceProvider: serviceProviderVal,
		StartDate:       startDateVal,
		Stock:           stockVal,
		Uuid:            uuidVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewPromotionCampaignsValueNull() PromotionCampaignsValue {
	return PromotionCampaignsValue{
		state: attr.ValueStateNull,
	}
}

func NewPromotionCampaignsValueUnknown() PromotionCampaignsValue {
	return PromotionCampaignsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPromotionCampaignsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PromotionCampaignsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PromotionCampaignsValue Attribute Value",
				"While creating a PromotionCampaignsValue value, a missing attribute value was detected. "+
					"A PromotionCampaignsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PromotionCampaignsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PromotionCampaignsValue Attribute Type",
				"While creating a PromotionCampaignsValue value, an invalid attribute value was detected. "+
					"A PromotionCampaignsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PromotionCampaignsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PromotionCampaignsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PromotionCampaignsValue Attribute Value",
				"While creating a PromotionCampaignsValue value, an extra attribute value was detected. "+
					"A PromotionCampaignsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PromotionCampaignsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPromotionCampaignsValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	discountAttribute, ok := attributes["discount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	discountVal, ok := discountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount expected to be basetypes.Int64Value, was: %T`, discountAttribute))
	}

	discountTypeAttribute, ok := attributes["discount_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount_type is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	discountTypeVal, ok := discountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount_type expected to be basetypes.StringValue, was: %T`, discountTypeAttribute))
	}

	endDateAttribute, ok := attributes["end_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_date is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	endDateVal, ok := endDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_date expected to be basetypes.StringValue, was: %T`, endDateAttribute))
	}

	monthsAttribute, ok := attributes["months"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`months is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	monthsVal, ok := monthsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`months expected to be basetypes.Int64Value, was: %T`, monthsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	serviceProviderAttribute, ok := attributes["service_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_provider is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	serviceProviderVal, ok := serviceProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_provider expected to be basetypes.StringValue, was: %T`, serviceProviderAttribute))
	}

	startDateAttribute, ok := attributes["start_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_date is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	startDateVal, ok := startDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_date expected to be basetypes.StringValue, was: %T`, startDateAttribute))
	}

	stockAttribute, ok := attributes["stock"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stock is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	stockVal, ok := stockAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stock expected to be basetypes.Int64Value, was: %T`, stockAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewPromotionCampaignsValueUnknown(), diags
	}

	return PromotionCampaignsValue{
		Description:     descriptionVal,
		Discount:        discountVal,
		DiscountType:    discountTypeVal,
		EndDate:         endDateVal,
		Months:          monthsVal,
		Name:            nameVal,
		ServiceProvider: serviceProviderVal,
		StartDate:       startDateVal,
		Stock:           stockVal,
		Uuid:            uuidVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewPromotionCampaignsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PromotionCampaignsValue {
	object, diags := NewPromotionCampaignsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPromotionCampaignsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PromotionCampaignsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPromotionCampaignsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPromotionCampaignsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPromotionCampaignsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPromotionCampaignsValueMust(PromotionCampaignsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PromotionCampaignsType) ValueType(ctx context.Context) attr.Value {
	return PromotionCampaignsValue{}
}

var _ basetypes.ObjectValuable = PromotionCampaignsValue{}

type PromotionCampaignsValue struct {
	Description     basetypes.StringValue `tfsdk:"description"`
	Discount        basetypes.Int64Value  `tfsdk:"discount"`
	DiscountType    basetypes.StringValue `tfsdk:"discount_type"`
	EndDate         basetypes.StringValue `tfsdk:"end_date"`
	Months          basetypes.Int64Value  `tfsdk:"months"`
	Name            basetypes.StringValue `tfsdk:"name"`
	ServiceProvider basetypes.StringValue `tfsdk:"service_provider"`
	StartDate       basetypes.StringValue `tfsdk:"start_date"`
	Stock           basetypes.Int64Value  `tfsdk:"stock"`
	Uuid            basetypes.StringValue `tfsdk:"uuid"`
	state           attr.ValueState
}

func (v PromotionCampaignsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["discount"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["discount_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["end_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["months"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["start_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stock"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Discount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discount"] = val

		val, err = v.DiscountType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discount_type"] = val

		val, err = v.EndDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end_date"] = val

		val, err = v.Months.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["months"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ServiceProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_provider"] = val

		val, err = v.StartDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_date"] = val

		val, err = v.Stock.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stock"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PromotionCampaignsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PromotionCampaignsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PromotionCampaignsValue) String() string {
	return "PromotionCampaignsValue"
}

func (v PromotionCampaignsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description":      basetypes.StringType{},
		"discount":         basetypes.Int64Type{},
		"discount_type":    basetypes.StringType{},
		"end_date":         basetypes.StringType{},
		"months":           basetypes.Int64Type{},
		"name":             basetypes.StringType{},
		"service_provider": basetypes.StringType{},
		"start_date":       basetypes.StringType{},
		"stock":            basetypes.Int64Type{},
		"uuid":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":      v.Description,
			"discount":         v.Discount,
			"discount_type":    v.DiscountType,
			"end_date":         v.EndDate,
			"months":           v.Months,
			"name":             v.Name,
			"service_provider": v.ServiceProvider,
			"start_date":       v.StartDate,
			"stock":            v.Stock,
			"uuid":             v.Uuid,
		})

	return objVal, diags
}

func (v PromotionCampaignsValue) Equal(o attr.Value) bool {
	other, ok := o.(PromotionCampaignsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Discount.Equal(other.Discount) {
		return false
	}

	if !v.DiscountType.Equal(other.DiscountType) {
		return false
	}

	if !v.EndDate.Equal(other.EndDate) {
		return false
	}

	if !v.Months.Equal(other.Months) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ServiceProvider.Equal(other.ServiceProvider) {
		return false
	}

	if !v.StartDate.Equal(other.StartDate) {
		return false
	}

	if !v.Stock.Equal(other.Stock) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v PromotionCampaignsValue) Type(ctx context.Context) attr.Type {
	return PromotionCampaignsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PromotionCampaignsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":      basetypes.StringType{},
		"discount":         basetypes.Int64Type{},
		"discount_type":    basetypes.StringType{},
		"end_date":         basetypes.StringType{},
		"months":           basetypes.Int64Type{},
		"name":             basetypes.StringType{},
		"service_provider": basetypes.StringType{},
		"start_date":       basetypes.StringType{},
		"stock":            basetypes.Int64Type{},
		"uuid":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = QuotasType{}

type QuotasType struct {
	basetypes.ObjectType
}

func (t QuotasType) Equal(o attr.Type) bool {
	other, ok := o.(QuotasType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QuotasType) String() string {
	return "QuotasType"
}

func (t QuotasType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	limitAttribute, ok := attributes["limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit is missing from object`)

		return nil, diags
	}

	limitVal, ok := limitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit expected to be basetypes.Int64Value, was: %T`, limitAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.Int64Value, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QuotasValue{
		Limit: limitVal,
		Name:  nameVal,
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewQuotasValueNull() QuotasValue {
	return QuotasValue{
		state: attr.ValueStateNull,
	}
}

func NewQuotasValueUnknown() QuotasValue {
	return QuotasValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQuotasValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QuotasValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QuotasValue Attribute Value",
				"While creating a QuotasValue value, a missing attribute value was detected. "+
					"A QuotasValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QuotasValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QuotasValue Attribute Type",
				"While creating a QuotasValue value, an invalid attribute value was detected. "+
					"A QuotasValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QuotasValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QuotasValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QuotasValue Attribute Value",
				"While creating a QuotasValue value, an extra attribute value was detected. "+
					"A QuotasValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QuotasValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQuotasValueUnknown(), diags
	}

	limitAttribute, ok := attributes["limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit is missing from object`)

		return NewQuotasValueUnknown(), diags
	}

	limitVal, ok := limitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit expected to be basetypes.Int64Value, was: %T`, limitAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewQuotasValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewQuotasValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.Int64Value, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewQuotasValueUnknown(), diags
	}

	return QuotasValue{
		Limit: limitVal,
		Name:  nameVal,
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewQuotasValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QuotasValue {
	object, diags := NewQuotasValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQuotasValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QuotasType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQuotasValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQuotasValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQuotasValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQuotasValueMust(QuotasValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QuotasType) ValueType(ctx context.Context) attr.Value {
	return QuotasValue{}
}

var _ basetypes.ObjectValuable = QuotasValue{}

type QuotasValue struct {
	Limit basetypes.Int64Value  `tfsdk:"limit"`
	Name  basetypes.StringValue `tfsdk:"name"`
	Usage basetypes.Int64Value  `tfsdk:"usage"`
	state attr.ValueState
}

func (v QuotasValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Limit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QuotasValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QuotasValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QuotasValue) String() string {
	return "QuotasValue"
}

func (v QuotasValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"limit": basetypes.Int64Type{},
		"name":  basetypes.StringType{},
		"usage": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"limit": v.Limit,
			"name":  v.Name,
			"usage": v.Usage,
		})

	return objVal, diags
}

func (v QuotasValue) Equal(o attr.Value) bool {
	other, ok := o.(QuotasValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Limit.Equal(other.Limit) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v QuotasValue) Type(ctx context.Context) attr.Type {
	return QuotasType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QuotasValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"limit": basetypes.Int64Type{},
		"name":  basetypes.StringType{},
		"usage": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ResourceOptionsType{}

type ResourceOptionsType struct {
	basetypes.ObjectType
}

func (t ResourceOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(ResourceOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourceOptionsType) String() string {
	return "ResourceOptionsType"
}

func (t ResourceOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	orderAttribute, ok := attributes["order"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order is missing from object`)

		return nil, diags
	}

	orderVal, ok := orderAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order expected to be basetypes.ListValue, was: %T`, orderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourceOptionsValue{
		Options: optionsVal,
		Order:   orderVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewResourceOptionsValueNull() ResourceOptionsValue {
	return ResourceOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewResourceOptionsValueUnknown() ResourceOptionsValue {
	return ResourceOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourceOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourceOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourceOptionsValue Attribute Value",
				"While creating a ResourceOptionsValue value, a missing attribute value was detected. "+
					"A ResourceOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourceOptionsValue Attribute Type",
				"While creating a ResourceOptionsValue value, an invalid attribute value was detected. "+
					"A ResourceOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourceOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourceOptionsValue Attribute Value",
				"While creating a ResourceOptionsValue value, an extra attribute value was detected. "+
					"A ResourceOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourceOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourceOptionsValueUnknown(), diags
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewResourceOptionsValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	orderAttribute, ok := attributes["order"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order is missing from object`)

		return NewResourceOptionsValueUnknown(), diags
	}

	orderVal, ok := orderAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order expected to be basetypes.ListValue, was: %T`, orderAttribute))
	}

	if diags.HasError() {
		return NewResourceOptionsValueUnknown(), diags
	}

	return ResourceOptionsValue{
		Options: optionsVal,
		Order:   orderVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewResourceOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourceOptionsValue {
	object, diags := NewResourceOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourceOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourceOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourceOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourceOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourceOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourceOptionsValueMust(ResourceOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourceOptionsType) ValueType(ctx context.Context) attr.Value {
	return ResourceOptionsValue{}
}

var _ basetypes.ObjectValuable = ResourceOptionsValue{}

type ResourceOptionsValue struct {
	Options basetypes.MapValue  `tfsdk:"options"`
	Order   basetypes.ListValue `tfsdk:"order"`
	state   attr.ValueState
}

func (v ResourceOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["options"] = basetypes.MapType{
		ElemType: OptionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["order"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.Order.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["order"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourceOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourceOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourceOptionsValue) String() string {
	return "ResourceOptionsValue"
}

func (v ResourceOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	options := types.MapValueMust(
		OptionsType{
			basetypes.ObjectType{
				AttrTypes: OptionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Options.Elements(),
	)

	if v.Options.IsNull() {
		options = types.MapNull(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Options.IsUnknown() {
		options = types.MapUnknown(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var orderVal basetypes.ListValue
	switch {
	case v.Order.IsUnknown():
		orderVal = types.ListUnknown(types.StringType)
	case v.Order.IsNull():
		orderVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		orderVal, d = types.ListValue(types.StringType, v.Order.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"order": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"order": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"options": options,
			"order":   orderVal,
		})

	return objVal, diags
}

func (v ResourceOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourceOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.Order.Equal(other.Order) {
		return false
	}

	return true
}

func (v ResourceOptionsValue) Type(ctx context.Context) attr.Type {
	return ResourceOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourceOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"order": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	choicesAttribute, ok := attributes["choices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`choices is missing from object`)

		return nil, diags
	}

	choicesVal, ok := choicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`choices expected to be basetypes.ListValue, was: %T`, choicesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return nil, diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	helpTextAttribute, ok := attributes["help_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`help_text is missing from object`)

		return nil, diags
	}

	helpTextVal, ok := helpTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`help_text expected to be basetypes.StringValue, was: %T`, helpTextAttribute))
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return nil, diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return nil, diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return nil, diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return nil, diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		Choices:     choicesVal,
		Default:     defaultVal,
		HelpText:    helpTextVal,
		Label:       labelVal,
		Max:         maxVal,
		Min:         minVal,
		Required:    requiredVal,
		OptionsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	choicesAttribute, ok := attributes["choices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`choices is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	choicesVal, ok := choicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`choices expected to be basetypes.ListValue, was: %T`, choicesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	helpTextAttribute, ok := attributes["help_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`help_text is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	helpTextVal, ok := helpTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`help_text expected to be basetypes.StringValue, was: %T`, helpTextAttribute))
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		Choices:     choicesVal,
		Default:     defaultVal,
		HelpText:    helpTextVal,
		Label:       labelVal,
		Max:         maxVal,
		Min:         minVal,
		Required:    requiredVal,
		OptionsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	Choices     basetypes.ListValue   `tfsdk:"choices"`
	Default     basetypes.StringValue `tfsdk:"default"`
	HelpText    basetypes.StringValue `tfsdk:"help_text"`
	Label       basetypes.StringValue `tfsdk:"label"`
	Max         basetypes.Int64Value  `tfsdk:"max"`
	Min         basetypes.Int64Value  `tfsdk:"min"`
	Required    basetypes.BoolValue   `tfsdk:"required"`
	OptionsType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["choices"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["help_text"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Choices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["choices"] = val

		val, err = v.Default.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default"] = val

		val, err = v.HelpText.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["help_text"] = val

		val, err = v.Label.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label"] = val

		val, err = v.Max.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max"] = val

		val, err = v.Min.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min"] = val

		val, err = v.Required.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required"] = val

		val, err = v.OptionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var choicesVal basetypes.ListValue
	switch {
	case v.Choices.IsUnknown():
		choicesVal = types.ListUnknown(types.StringType)
	case v.Choices.IsNull():
		choicesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		choicesVal, d = types.ListValue(types.StringType, v.Choices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"choices": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default":   basetypes.StringType{},
			"help_text": basetypes.StringType{},
			"label":     basetypes.StringType{},
			"max":       basetypes.Int64Type{},
			"min":       basetypes.Int64Type{},
			"required":  basetypes.BoolType{},
			"type":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"choices": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default":   basetypes.StringType{},
		"help_text": basetypes.StringType{},
		"label":     basetypes.StringType{},
		"max":       basetypes.Int64Type{},
		"min":       basetypes.Int64Type{},
		"required":  basetypes.BoolType{},
		"type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"choices":   choicesVal,
			"default":   v.Default,
			"help_text": v.HelpText,
			"label":     v.Label,
			"max":       v.Max,
			"min":       v.Min,
			"required":  v.Required,
			"type":      v.OptionsType,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Choices.Equal(other.Choices) {
		return false
	}

	if !v.Default.Equal(other.Default) {
		return false
	}

	if !v.HelpText.Equal(other.HelpText) {
		return false
	}

	if !v.Label.Equal(other.Label) {
		return false
	}

	if !v.Max.Equal(other.Max) {
		return false
	}

	if !v.Min.Equal(other.Min) {
		return false
	}

	if !v.Required.Equal(other.Required) {
		return false
	}

	if !v.OptionsType.Equal(other.OptionsType) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"choices": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default":   basetypes.StringType{},
		"help_text": basetypes.StringType{},
		"label":     basetypes.StringType{},
		"max":       basetypes.Int64Type{},
		"min":       basetypes.Int64Type{},
		"required":  basetypes.BoolType{},
		"type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RolesType{}

type RolesType struct {
	basetypes.ObjectType
}

func (t RolesType) Equal(o attr.Type) bool {
	other, ok := o.(RolesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RolesType) String() string {
	return "RolesType"
}

func (t RolesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RolesValue{
		Name:  nameVal,
		Url:   urlVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRolesValueNull() RolesValue {
	return RolesValue{
		state: attr.ValueStateNull,
	}
}

func NewRolesValueUnknown() RolesValue {
	return RolesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRolesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RolesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RolesValue Attribute Value",
				"While creating a RolesValue value, a missing attribute value was detected. "+
					"A RolesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RolesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RolesValue Attribute Type",
				"While creating a RolesValue value, an invalid attribute value was detected. "+
					"A RolesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RolesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RolesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RolesValue Attribute Value",
				"While creating a RolesValue value, an extra attribute value was detected. "+
					"A RolesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RolesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRolesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewRolesValueUnknown(), diags
	}

	return RolesValue{
		Name:  nameVal,
		Url:   urlVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRolesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RolesValue {
	object, diags := NewRolesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRolesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RolesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRolesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRolesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRolesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRolesValueMust(RolesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RolesType) ValueType(ctx context.Context) attr.Value {
	return RolesValue{}
}

var _ basetypes.ObjectValuable = RolesValue{}

type RolesValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Url   basetypes.StringValue `tfsdk:"url"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v RolesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RolesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RolesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RolesValue) String() string {
	return "RolesValue"
}

func (v RolesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"url":  basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"url":  v.Url,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v RolesValue) Equal(o attr.Value) bool {
	other, ok := o.(RolesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v RolesValue) Type(ctx context.Context) attr.Type {
	return RolesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RolesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"url":  basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ScreenshotsType{}

type ScreenshotsType struct {
	basetypes.ObjectType
}

func (t ScreenshotsType) Equal(o attr.Type) bool {
	other, ok := o.(ScreenshotsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScreenshotsType) String() string {
	return "ScreenshotsType"
}

func (t ScreenshotsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	thumbnailAttribute, ok := attributes["thumbnail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thumbnail is missing from object`)

		return nil, diags
	}

	thumbnailVal, ok := thumbnailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thumbnail expected to be basetypes.StringValue, was: %T`, thumbnailAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScreenshotsValue{
		Created:     createdVal,
		Description: descriptionVal,
		Image:       imageVal,
		Name:        nameVal,
		Thumbnail:   thumbnailVal,
		Uuid:        uuidVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewScreenshotsValueNull() ScreenshotsValue {
	return ScreenshotsValue{
		state: attr.ValueStateNull,
	}
}

func NewScreenshotsValueUnknown() ScreenshotsValue {
	return ScreenshotsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScreenshotsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScreenshotsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScreenshotsValue Attribute Value",
				"While creating a ScreenshotsValue value, a missing attribute value was detected. "+
					"A ScreenshotsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScreenshotsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScreenshotsValue Attribute Type",
				"While creating a ScreenshotsValue value, an invalid attribute value was detected. "+
					"A ScreenshotsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScreenshotsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScreenshotsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScreenshotsValue Attribute Value",
				"While creating a ScreenshotsValue value, an extra attribute value was detected. "+
					"A ScreenshotsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScreenshotsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScreenshotsValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	thumbnailAttribute, ok := attributes["thumbnail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thumbnail is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	thumbnailVal, ok := thumbnailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thumbnail expected to be basetypes.StringValue, was: %T`, thumbnailAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewScreenshotsValueUnknown(), diags
	}

	return ScreenshotsValue{
		Created:     createdVal,
		Description: descriptionVal,
		Image:       imageVal,
		Name:        nameVal,
		Thumbnail:   thumbnailVal,
		Uuid:        uuidVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewScreenshotsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScreenshotsValue {
	object, diags := NewScreenshotsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScreenshotsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScreenshotsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScreenshotsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScreenshotsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScreenshotsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScreenshotsValueMust(ScreenshotsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScreenshotsType) ValueType(ctx context.Context) attr.Value {
	return ScreenshotsValue{}
}

var _ basetypes.ObjectValuable = ScreenshotsValue{}

type ScreenshotsValue struct {
	Created     basetypes.StringValue `tfsdk:"created"`
	Description basetypes.StringValue `tfsdk:"description"`
	Image       basetypes.StringValue `tfsdk:"image"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Thumbnail   basetypes.StringValue `tfsdk:"thumbnail"`
	Uuid        basetypes.StringValue `tfsdk:"uuid"`
	state       attr.ValueState
}

func (v ScreenshotsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["thumbnail"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Thumbnail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["thumbnail"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScreenshotsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScreenshotsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScreenshotsValue) String() string {
	return "ScreenshotsValue"
}

func (v ScreenshotsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"image":       basetypes.StringType{},
		"name":        basetypes.StringType{},
		"thumbnail":   basetypes.StringType{},
		"uuid":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created":     v.Created,
			"description": v.Description,
			"image":       v.Image,
			"name":        v.Name,
			"thumbnail":   v.Thumbnail,
			"uuid":        v.Uuid,
		})

	return objVal, diags
}

func (v ScreenshotsValue) Equal(o attr.Value) bool {
	other, ok := o.(ScreenshotsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Thumbnail.Equal(other.Thumbnail) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v ScreenshotsValue) Type(ctx context.Context) attr.Type {
	return ScreenshotsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScreenshotsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"image":       basetypes.StringType{},
		"name":        basetypes.StringType{},
		"thumbnail":   basetypes.StringType{},
		"uuid":        basetypes.StringType{},
	}
}
