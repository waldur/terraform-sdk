// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_openstack_instance

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func OpenstackInstanceDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"access_url": schema.StringAttribute{
				Computed: true,
			},
			"action": schema.StringAttribute{
				Computed: true,
			},
			"availability_zone": schema.StringAttribute{
				Computed: true,
			},
			"availability_zone_name": schema.StringAttribute{
				Computed: true,
			},
			"backend_id": schema.StringAttribute{
				Computed: true,
			},
			"connect_directly_to_external_network": schema.BoolAttribute{
				Computed: true,
			},
			"cores": schema.Int64Attribute{
				Computed:            true,
				Description:         "Number of cores in a VM",
				MarkdownDescription: "Number of cores in a VM",
			},
			"created": schema.StringAttribute{
				Computed: true,
			},
			"customer": schema.StringAttribute{
				Computed: true,
			},
			"customer_abbreviation": schema.StringAttribute{
				Computed: true,
			},
			"customer_name": schema.StringAttribute{
				Computed: true,
			},
			"customer_native_name": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Computed: true,
			},
			"disk": schema.Int64Attribute{
				Computed:            true,
				Description:         "Disk size in MiB",
				MarkdownDescription: "Disk size in MiB",
			},
			"error_message": schema.StringAttribute{
				Computed: true,
			},
			"error_traceback": schema.StringAttribute{
				Computed: true,
			},
			"external_address": schema.ListAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"external_ips": schema.ListAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"field": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"flavor_disk": schema.Int64Attribute{
				Computed:            true,
				Description:         "Flavor disk size in MiB",
				MarkdownDescription: "Flavor disk size in MiB",
			},
			"flavor_name": schema.StringAttribute{
				Computed: true,
			},
			"floating_ips": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"address": schema.StringAttribute{
							Computed: true,
						},
						"port_fixed_ips": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ip_address": schema.StringAttribute{
										Computed: true,
									},
									"subnet_id": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: PortFixedIpsType{
									ObjectType: types.ObjectType{
										AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"port_mac_address": schema.StringAttribute{
							Computed: true,
						},
						"subnet": schema.StringAttribute{
							Computed: true,
						},
						"subnet_cidr": schema.StringAttribute{
							Computed: true,
						},
						"subnet_description": schema.StringAttribute{
							Computed: true,
						},
						"subnet_name": schema.StringAttribute{
							Computed: true,
						},
						"subnet_uuid": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: FloatingIpsType{
						ObjectType: types.ObjectType{
							AttrTypes: FloatingIpsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"hypervisor_hostname": schema.StringAttribute{
				Computed: true,
			},
			"image_name": schema.StringAttribute{
				Computed: true,
			},
			"internal_ips": schema.ListAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"is_limit_based": schema.BoolAttribute{
				Computed: true,
			},
			"is_usage_based": schema.BoolAttribute{
				Computed: true,
			},
			"key_fingerprint": schema.StringAttribute{
				Computed: true,
			},
			"key_name": schema.StringAttribute{
				Computed: true,
			},
			"latitude": schema.Float64Attribute{
				Computed: true,
			},
			"longitude": schema.Float64Attribute{
				Computed: true,
			},
			"marketplace_category_name": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_category_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_offering_name": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_offering_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_plan_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_resource_state": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_resource_uuid": schema.StringAttribute{
				Computed: true,
			},
			"min_disk": schema.Int64Attribute{
				Computed:            true,
				Description:         "Minimum disk size in MiB",
				MarkdownDescription: "Minimum disk size in MiB",
			},
			"min_ram": schema.Int64Attribute{
				Computed:            true,
				Description:         "Minimum memory size in MiB",
				MarkdownDescription: "Minimum memory size in MiB",
			},
			"modified": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"ports": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"allowed_address_pairs": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"mac_address": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: AllowedAddressPairsType{
									ObjectType: types.ObjectType{
										AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"device_id": schema.StringAttribute{
							Computed: true,
						},
						"device_owner": schema.StringAttribute{
							Computed: true,
						},
						"fixed_ips": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ip_address": schema.StringAttribute{
										Computed: true,
									},
									"subnet_id": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: FixedIpsType{
									ObjectType: types.ObjectType{
										AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"mac_address": schema.StringAttribute{
							Computed: true,
						},
						"security_groups": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"access_url": schema.StringAttribute{
										Computed: true,
									},
									"backend_id": schema.StringAttribute{
										Computed: true,
									},
									"created": schema.StringAttribute{
										Computed: true,
									},
									"customer": schema.StringAttribute{
										Computed: true,
									},
									"customer_abbreviation": schema.StringAttribute{
										Computed: true,
									},
									"customer_name": schema.StringAttribute{
										Computed: true,
									},
									"customer_native_name": schema.StringAttribute{
										Computed: true,
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"error_message": schema.StringAttribute{
										Computed: true,
									},
									"error_traceback": schema.StringAttribute{
										Computed: true,
									},
									"is_limit_based": schema.BoolAttribute{
										Computed: true,
									},
									"is_usage_based": schema.BoolAttribute{
										Computed: true,
									},
									"marketplace_category_name": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_category_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_offering_name": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_offering_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_plan_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_resource_state": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_resource_uuid": schema.StringAttribute{
										Computed: true,
									},
									"modified": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"project": schema.StringAttribute{
										Computed: true,
									},
									"project_name": schema.StringAttribute{
										Computed: true,
									},
									"project_uuid": schema.StringAttribute{
										Computed: true,
									},
									"resource_type": schema.StringAttribute{
										Computed: true,
									},
									"rules": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"cidr": schema.StringAttribute{
													Computed: true,
												},
												"description": schema.StringAttribute{
													Computed: true,
												},
												"direction": schema.StringAttribute{
													Computed: true,
												},
												"ethertype": schema.StringAttribute{
													Computed: true,
												},
												"from_port": schema.Int64Attribute{
													Computed: true,
												},
												"id": schema.Int64Attribute{
													Computed: true,
												},
												"remote_group": schema.StringAttribute{
													Computed: true,
												},
												"remote_group_name": schema.StringAttribute{
													Computed: true,
												},
												"remote_group_uuid": schema.StringAttribute{
													Computed: true,
												},
												"to_port": schema.Int64Attribute{
													Computed: true,
												},
											},
											CustomType: RulesType{
												ObjectType: types.ObjectType{
													AttrTypes: RulesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"service_name": schema.StringAttribute{
										Computed: true,
									},
									"service_settings": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_error_message": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_state": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_uuid": schema.StringAttribute{
										Computed: true,
									},
									"state": schema.StringAttribute{
										Computed: true,
									},
									"tenant": schema.StringAttribute{
										Computed: true,
									},
									"tenant_name": schema.StringAttribute{
										Computed: true,
									},
									"tenant_uuid": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SecurityGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"subnet": schema.StringAttribute{
							Computed: true,
						},
						"subnet_cidr": schema.StringAttribute{
							Computed: true,
						},
						"subnet_description": schema.StringAttribute{
							Computed: true,
						},
						"subnet_name": schema.StringAttribute{
							Computed: true,
						},
						"subnet_uuid": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: PortsType{
						ObjectType: types.ObjectType{
							AttrTypes: PortsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"project": schema.StringAttribute{
				Computed: true,
			},
			"project_name": schema.StringAttribute{
				Computed: true,
			},
			"project_uuid": schema.StringAttribute{
				Computed: true,
			},
			"ram": schema.Int64Attribute{
				Computed:            true,
				Description:         "Memory size in MiB",
				MarkdownDescription: "Memory size in MiB",
			},
			"rancher_cluster": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"marketplace_uuid": schema.StringAttribute{
						Computed: true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"uuid": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: RancherClusterType{
					ObjectType: types.ObjectType{
						AttrTypes: RancherClusterValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"resource_type": schema.StringAttribute{
				Computed: true,
			},
			"runtime_state": schema.StringAttribute{
				Computed: true,
			},
			"security_groups": schema.ListAttribute{
				ElementType: types.ListType{
					ElemType: types.ObjectType{
						AttrTypes: map[string]attr.Type{
							"url": types.StringType,
						},
					},
				},
				Computed: true,
			},
			"server_group": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"name": schema.StringAttribute{
						Computed: true,
					},
					"policy": schema.StringAttribute{
						Computed: true,
					},
					"state": schema.StringAttribute{
						Computed: true,
					},
					"url": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: ServerGroupType{
					ObjectType: types.ObjectType{
						AttrTypes: ServerGroupValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"service_name": schema.StringAttribute{
				Computed: true,
			},
			"service_settings": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_error_message": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_state": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_uuid": schema.StringAttribute{
				Computed: true,
			},
			"start_time": schema.StringAttribute{
				Computed: true,
			},
			"state": schema.StringAttribute{
				Computed: true,
			},
			"tenant": schema.StringAttribute{
				Computed: true,
			},
			"tenant_uuid": schema.StringAttribute{
				Computed: true,
			},
			"url": schema.StringAttribute{
				Computed: true,
			},
			"user_data": schema.StringAttribute{
				Computed:            true,
				Description:         "Additional data that will be added to instance on provisioning",
				MarkdownDescription: "Additional data that will be added to instance on provisioning",
			},
			"uuid": schema.StringAttribute{
				Required: true,
			},
			"volumes": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"bootable": schema.BoolAttribute{
							Computed: true,
						},
						"device": schema.StringAttribute{
							Computed:            true,
							Description:         "Name of volume as instance device e.g. /dev/vdb.",
							MarkdownDescription: "Name of volume as instance device e.g. /dev/vdb.",
						},
						"image_name": schema.StringAttribute{
							Computed: true,
						},
						"marketplace_resource_uuid": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"resource_type": schema.StringAttribute{
							Computed: true,
						},
						"size": schema.Int64Attribute{
							Computed:            true,
							Description:         "Size in MiB",
							MarkdownDescription: "Size in MiB",
						},
						"state": schema.StringAttribute{
							Computed: true,
						},
						"type": schema.StringAttribute{
							Computed: true,
						},
						"type_name": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: VolumesType{
						ObjectType: types.ObjectType{
							AttrTypes: VolumesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
		},
	}
}

type OpenstackInstanceModel struct {
	AccessUrl                        types.String        `tfsdk:"access_url"`
	Action                           types.String        `tfsdk:"action"`
	AvailabilityZone                 types.String        `tfsdk:"availability_zone"`
	AvailabilityZoneName             types.String        `tfsdk:"availability_zone_name"`
	BackendId                        types.String        `tfsdk:"backend_id"`
	ConnectDirectlyToExternalNetwork types.Bool          `tfsdk:"connect_directly_to_external_network"`
	Cores                            types.Int64         `tfsdk:"cores"`
	Created                          types.String        `tfsdk:"created"`
	Customer                         types.String        `tfsdk:"customer"`
	CustomerAbbreviation             types.String        `tfsdk:"customer_abbreviation"`
	CustomerName                     types.String        `tfsdk:"customer_name"`
	CustomerNativeName               types.String        `tfsdk:"customer_native_name"`
	Description                      types.String        `tfsdk:"description"`
	Disk                             types.Int64         `tfsdk:"disk"`
	ErrorMessage                     types.String        `tfsdk:"error_message"`
	ErrorTraceback                   types.String        `tfsdk:"error_traceback"`
	ExternalAddress                  types.List          `tfsdk:"external_address"`
	ExternalIps                      types.List          `tfsdk:"external_ips"`
	Field                            types.List          `tfsdk:"field"`
	FlavorDisk                       types.Int64         `tfsdk:"flavor_disk"`
	FlavorName                       types.String        `tfsdk:"flavor_name"`
	FloatingIps                      types.List          `tfsdk:"floating_ips"`
	HypervisorHostname               types.String        `tfsdk:"hypervisor_hostname"`
	ImageName                        types.String        `tfsdk:"image_name"`
	InternalIps                      types.List          `tfsdk:"internal_ips"`
	IsLimitBased                     types.Bool          `tfsdk:"is_limit_based"`
	IsUsageBased                     types.Bool          `tfsdk:"is_usage_based"`
	KeyFingerprint                   types.String        `tfsdk:"key_fingerprint"`
	KeyName                          types.String        `tfsdk:"key_name"`
	Latitude                         types.Float64       `tfsdk:"latitude"`
	Longitude                        types.Float64       `tfsdk:"longitude"`
	MarketplaceCategoryName          types.String        `tfsdk:"marketplace_category_name"`
	MarketplaceCategoryUuid          types.String        `tfsdk:"marketplace_category_uuid"`
	MarketplaceOfferingName          types.String        `tfsdk:"marketplace_offering_name"`
	MarketplaceOfferingUuid          types.String        `tfsdk:"marketplace_offering_uuid"`
	MarketplacePlanUuid              types.String        `tfsdk:"marketplace_plan_uuid"`
	MarketplaceResourceState         types.String        `tfsdk:"marketplace_resource_state"`
	MarketplaceResourceUuid          types.String        `tfsdk:"marketplace_resource_uuid"`
	MinDisk                          types.Int64         `tfsdk:"min_disk"`
	MinRam                           types.Int64         `tfsdk:"min_ram"`
	Modified                         types.String        `tfsdk:"modified"`
	Name                             types.String        `tfsdk:"name"`
	Ports                            types.List          `tfsdk:"ports"`
	Project                          types.String        `tfsdk:"project"`
	ProjectName                      types.String        `tfsdk:"project_name"`
	ProjectUuid                      types.String        `tfsdk:"project_uuid"`
	Ram                              types.Int64         `tfsdk:"ram"`
	RancherCluster                   RancherClusterValue `tfsdk:"rancher_cluster"`
	ResourceType                     types.String        `tfsdk:"resource_type"`
	RuntimeState                     types.String        `tfsdk:"runtime_state"`
	SecurityGroups                   types.List          `tfsdk:"security_groups"`
	ServerGroup                      ServerGroupValue    `tfsdk:"server_group"`
	ServiceName                      types.String        `tfsdk:"service_name"`
	ServiceSettings                  types.String        `tfsdk:"service_settings"`
	ServiceSettingsErrorMessage      types.String        `tfsdk:"service_settings_error_message"`
	ServiceSettingsState             types.String        `tfsdk:"service_settings_state"`
	ServiceSettingsUuid              types.String        `tfsdk:"service_settings_uuid"`
	StartTime                        types.String        `tfsdk:"start_time"`
	State                            types.String        `tfsdk:"state"`
	Tenant                           types.String        `tfsdk:"tenant"`
	TenantUuid                       types.String        `tfsdk:"tenant_uuid"`
	Url                              types.String        `tfsdk:"url"`
	UserData                         types.String        `tfsdk:"user_data"`
	Uuid                             types.String        `tfsdk:"uuid"`
	Volumes                          types.List          `tfsdk:"volumes"`
}

var _ basetypes.ObjectTypable = FloatingIpsType{}

type FloatingIpsType struct {
	basetypes.ObjectType
}

func (t FloatingIpsType) Equal(o attr.Type) bool {
	other, ok := o.(FloatingIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FloatingIpsType) String() string {
	return "FloatingIpsType"
}

func (t FloatingIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	portFixedIpsAttribute, ok := attributes["port_fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_fixed_ips is missing from object`)

		return nil, diags
	}

	portFixedIpsVal, ok := portFixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_fixed_ips expected to be basetypes.ListValue, was: %T`, portFixedIpsAttribute))
	}

	portMacAddressAttribute, ok := attributes["port_mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mac_address is missing from object`)

		return nil, diags
	}

	portMacAddressVal, ok := portMacAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mac_address expected to be basetypes.StringValue, was: %T`, portMacAddressAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return nil, diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return nil, diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return nil, diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FloatingIpsValue{
		Address:           addressVal,
		PortFixedIps:      portFixedIpsVal,
		PortMacAddress:    portMacAddressVal,
		Subnet:            subnetVal,
		SubnetCidr:        subnetCidrVal,
		SubnetDescription: subnetDescriptionVal,
		SubnetName:        subnetNameVal,
		SubnetUuid:        subnetUuidVal,
		Url:               urlVal,
		Uuid:              uuidVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewFloatingIpsValueNull() FloatingIpsValue {
	return FloatingIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewFloatingIpsValueUnknown() FloatingIpsValue {
	return FloatingIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFloatingIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FloatingIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FloatingIpsValue Attribute Value",
				"While creating a FloatingIpsValue value, a missing attribute value was detected. "+
					"A FloatingIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FloatingIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FloatingIpsValue Attribute Type",
				"While creating a FloatingIpsValue value, an invalid attribute value was detected. "+
					"A FloatingIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FloatingIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FloatingIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FloatingIpsValue Attribute Value",
				"While creating a FloatingIpsValue value, an extra attribute value was detected. "+
					"A FloatingIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FloatingIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFloatingIpsValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	portFixedIpsAttribute, ok := attributes["port_fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_fixed_ips is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	portFixedIpsVal, ok := portFixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_fixed_ips expected to be basetypes.ListValue, was: %T`, portFixedIpsAttribute))
	}

	portMacAddressAttribute, ok := attributes["port_mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mac_address is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	portMacAddressVal, ok := portMacAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mac_address expected to be basetypes.StringValue, was: %T`, portMacAddressAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewFloatingIpsValueUnknown(), diags
	}

	return FloatingIpsValue{
		Address:           addressVal,
		PortFixedIps:      portFixedIpsVal,
		PortMacAddress:    portMacAddressVal,
		Subnet:            subnetVal,
		SubnetCidr:        subnetCidrVal,
		SubnetDescription: subnetDescriptionVal,
		SubnetName:        subnetNameVal,
		SubnetUuid:        subnetUuidVal,
		Url:               urlVal,
		Uuid:              uuidVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewFloatingIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FloatingIpsValue {
	object, diags := NewFloatingIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFloatingIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FloatingIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFloatingIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFloatingIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFloatingIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFloatingIpsValueMust(FloatingIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FloatingIpsType) ValueType(ctx context.Context) attr.Value {
	return FloatingIpsValue{}
}

var _ basetypes.ObjectValuable = FloatingIpsValue{}

type FloatingIpsValue struct {
	Address           basetypes.StringValue `tfsdk:"address"`
	PortFixedIps      basetypes.ListValue   `tfsdk:"port_fixed_ips"`
	PortMacAddress    basetypes.StringValue `tfsdk:"port_mac_address"`
	Subnet            basetypes.StringValue `tfsdk:"subnet"`
	SubnetCidr        basetypes.StringValue `tfsdk:"subnet_cidr"`
	SubnetDescription basetypes.StringValue `tfsdk:"subnet_description"`
	SubnetName        basetypes.StringValue `tfsdk:"subnet_name"`
	SubnetUuid        basetypes.StringValue `tfsdk:"subnet_uuid"`
	Url               basetypes.StringValue `tfsdk:"url"`
	Uuid              basetypes.StringValue `tfsdk:"uuid"`
	state             attr.ValueState
}

func (v FloatingIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_fixed_ips"] = basetypes.ListType{
		ElemType: PortFixedIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["port_mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.PortFixedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_fixed_ips"] = val

		val, err = v.PortMacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mac_address"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.SubnetDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_description"] = val

		val, err = v.SubnetName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_name"] = val

		val, err = v.SubnetUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FloatingIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FloatingIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FloatingIpsValue) String() string {
	return "FloatingIpsValue"
}

func (v FloatingIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	portFixedIps := types.ListValueMust(
		PortFixedIpsType{
			basetypes.ObjectType{
				AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.PortFixedIps.Elements(),
	)

	if v.PortFixedIps.IsNull() {
		portFixedIps = types.ListNull(
			PortFixedIpsType{
				basetypes.ObjectType{
					AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortFixedIps.IsUnknown() {
		portFixedIps = types.ListUnknown(
			PortFixedIpsType{
				basetypes.ObjectType{
					AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"address": basetypes.StringType{},
		"port_fixed_ips": basetypes.ListType{
			ElemType: PortFixedIpsValue{}.Type(ctx),
		},
		"port_mac_address":   basetypes.StringType{},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
		"uuid":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":            v.Address,
			"port_fixed_ips":     portFixedIps,
			"port_mac_address":   v.PortMacAddress,
			"subnet":             v.Subnet,
			"subnet_cidr":        v.SubnetCidr,
			"subnet_description": v.SubnetDescription,
			"subnet_name":        v.SubnetName,
			"subnet_uuid":        v.SubnetUuid,
			"url":                v.Url,
			"uuid":               v.Uuid,
		})

	return objVal, diags
}

func (v FloatingIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(FloatingIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.PortFixedIps.Equal(other.PortFixedIps) {
		return false
	}

	if !v.PortMacAddress.Equal(other.PortMacAddress) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.SubnetDescription.Equal(other.SubnetDescription) {
		return false
	}

	if !v.SubnetName.Equal(other.SubnetName) {
		return false
	}

	if !v.SubnetUuid.Equal(other.SubnetUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v FloatingIpsValue) Type(ctx context.Context) attr.Type {
	return FloatingIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FloatingIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address": basetypes.StringType{},
		"port_fixed_ips": basetypes.ListType{
			ElemType: PortFixedIpsValue{}.Type(ctx),
		},
		"port_mac_address":   basetypes.StringType{},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
		"uuid":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortFixedIpsType{}

type PortFixedIpsType struct {
	basetypes.ObjectType
}

func (t PortFixedIpsType) Equal(o attr.Type) bool {
	other, ok := o.(PortFixedIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortFixedIpsType) String() string {
	return "PortFixedIpsType"
}

func (t PortFixedIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortFixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPortFixedIpsValueNull() PortFixedIpsValue {
	return PortFixedIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortFixedIpsValueUnknown() PortFixedIpsValue {
	return PortFixedIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortFixedIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortFixedIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortFixedIpsValue Attribute Value",
				"While creating a PortFixedIpsValue value, a missing attribute value was detected. "+
					"A PortFixedIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortFixedIpsValue Attribute Type",
				"While creating a PortFixedIpsValue value, an invalid attribute value was detected. "+
					"A PortFixedIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortFixedIpsValue Attribute Value",
				"While creating a PortFixedIpsValue value, an extra attribute value was detected. "+
					"A PortFixedIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortFixedIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortFixedIpsValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewPortFixedIpsValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewPortFixedIpsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewPortFixedIpsValueUnknown(), diags
	}

	return PortFixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPortFixedIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortFixedIpsValue {
	object, diags := NewPortFixedIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortFixedIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortFixedIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortFixedIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortFixedIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortFixedIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortFixedIpsValueMust(PortFixedIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortFixedIpsType) ValueType(ctx context.Context) attr.Value {
	return PortFixedIpsValue{}
}

var _ basetypes.ObjectValuable = PortFixedIpsValue{}

type PortFixedIpsValue struct {
	IpAddress basetypes.StringValue `tfsdk:"ip_address"`
	SubnetId  basetypes.StringValue `tfsdk:"subnet_id"`
	state     attr.ValueState
}

func (v PortFixedIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortFixedIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortFixedIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortFixedIpsValue) String() string {
	return "PortFixedIpsValue"
}

func (v PortFixedIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address": v.IpAddress,
			"subnet_id":  v.SubnetId,
		})

	return objVal, diags
}

func (v PortFixedIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortFixedIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v PortFixedIpsValue) Type(ctx context.Context) attr.Type {
	return PortFixedIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortFixedIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortsType{}

type PortsType struct {
	basetypes.ObjectType
}

func (t PortsType) Equal(o attr.Type) bool {
	other, ok := o.(PortsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortsType) String() string {
	return "PortsType"
}

func (t PortsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedAddressPairsAttribute, ok := attributes["allowed_address_pairs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_address_pairs is missing from object`)

		return nil, diags
	}

	allowedAddressPairsVal, ok := allowedAddressPairsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_address_pairs expected to be basetypes.ListValue, was: %T`, allowedAddressPairsAttribute))
	}

	deviceIdAttribute, ok := attributes["device_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_id is missing from object`)

		return nil, diags
	}

	deviceIdVal, ok := deviceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_id expected to be basetypes.StringValue, was: %T`, deviceIdAttribute))
	}

	deviceOwnerAttribute, ok := attributes["device_owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_owner is missing from object`)

		return nil, diags
	}

	deviceOwnerVal, ok := deviceOwnerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_owner expected to be basetypes.StringValue, was: %T`, deviceOwnerAttribute))
	}

	fixedIpsAttribute, ok := attributes["fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ips is missing from object`)

		return nil, diags
	}

	fixedIpsVal, ok := fixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ips expected to be basetypes.ListValue, was: %T`, fixedIpsAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return nil, diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return nil, diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return nil, diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortsValue{
		AllowedAddressPairs: allowedAddressPairsVal,
		DeviceId:            deviceIdVal,
		DeviceOwner:         deviceOwnerVal,
		FixedIps:            fixedIpsVal,
		MacAddress:          macAddressVal,
		SecurityGroups:      securityGroupsVal,
		Subnet:              subnetVal,
		SubnetCidr:          subnetCidrVal,
		SubnetDescription:   subnetDescriptionVal,
		SubnetName:          subnetNameVal,
		SubnetUuid:          subnetUuidVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPortsValueNull() PortsValue {
	return PortsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortsValueUnknown() PortsValue {
	return PortsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortsValue Attribute Value",
				"While creating a PortsValue value, a missing attribute value was detected. "+
					"A PortsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortsValue Attribute Type",
				"While creating a PortsValue value, an invalid attribute value was detected. "+
					"A PortsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortsValue Attribute Value",
				"While creating a PortsValue value, an extra attribute value was detected. "+
					"A PortsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	allowedAddressPairsAttribute, ok := attributes["allowed_address_pairs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_address_pairs is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	allowedAddressPairsVal, ok := allowedAddressPairsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_address_pairs expected to be basetypes.ListValue, was: %T`, allowedAddressPairsAttribute))
	}

	deviceIdAttribute, ok := attributes["device_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_id is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	deviceIdVal, ok := deviceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_id expected to be basetypes.StringValue, was: %T`, deviceIdAttribute))
	}

	deviceOwnerAttribute, ok := attributes["device_owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_owner is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	deviceOwnerVal, ok := deviceOwnerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_owner expected to be basetypes.StringValue, was: %T`, deviceOwnerAttribute))
	}

	fixedIpsAttribute, ok := attributes["fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ips is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	fixedIpsVal, ok := fixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ips expected to be basetypes.ListValue, was: %T`, fixedIpsAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	return PortsValue{
		AllowedAddressPairs: allowedAddressPairsVal,
		DeviceId:            deviceIdVal,
		DeviceOwner:         deviceOwnerVal,
		FixedIps:            fixedIpsVal,
		MacAddress:          macAddressVal,
		SecurityGroups:      securityGroupsVal,
		Subnet:              subnetVal,
		SubnetCidr:          subnetCidrVal,
		SubnetDescription:   subnetDescriptionVal,
		SubnetName:          subnetNameVal,
		SubnetUuid:          subnetUuidVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPortsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortsValue {
	object, diags := NewPortsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortsValueMust(PortsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortsType) ValueType(ctx context.Context) attr.Value {
	return PortsValue{}
}

var _ basetypes.ObjectValuable = PortsValue{}

type PortsValue struct {
	AllowedAddressPairs basetypes.ListValue   `tfsdk:"allowed_address_pairs"`
	DeviceId            basetypes.StringValue `tfsdk:"device_id"`
	DeviceOwner         basetypes.StringValue `tfsdk:"device_owner"`
	FixedIps            basetypes.ListValue   `tfsdk:"fixed_ips"`
	MacAddress          basetypes.StringValue `tfsdk:"mac_address"`
	SecurityGroups      basetypes.ListValue   `tfsdk:"security_groups"`
	Subnet              basetypes.StringValue `tfsdk:"subnet"`
	SubnetCidr          basetypes.StringValue `tfsdk:"subnet_cidr"`
	SubnetDescription   basetypes.StringValue `tfsdk:"subnet_description"`
	SubnetName          basetypes.StringValue `tfsdk:"subnet_name"`
	SubnetUuid          basetypes.StringValue `tfsdk:"subnet_uuid"`
	Url                 basetypes.StringValue `tfsdk:"url"`
	state               attr.ValueState
}

func (v PortsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["allowed_address_pairs"] = basetypes.ListType{
		ElemType: AllowedAddressPairsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["device_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["device_owner"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_ips"] = basetypes.ListType{
		ElemType: FixedIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AllowedAddressPairs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_address_pairs"] = val

		val, err = v.DeviceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_id"] = val

		val, err = v.DeviceOwner.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_owner"] = val

		val, err = v.FixedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_ips"] = val

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.SubnetDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_description"] = val

		val, err = v.SubnetName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_name"] = val

		val, err = v.SubnetUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortsValue) String() string {
	return "PortsValue"
}

func (v PortsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	allowedAddressPairs := types.ListValueMust(
		AllowedAddressPairsType{
			basetypes.ObjectType{
				AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
			},
		},
		v.AllowedAddressPairs.Elements(),
	)

	if v.AllowedAddressPairs.IsNull() {
		allowedAddressPairs = types.ListNull(
			AllowedAddressPairsType{
				basetypes.ObjectType{
					AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AllowedAddressPairs.IsUnknown() {
		allowedAddressPairs = types.ListUnknown(
			AllowedAddressPairsType{
				basetypes.ObjectType{
					AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	fixedIps := types.ListValueMust(
		FixedIpsType{
			basetypes.ObjectType{
				AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.FixedIps.Elements(),
	)

	if v.FixedIps.IsNull() {
		fixedIps = types.ListNull(
			FixedIpsType{
				basetypes.ObjectType{
					AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FixedIps.IsUnknown() {
		fixedIps = types.ListUnknown(
			FixedIpsType{
				basetypes.ObjectType{
					AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroups := types.ListValueMust(
		SecurityGroupsType{
			basetypes.ObjectType{
				AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups.Elements(),
	)

	if v.SecurityGroups.IsNull() {
		securityGroups = types.ListNull(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups.IsUnknown() {
		securityGroups = types.ListUnknown(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"allowed_address_pairs": basetypes.ListType{
			ElemType: AllowedAddressPairsValue{}.Type(ctx),
		},
		"device_id":    basetypes.StringType{},
		"device_owner": basetypes.StringType{},
		"fixed_ips": basetypes.ListType{
			ElemType: FixedIpsValue{}.Type(ctx),
		},
		"mac_address": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_address_pairs": allowedAddressPairs,
			"device_id":             v.DeviceId,
			"device_owner":          v.DeviceOwner,
			"fixed_ips":             fixedIps,
			"mac_address":           v.MacAddress,
			"security_groups":       securityGroups,
			"subnet":                v.Subnet,
			"subnet_cidr":           v.SubnetCidr,
			"subnet_description":    v.SubnetDescription,
			"subnet_name":           v.SubnetName,
			"subnet_uuid":           v.SubnetUuid,
			"url":                   v.Url,
		})

	return objVal, diags
}

func (v PortsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedAddressPairs.Equal(other.AllowedAddressPairs) {
		return false
	}

	if !v.DeviceId.Equal(other.DeviceId) {
		return false
	}

	if !v.DeviceOwner.Equal(other.DeviceOwner) {
		return false
	}

	if !v.FixedIps.Equal(other.FixedIps) {
		return false
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.SubnetDescription.Equal(other.SubnetDescription) {
		return false
	}

	if !v.SubnetName.Equal(other.SubnetName) {
		return false
	}

	if !v.SubnetUuid.Equal(other.SubnetUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PortsValue) Type(ctx context.Context) attr.Type {
	return PortsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_address_pairs": basetypes.ListType{
			ElemType: AllowedAddressPairsValue{}.Type(ctx),
		},
		"device_id":    basetypes.StringType{},
		"device_owner": basetypes.StringType{},
		"fixed_ips": basetypes.ListType{
			ElemType: FixedIpsValue{}.Type(ctx),
		},
		"mac_address": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AllowedAddressPairsType{}

type AllowedAddressPairsType struct {
	basetypes.ObjectType
}

func (t AllowedAddressPairsType) Equal(o attr.Type) bool {
	other, ok := o.(AllowedAddressPairsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AllowedAddressPairsType) String() string {
	return "AllowedAddressPairsType"
}

func (t AllowedAddressPairsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AllowedAddressPairsValue{
		MacAddress: macAddressVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAllowedAddressPairsValueNull() AllowedAddressPairsValue {
	return AllowedAddressPairsValue{
		state: attr.ValueStateNull,
	}
}

func NewAllowedAddressPairsValueUnknown() AllowedAddressPairsValue {
	return AllowedAddressPairsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAllowedAddressPairsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AllowedAddressPairsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AllowedAddressPairsValue Attribute Value",
				"While creating a AllowedAddressPairsValue value, a missing attribute value was detected. "+
					"A AllowedAddressPairsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AllowedAddressPairsValue Attribute Type",
				"While creating a AllowedAddressPairsValue value, an invalid attribute value was detected. "+
					"A AllowedAddressPairsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AllowedAddressPairsValue Attribute Value",
				"While creating a AllowedAddressPairsValue value, an extra attribute value was detected. "+
					"A AllowedAddressPairsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AllowedAddressPairsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAllowedAddressPairsValueUnknown(), diags
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewAllowedAddressPairsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	if diags.HasError() {
		return NewAllowedAddressPairsValueUnknown(), diags
	}

	return AllowedAddressPairsValue{
		MacAddress: macAddressVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAllowedAddressPairsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AllowedAddressPairsValue {
	object, diags := NewAllowedAddressPairsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAllowedAddressPairsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AllowedAddressPairsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAllowedAddressPairsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAllowedAddressPairsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAllowedAddressPairsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAllowedAddressPairsValueMust(AllowedAddressPairsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AllowedAddressPairsType) ValueType(ctx context.Context) attr.Value {
	return AllowedAddressPairsValue{}
}

var _ basetypes.ObjectValuable = AllowedAddressPairsValue{}

type AllowedAddressPairsValue struct {
	MacAddress basetypes.StringValue `tfsdk:"mac_address"`
	state      attr.ValueState
}

func (v AllowedAddressPairsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AllowedAddressPairsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AllowedAddressPairsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AllowedAddressPairsValue) String() string {
	return "AllowedAddressPairsValue"
}

func (v AllowedAddressPairsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mac_address": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mac_address": v.MacAddress,
		})

	return objVal, diags
}

func (v AllowedAddressPairsValue) Equal(o attr.Value) bool {
	other, ok := o.(AllowedAddressPairsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	return true
}

func (v AllowedAddressPairsValue) Type(ctx context.Context) attr.Type {
	return AllowedAddressPairsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AllowedAddressPairsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mac_address": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FixedIpsType{}

type FixedIpsType struct {
	basetypes.ObjectType
}

func (t FixedIpsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedIpsType) String() string {
	return "FixedIpsType"
}

func (t FixedIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueNull() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedIpsValueUnknown() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, a missing attribute value was detected. "+
					"A FixedIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedIpsValue Attribute Type",
				"While creating a FixedIpsValue value, an invalid attribute value was detected. "+
					"A FixedIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, an extra attribute value was detected. "+
					"A FixedIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedIpsValue {
	object, diags := NewFixedIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedIpsValueMust(FixedIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedIpsType) ValueType(ctx context.Context) attr.Value {
	return FixedIpsValue{}
}

var _ basetypes.ObjectValuable = FixedIpsValue{}

type FixedIpsValue struct {
	IpAddress basetypes.StringValue `tfsdk:"ip_address"`
	SubnetId  basetypes.StringValue `tfsdk:"subnet_id"`
	state     attr.ValueState
}

func (v FixedIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedIpsValue) String() string {
	return "FixedIpsValue"
}

func (v FixedIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address": v.IpAddress,
			"subnet_id":  v.SubnetId,
		})

	return objVal, diags
}

func (v FixedIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v FixedIpsValue) Type(ctx context.Context) attr.Type {
	return FixedIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroupsType{}

type SecurityGroupsType struct {
	basetypes.ObjectType
}

func (t SecurityGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroupsType) String() string {
	return "SecurityGroupsType"
}

func (t SecurityGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return nil, diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return nil, diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return nil, diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerAbbreviationAttribute, ok := attributes["customer_abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_abbreviation is missing from object`)

		return nil, diags
	}

	customerAbbreviationVal, ok := customerAbbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_abbreviation expected to be basetypes.StringValue, was: %T`, customerAbbreviationAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return nil, diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerNativeNameAttribute, ok := attributes["customer_native_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_native_name is missing from object`)

		return nil, diags
	}

	customerNativeNameVal, ok := customerNativeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_native_name expected to be basetypes.StringValue, was: %T`, customerNativeNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return nil, diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	errorTracebackAttribute, ok := attributes["error_traceback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_traceback is missing from object`)

		return nil, diags
	}

	errorTracebackVal, ok := errorTracebackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_traceback expected to be basetypes.StringValue, was: %T`, errorTracebackAttribute))
	}

	isLimitBasedAttribute, ok := attributes["is_limit_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_limit_based is missing from object`)

		return nil, diags
	}

	isLimitBasedVal, ok := isLimitBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_limit_based expected to be basetypes.BoolValue, was: %T`, isLimitBasedAttribute))
	}

	isUsageBasedAttribute, ok := attributes["is_usage_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_usage_based is missing from object`)

		return nil, diags
	}

	isUsageBasedVal, ok := isUsageBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_usage_based expected to be basetypes.BoolValue, was: %T`, isUsageBasedAttribute))
	}

	marketplaceCategoryNameAttribute, ok := attributes["marketplace_category_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_name is missing from object`)

		return nil, diags
	}

	marketplaceCategoryNameVal, ok := marketplaceCategoryNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_name expected to be basetypes.StringValue, was: %T`, marketplaceCategoryNameAttribute))
	}

	marketplaceCategoryUuidAttribute, ok := attributes["marketplace_category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_uuid is missing from object`)

		return nil, diags
	}

	marketplaceCategoryUuidVal, ok := marketplaceCategoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_uuid expected to be basetypes.StringValue, was: %T`, marketplaceCategoryUuidAttribute))
	}

	marketplaceOfferingNameAttribute, ok := attributes["marketplace_offering_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_name is missing from object`)

		return nil, diags
	}

	marketplaceOfferingNameVal, ok := marketplaceOfferingNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_name expected to be basetypes.StringValue, was: %T`, marketplaceOfferingNameAttribute))
	}

	marketplaceOfferingUuidAttribute, ok := attributes["marketplace_offering_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_uuid is missing from object`)

		return nil, diags
	}

	marketplaceOfferingUuidVal, ok := marketplaceOfferingUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_uuid expected to be basetypes.StringValue, was: %T`, marketplaceOfferingUuidAttribute))
	}

	marketplacePlanUuidAttribute, ok := attributes["marketplace_plan_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_plan_uuid is missing from object`)

		return nil, diags
	}

	marketplacePlanUuidVal, ok := marketplacePlanUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_plan_uuid expected to be basetypes.StringValue, was: %T`, marketplacePlanUuidAttribute))
	}

	marketplaceResourceStateAttribute, ok := attributes["marketplace_resource_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_state is missing from object`)

		return nil, diags
	}

	marketplaceResourceStateVal, ok := marketplaceResourceStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_state expected to be basetypes.StringValue, was: %T`, marketplaceResourceStateAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return nil, diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	modifiedAttribute, ok := attributes["modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified is missing from object`)

		return nil, diags
	}

	modifiedVal, ok := modifiedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified expected to be basetypes.StringValue, was: %T`, modifiedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return nil, diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return nil, diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return nil, diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serviceNameAttribute, ok := attributes["service_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_name is missing from object`)

		return nil, diags
	}

	serviceNameVal, ok := serviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_name expected to be basetypes.StringValue, was: %T`, serviceNameAttribute))
	}

	serviceSettingsAttribute, ok := attributes["service_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings is missing from object`)

		return nil, diags
	}

	serviceSettingsVal, ok := serviceSettingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings expected to be basetypes.StringValue, was: %T`, serviceSettingsAttribute))
	}

	serviceSettingsErrorMessageAttribute, ok := attributes["service_settings_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_error_message is missing from object`)

		return nil, diags
	}

	serviceSettingsErrorMessageVal, ok := serviceSettingsErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_error_message expected to be basetypes.StringValue, was: %T`, serviceSettingsErrorMessageAttribute))
	}

	serviceSettingsStateAttribute, ok := attributes["service_settings_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_state is missing from object`)

		return nil, diags
	}

	serviceSettingsStateVal, ok := serviceSettingsStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_state expected to be basetypes.StringValue, was: %T`, serviceSettingsStateAttribute))
	}

	serviceSettingsUuidAttribute, ok := attributes["service_settings_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_uuid is missing from object`)

		return nil, diags
	}

	serviceSettingsUuidVal, ok := serviceSettingsUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_uuid expected to be basetypes.StringValue, was: %T`, serviceSettingsUuidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	tenantNameAttribute, ok := attributes["tenant_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_name is missing from object`)

		return nil, diags
	}

	tenantNameVal, ok := tenantNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_name expected to be basetypes.StringValue, was: %T`, tenantNameAttribute))
	}

	tenantUuidAttribute, ok := attributes["tenant_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_uuid is missing from object`)

		return nil, diags
	}

	tenantUuidVal, ok := tenantUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_uuid expected to be basetypes.StringValue, was: %T`, tenantUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroupsValue{
		AccessUrl:                   accessUrlVal,
		BackendId:                   backendIdVal,
		Created:                     createdVal,
		Customer:                    customerVal,
		CustomerAbbreviation:        customerAbbreviationVal,
		CustomerName:                customerNameVal,
		CustomerNativeName:          customerNativeNameVal,
		Description:                 descriptionVal,
		ErrorMessage:                errorMessageVal,
		ErrorTraceback:              errorTracebackVal,
		IsLimitBased:                isLimitBasedVal,
		IsUsageBased:                isUsageBasedVal,
		MarketplaceCategoryName:     marketplaceCategoryNameVal,
		MarketplaceCategoryUuid:     marketplaceCategoryUuidVal,
		MarketplaceOfferingName:     marketplaceOfferingNameVal,
		MarketplaceOfferingUuid:     marketplaceOfferingUuidVal,
		MarketplacePlanUuid:         marketplacePlanUuidVal,
		MarketplaceResourceState:    marketplaceResourceStateVal,
		MarketplaceResourceUuid:     marketplaceResourceUuidVal,
		Modified:                    modifiedVal,
		Name:                        nameVal,
		Project:                     projectVal,
		ProjectName:                 projectNameVal,
		ProjectUuid:                 projectUuidVal,
		ResourceType:                resourceTypeVal,
		Rules:                       rulesVal,
		ServiceName:                 serviceNameVal,
		ServiceSettings:             serviceSettingsVal,
		ServiceSettingsErrorMessage: serviceSettingsErrorMessageVal,
		ServiceSettingsState:        serviceSettingsStateVal,
		ServiceSettingsUuid:         serviceSettingsUuidVal,
		State:                       stateVal,
		Tenant:                      tenantVal,
		TenantName:                  tenantNameVal,
		TenantUuid:                  tenantUuidVal,
		Url:                         urlVal,
		Uuid:                        uuidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueNull() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroupsValueUnknown() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, a missing attribute value was detected. "+
					"A SecurityGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroupsValue Attribute Type",
				"While creating a SecurityGroupsValue value, an invalid attribute value was detected. "+
					"A SecurityGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, an extra attribute value was detected. "+
					"A SecurityGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerAbbreviationAttribute, ok := attributes["customer_abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_abbreviation is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerAbbreviationVal, ok := customerAbbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_abbreviation expected to be basetypes.StringValue, was: %T`, customerAbbreviationAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerNativeNameAttribute, ok := attributes["customer_native_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_native_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerNativeNameVal, ok := customerNativeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_native_name expected to be basetypes.StringValue, was: %T`, customerNativeNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	errorTracebackAttribute, ok := attributes["error_traceback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_traceback is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	errorTracebackVal, ok := errorTracebackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_traceback expected to be basetypes.StringValue, was: %T`, errorTracebackAttribute))
	}

	isLimitBasedAttribute, ok := attributes["is_limit_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_limit_based is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	isLimitBasedVal, ok := isLimitBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_limit_based expected to be basetypes.BoolValue, was: %T`, isLimitBasedAttribute))
	}

	isUsageBasedAttribute, ok := attributes["is_usage_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_usage_based is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	isUsageBasedVal, ok := isUsageBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_usage_based expected to be basetypes.BoolValue, was: %T`, isUsageBasedAttribute))
	}

	marketplaceCategoryNameAttribute, ok := attributes["marketplace_category_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceCategoryNameVal, ok := marketplaceCategoryNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_name expected to be basetypes.StringValue, was: %T`, marketplaceCategoryNameAttribute))
	}

	marketplaceCategoryUuidAttribute, ok := attributes["marketplace_category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceCategoryUuidVal, ok := marketplaceCategoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_uuid expected to be basetypes.StringValue, was: %T`, marketplaceCategoryUuidAttribute))
	}

	marketplaceOfferingNameAttribute, ok := attributes["marketplace_offering_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceOfferingNameVal, ok := marketplaceOfferingNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_name expected to be basetypes.StringValue, was: %T`, marketplaceOfferingNameAttribute))
	}

	marketplaceOfferingUuidAttribute, ok := attributes["marketplace_offering_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceOfferingUuidVal, ok := marketplaceOfferingUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_uuid expected to be basetypes.StringValue, was: %T`, marketplaceOfferingUuidAttribute))
	}

	marketplacePlanUuidAttribute, ok := attributes["marketplace_plan_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_plan_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplacePlanUuidVal, ok := marketplacePlanUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_plan_uuid expected to be basetypes.StringValue, was: %T`, marketplacePlanUuidAttribute))
	}

	marketplaceResourceStateAttribute, ok := attributes["marketplace_resource_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceResourceStateVal, ok := marketplaceResourceStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_state expected to be basetypes.StringValue, was: %T`, marketplaceResourceStateAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	modifiedAttribute, ok := attributes["modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	modifiedVal, ok := modifiedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified expected to be basetypes.StringValue, was: %T`, modifiedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serviceNameAttribute, ok := attributes["service_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceNameVal, ok := serviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_name expected to be basetypes.StringValue, was: %T`, serviceNameAttribute))
	}

	serviceSettingsAttribute, ok := attributes["service_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsVal, ok := serviceSettingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings expected to be basetypes.StringValue, was: %T`, serviceSettingsAttribute))
	}

	serviceSettingsErrorMessageAttribute, ok := attributes["service_settings_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_error_message is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsErrorMessageVal, ok := serviceSettingsErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_error_message expected to be basetypes.StringValue, was: %T`, serviceSettingsErrorMessageAttribute))
	}

	serviceSettingsStateAttribute, ok := attributes["service_settings_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsStateVal, ok := serviceSettingsStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_state expected to be basetypes.StringValue, was: %T`, serviceSettingsStateAttribute))
	}

	serviceSettingsUuidAttribute, ok := attributes["service_settings_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsUuidVal, ok := serviceSettingsUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_uuid expected to be basetypes.StringValue, was: %T`, serviceSettingsUuidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	tenantNameAttribute, ok := attributes["tenant_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantNameVal, ok := tenantNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_name expected to be basetypes.StringValue, was: %T`, tenantNameAttribute))
	}

	tenantUuidAttribute, ok := attributes["tenant_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantUuidVal, ok := tenantUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_uuid expected to be basetypes.StringValue, was: %T`, tenantUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	return SecurityGroupsValue{
		AccessUrl:                   accessUrlVal,
		BackendId:                   backendIdVal,
		Created:                     createdVal,
		Customer:                    customerVal,
		CustomerAbbreviation:        customerAbbreviationVal,
		CustomerName:                customerNameVal,
		CustomerNativeName:          customerNativeNameVal,
		Description:                 descriptionVal,
		ErrorMessage:                errorMessageVal,
		ErrorTraceback:              errorTracebackVal,
		IsLimitBased:                isLimitBasedVal,
		IsUsageBased:                isUsageBasedVal,
		MarketplaceCategoryName:     marketplaceCategoryNameVal,
		MarketplaceCategoryUuid:     marketplaceCategoryUuidVal,
		MarketplaceOfferingName:     marketplaceOfferingNameVal,
		MarketplaceOfferingUuid:     marketplaceOfferingUuidVal,
		MarketplacePlanUuid:         marketplacePlanUuidVal,
		MarketplaceResourceState:    marketplaceResourceStateVal,
		MarketplaceResourceUuid:     marketplaceResourceUuidVal,
		Modified:                    modifiedVal,
		Name:                        nameVal,
		Project:                     projectVal,
		ProjectName:                 projectNameVal,
		ProjectUuid:                 projectUuidVal,
		ResourceType:                resourceTypeVal,
		Rules:                       rulesVal,
		ServiceName:                 serviceNameVal,
		ServiceSettings:             serviceSettingsVal,
		ServiceSettingsErrorMessage: serviceSettingsErrorMessageVal,
		ServiceSettingsState:        serviceSettingsStateVal,
		ServiceSettingsUuid:         serviceSettingsUuidVal,
		State:                       stateVal,
		Tenant:                      tenantVal,
		TenantName:                  tenantNameVal,
		TenantUuid:                  tenantUuidVal,
		Url:                         urlVal,
		Uuid:                        uuidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroupsValue {
	object, diags := NewSecurityGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroupsValueMust(SecurityGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroupsType) ValueType(ctx context.Context) attr.Value {
	return SecurityGroupsValue{}
}

var _ basetypes.ObjectValuable = SecurityGroupsValue{}

type SecurityGroupsValue struct {
	AccessUrl                   basetypes.StringValue `tfsdk:"access_url"`
	BackendId                   basetypes.StringValue `tfsdk:"backend_id"`
	Created                     basetypes.StringValue `tfsdk:"created"`
	Customer                    basetypes.StringValue `tfsdk:"customer"`
	CustomerAbbreviation        basetypes.StringValue `tfsdk:"customer_abbreviation"`
	CustomerName                basetypes.StringValue `tfsdk:"customer_name"`
	CustomerNativeName          basetypes.StringValue `tfsdk:"customer_native_name"`
	Description                 basetypes.StringValue `tfsdk:"description"`
	ErrorMessage                basetypes.StringValue `tfsdk:"error_message"`
	ErrorTraceback              basetypes.StringValue `tfsdk:"error_traceback"`
	IsLimitBased                basetypes.BoolValue   `tfsdk:"is_limit_based"`
	IsUsageBased                basetypes.BoolValue   `tfsdk:"is_usage_based"`
	MarketplaceCategoryName     basetypes.StringValue `tfsdk:"marketplace_category_name"`
	MarketplaceCategoryUuid     basetypes.StringValue `tfsdk:"marketplace_category_uuid"`
	MarketplaceOfferingName     basetypes.StringValue `tfsdk:"marketplace_offering_name"`
	MarketplaceOfferingUuid     basetypes.StringValue `tfsdk:"marketplace_offering_uuid"`
	MarketplacePlanUuid         basetypes.StringValue `tfsdk:"marketplace_plan_uuid"`
	MarketplaceResourceState    basetypes.StringValue `tfsdk:"marketplace_resource_state"`
	MarketplaceResourceUuid     basetypes.StringValue `tfsdk:"marketplace_resource_uuid"`
	Modified                    basetypes.StringValue `tfsdk:"modified"`
	Name                        basetypes.StringValue `tfsdk:"name"`
	Project                     basetypes.StringValue `tfsdk:"project"`
	ProjectName                 basetypes.StringValue `tfsdk:"project_name"`
	ProjectUuid                 basetypes.StringValue `tfsdk:"project_uuid"`
	ResourceType                basetypes.StringValue `tfsdk:"resource_type"`
	Rules                       basetypes.ListValue   `tfsdk:"rules"`
	ServiceName                 basetypes.StringValue `tfsdk:"service_name"`
	ServiceSettings             basetypes.StringValue `tfsdk:"service_settings"`
	ServiceSettingsErrorMessage basetypes.StringValue `tfsdk:"service_settings_error_message"`
	ServiceSettingsState        basetypes.StringValue `tfsdk:"service_settings_state"`
	ServiceSettingsUuid         basetypes.StringValue `tfsdk:"service_settings_uuid"`
	State                       basetypes.StringValue `tfsdk:"state"`
	Tenant                      basetypes.StringValue `tfsdk:"tenant"`
	TenantName                  basetypes.StringValue `tfsdk:"tenant_name"`
	TenantUuid                  basetypes.StringValue `tfsdk:"tenant_uuid"`
	Url                         basetypes.StringValue `tfsdk:"url"`
	Uuid                        basetypes.StringValue `tfsdk:"uuid"`
	state                       attr.ValueState
}

func (v SecurityGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 37)

	var val tftypes.Value
	var err error

	attrTypes["access_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backend_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_abbreviation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_native_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["error_traceback"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_limit_based"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_usage_based"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["marketplace_category_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_category_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_offering_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_offering_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_plan_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: RulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 37)

		val, err = v.AccessUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_url"] = val

		val, err = v.BackendId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_id"] = val

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Customer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer"] = val

		val, err = v.CustomerAbbreviation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_abbreviation"] = val

		val, err = v.CustomerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_name"] = val

		val, err = v.CustomerNativeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_native_name"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.ErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_message"] = val

		val, err = v.ErrorTraceback.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_traceback"] = val

		val, err = v.IsLimitBased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_limit_based"] = val

		val, err = v.IsUsageBased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_usage_based"] = val

		val, err = v.MarketplaceCategoryName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_category_name"] = val

		val, err = v.MarketplaceCategoryUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_category_uuid"] = val

		val, err = v.MarketplaceOfferingName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_offering_name"] = val

		val, err = v.MarketplaceOfferingUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_offering_uuid"] = val

		val, err = v.MarketplacePlanUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_plan_uuid"] = val

		val, err = v.MarketplaceResourceState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_state"] = val

		val, err = v.MarketplaceResourceUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_uuid"] = val

		val, err = v.Modified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		val, err = v.ProjectName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_name"] = val

		val, err = v.ProjectUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_uuid"] = val

		val, err = v.ResourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_type"] = val

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		val, err = v.ServiceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_name"] = val

		val, err = v.ServiceSettings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings"] = val

		val, err = v.ServiceSettingsErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_error_message"] = val

		val, err = v.ServiceSettingsState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_state"] = val

		val, err = v.ServiceSettingsUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_uuid"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.TenantName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_name"] = val

		val, err = v.TenantUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroupsValue) String() string {
	return "SecurityGroupsValue"
}

func (v SecurityGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	rules := types.ListValueMust(
		RulesType{
			basetypes.ObjectType{
				AttrTypes: RulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Rules.Elements(),
	)

	if v.Rules.IsNull() {
		rules = types.ListNull(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rules.IsUnknown() {
		rules = types.ListUnknown(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"access_url":                 basetypes.StringType{},
		"backend_id":                 basetypes.StringType{},
		"created":                    basetypes.StringType{},
		"customer":                   basetypes.StringType{},
		"customer_abbreviation":      basetypes.StringType{},
		"customer_name":              basetypes.StringType{},
		"customer_native_name":       basetypes.StringType{},
		"description":                basetypes.StringType{},
		"error_message":              basetypes.StringType{},
		"error_traceback":            basetypes.StringType{},
		"is_limit_based":             basetypes.BoolType{},
		"is_usage_based":             basetypes.BoolType{},
		"marketplace_category_name":  basetypes.StringType{},
		"marketplace_category_uuid":  basetypes.StringType{},
		"marketplace_offering_name":  basetypes.StringType{},
		"marketplace_offering_uuid":  basetypes.StringType{},
		"marketplace_plan_uuid":      basetypes.StringType{},
		"marketplace_resource_state": basetypes.StringType{},
		"marketplace_resource_uuid":  basetypes.StringType{},
		"modified":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"project":                    basetypes.StringType{},
		"project_name":               basetypes.StringType{},
		"project_uuid":               basetypes.StringType{},
		"resource_type":              basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"service_name":                   basetypes.StringType{},
		"service_settings":               basetypes.StringType{},
		"service_settings_error_message": basetypes.StringType{},
		"service_settings_state":         basetypes.StringType{},
		"service_settings_uuid":          basetypes.StringType{},
		"state":                          basetypes.StringType{},
		"tenant":                         basetypes.StringType{},
		"tenant_name":                    basetypes.StringType{},
		"tenant_uuid":                    basetypes.StringType{},
		"url":                            basetypes.StringType{},
		"uuid":                           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_url":                     v.AccessUrl,
			"backend_id":                     v.BackendId,
			"created":                        v.Created,
			"customer":                       v.Customer,
			"customer_abbreviation":          v.CustomerAbbreviation,
			"customer_name":                  v.CustomerName,
			"customer_native_name":           v.CustomerNativeName,
			"description":                    v.Description,
			"error_message":                  v.ErrorMessage,
			"error_traceback":                v.ErrorTraceback,
			"is_limit_based":                 v.IsLimitBased,
			"is_usage_based":                 v.IsUsageBased,
			"marketplace_category_name":      v.MarketplaceCategoryName,
			"marketplace_category_uuid":      v.MarketplaceCategoryUuid,
			"marketplace_offering_name":      v.MarketplaceOfferingName,
			"marketplace_offering_uuid":      v.MarketplaceOfferingUuid,
			"marketplace_plan_uuid":          v.MarketplacePlanUuid,
			"marketplace_resource_state":     v.MarketplaceResourceState,
			"marketplace_resource_uuid":      v.MarketplaceResourceUuid,
			"modified":                       v.Modified,
			"name":                           v.Name,
			"project":                        v.Project,
			"project_name":                   v.ProjectName,
			"project_uuid":                   v.ProjectUuid,
			"resource_type":                  v.ResourceType,
			"rules":                          rules,
			"service_name":                   v.ServiceName,
			"service_settings":               v.ServiceSettings,
			"service_settings_error_message": v.ServiceSettingsErrorMessage,
			"service_settings_state":         v.ServiceSettingsState,
			"service_settings_uuid":          v.ServiceSettingsUuid,
			"state":                          v.State,
			"tenant":                         v.Tenant,
			"tenant_name":                    v.TenantName,
			"tenant_uuid":                    v.TenantUuid,
			"url":                            v.Url,
			"uuid":                           v.Uuid,
		})

	return objVal, diags
}

func (v SecurityGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessUrl.Equal(other.AccessUrl) {
		return false
	}

	if !v.BackendId.Equal(other.BackendId) {
		return false
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Customer.Equal(other.Customer) {
		return false
	}

	if !v.CustomerAbbreviation.Equal(other.CustomerAbbreviation) {
		return false
	}

	if !v.CustomerName.Equal(other.CustomerName) {
		return false
	}

	if !v.CustomerNativeName.Equal(other.CustomerNativeName) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.ErrorMessage.Equal(other.ErrorMessage) {
		return false
	}

	if !v.ErrorTraceback.Equal(other.ErrorTraceback) {
		return false
	}

	if !v.IsLimitBased.Equal(other.IsLimitBased) {
		return false
	}

	if !v.IsUsageBased.Equal(other.IsUsageBased) {
		return false
	}

	if !v.MarketplaceCategoryName.Equal(other.MarketplaceCategoryName) {
		return false
	}

	if !v.MarketplaceCategoryUuid.Equal(other.MarketplaceCategoryUuid) {
		return false
	}

	if !v.MarketplaceOfferingName.Equal(other.MarketplaceOfferingName) {
		return false
	}

	if !v.MarketplaceOfferingUuid.Equal(other.MarketplaceOfferingUuid) {
		return false
	}

	if !v.MarketplacePlanUuid.Equal(other.MarketplacePlanUuid) {
		return false
	}

	if !v.MarketplaceResourceState.Equal(other.MarketplaceResourceState) {
		return false
	}

	if !v.MarketplaceResourceUuid.Equal(other.MarketplaceResourceUuid) {
		return false
	}

	if !v.Modified.Equal(other.Modified) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	if !v.ProjectName.Equal(other.ProjectName) {
		return false
	}

	if !v.ProjectUuid.Equal(other.ProjectUuid) {
		return false
	}

	if !v.ResourceType.Equal(other.ResourceType) {
		return false
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	if !v.ServiceName.Equal(other.ServiceName) {
		return false
	}

	if !v.ServiceSettings.Equal(other.ServiceSettings) {
		return false
	}

	if !v.ServiceSettingsErrorMessage.Equal(other.ServiceSettingsErrorMessage) {
		return false
	}

	if !v.ServiceSettingsState.Equal(other.ServiceSettingsState) {
		return false
	}

	if !v.ServiceSettingsUuid.Equal(other.ServiceSettingsUuid) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.TenantName.Equal(other.TenantName) {
		return false
	}

	if !v.TenantUuid.Equal(other.TenantUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v SecurityGroupsValue) Type(ctx context.Context) attr.Type {
	return SecurityGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_url":                 basetypes.StringType{},
		"backend_id":                 basetypes.StringType{},
		"created":                    basetypes.StringType{},
		"customer":                   basetypes.StringType{},
		"customer_abbreviation":      basetypes.StringType{},
		"customer_name":              basetypes.StringType{},
		"customer_native_name":       basetypes.StringType{},
		"description":                basetypes.StringType{},
		"error_message":              basetypes.StringType{},
		"error_traceback":            basetypes.StringType{},
		"is_limit_based":             basetypes.BoolType{},
		"is_usage_based":             basetypes.BoolType{},
		"marketplace_category_name":  basetypes.StringType{},
		"marketplace_category_uuid":  basetypes.StringType{},
		"marketplace_offering_name":  basetypes.StringType{},
		"marketplace_offering_uuid":  basetypes.StringType{},
		"marketplace_plan_uuid":      basetypes.StringType{},
		"marketplace_resource_state": basetypes.StringType{},
		"marketplace_resource_uuid":  basetypes.StringType{},
		"modified":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"project":                    basetypes.StringType{},
		"project_name":               basetypes.StringType{},
		"project_uuid":               basetypes.StringType{},
		"resource_type":              basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"service_name":                   basetypes.StringType{},
		"service_settings":               basetypes.StringType{},
		"service_settings_error_message": basetypes.StringType{},
		"service_settings_state":         basetypes.StringType{},
		"service_settings_uuid":          basetypes.StringType{},
		"state":                          basetypes.StringType{},
		"tenant":                         basetypes.StringType{},
		"tenant_name":                    basetypes.StringType{},
		"tenant_uuid":                    basetypes.StringType{},
		"url":                            basetypes.StringType{},
		"uuid":                           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RulesType{}

type RulesType struct {
	basetypes.ObjectType
}

func (t RulesType) Equal(o attr.Type) bool {
	other, ok := o.(RulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RulesType) String() string {
	return "RulesType"
}

func (t RulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return nil, diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	fromPortAttribute, ok := attributes["from_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_port is missing from object`)

		return nil, diags
	}

	fromPortVal, ok := fromPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_port expected to be basetypes.Int64Value, was: %T`, fromPortAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	remoteGroupAttribute, ok := attributes["remote_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group is missing from object`)

		return nil, diags
	}

	remoteGroupVal, ok := remoteGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group expected to be basetypes.StringValue, was: %T`, remoteGroupAttribute))
	}

	remoteGroupNameAttribute, ok := attributes["remote_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_name is missing from object`)

		return nil, diags
	}

	remoteGroupNameVal, ok := remoteGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_name expected to be basetypes.StringValue, was: %T`, remoteGroupNameAttribute))
	}

	remoteGroupUuidAttribute, ok := attributes["remote_group_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_uuid is missing from object`)

		return nil, diags
	}

	remoteGroupUuidVal, ok := remoteGroupUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_uuid expected to be basetypes.StringValue, was: %T`, remoteGroupUuidAttribute))
	}

	toPortAttribute, ok := attributes["to_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_port is missing from object`)

		return nil, diags
	}

	toPortVal, ok := toPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_port expected to be basetypes.Int64Value, was: %T`, toPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RulesValue{
		Cidr:            cidrVal,
		Description:     descriptionVal,
		Direction:       directionVal,
		Ethertype:       ethertypeVal,
		FromPort:        fromPortVal,
		Id:              idVal,
		RemoteGroup:     remoteGroupVal,
		RemoteGroupName: remoteGroupNameVal,
		RemoteGroupUuid: remoteGroupUuidVal,
		ToPort:          toPortVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRulesValueNull() RulesValue {
	return RulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRulesValueUnknown() RulesValue {
	return RulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RulesValue Attribute Value",
				"While creating a RulesValue value, a missing attribute value was detected. "+
					"A RulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RulesValue Attribute Type",
				"While creating a RulesValue value, an invalid attribute value was detected. "+
					"A RulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RulesValue Attribute Value",
				"While creating a RulesValue value, an extra attribute value was detected. "+
					"A RulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	fromPortAttribute, ok := attributes["from_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_port is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	fromPortVal, ok := fromPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_port expected to be basetypes.Int64Value, was: %T`, fromPortAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	remoteGroupAttribute, ok := attributes["remote_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupVal, ok := remoteGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group expected to be basetypes.StringValue, was: %T`, remoteGroupAttribute))
	}

	remoteGroupNameAttribute, ok := attributes["remote_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_name is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupNameVal, ok := remoteGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_name expected to be basetypes.StringValue, was: %T`, remoteGroupNameAttribute))
	}

	remoteGroupUuidAttribute, ok := attributes["remote_group_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_uuid is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupUuidVal, ok := remoteGroupUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_uuid expected to be basetypes.StringValue, was: %T`, remoteGroupUuidAttribute))
	}

	toPortAttribute, ok := attributes["to_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_port is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	toPortVal, ok := toPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_port expected to be basetypes.Int64Value, was: %T`, toPortAttribute))
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	return RulesValue{
		Cidr:            cidrVal,
		Description:     descriptionVal,
		Direction:       directionVal,
		Ethertype:       ethertypeVal,
		FromPort:        fromPortVal,
		Id:              idVal,
		RemoteGroup:     remoteGroupVal,
		RemoteGroupName: remoteGroupNameVal,
		RemoteGroupUuid: remoteGroupUuidVal,
		ToPort:          toPortVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RulesValue {
	object, diags := NewRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRulesValueMust(RulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RulesType) ValueType(ctx context.Context) attr.Value {
	return RulesValue{}
}

var _ basetypes.ObjectValuable = RulesValue{}

type RulesValue struct {
	Cidr            basetypes.StringValue `tfsdk:"cidr"`
	Description     basetypes.StringValue `tfsdk:"description"`
	Direction       basetypes.StringValue `tfsdk:"direction"`
	Ethertype       basetypes.StringValue `tfsdk:"ethertype"`
	FromPort        basetypes.Int64Value  `tfsdk:"from_port"`
	Id              basetypes.Int64Value  `tfsdk:"id"`
	RemoteGroup     basetypes.StringValue `tfsdk:"remote_group"`
	RemoteGroupName basetypes.StringValue `tfsdk:"remote_group_name"`
	RemoteGroupUuid basetypes.StringValue `tfsdk:"remote_group_uuid"`
	ToPort          basetypes.Int64Value  `tfsdk:"to_port"`
	state           attr.ValueState
}

func (v RulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ethertype"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_group_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_group_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Ethertype.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethertype"] = val

		val, err = v.FromPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_port"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.RemoteGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group"] = val

		val, err = v.RemoteGroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group_name"] = val

		val, err = v.RemoteGroupUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group_uuid"] = val

		val, err = v.ToPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RulesValue) String() string {
	return "RulesValue"
}

func (v RulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cidr":              basetypes.StringType{},
		"description":       basetypes.StringType{},
		"direction":         basetypes.StringType{},
		"ethertype":         basetypes.StringType{},
		"from_port":         basetypes.Int64Type{},
		"id":                basetypes.Int64Type{},
		"remote_group":      basetypes.StringType{},
		"remote_group_name": basetypes.StringType{},
		"remote_group_uuid": basetypes.StringType{},
		"to_port":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cidr":              v.Cidr,
			"description":       v.Description,
			"direction":         v.Direction,
			"ethertype":         v.Ethertype,
			"from_port":         v.FromPort,
			"id":                v.Id,
			"remote_group":      v.RemoteGroup,
			"remote_group_name": v.RemoteGroupName,
			"remote_group_uuid": v.RemoteGroupUuid,
			"to_port":           v.ToPort,
		})

	return objVal, diags
}

func (v RulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Ethertype.Equal(other.Ethertype) {
		return false
	}

	if !v.FromPort.Equal(other.FromPort) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.RemoteGroup.Equal(other.RemoteGroup) {
		return false
	}

	if !v.RemoteGroupName.Equal(other.RemoteGroupName) {
		return false
	}

	if !v.RemoteGroupUuid.Equal(other.RemoteGroupUuid) {
		return false
	}

	if !v.ToPort.Equal(other.ToPort) {
		return false
	}

	return true
}

func (v RulesValue) Type(ctx context.Context) attr.Type {
	return RulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":              basetypes.StringType{},
		"description":       basetypes.StringType{},
		"direction":         basetypes.StringType{},
		"ethertype":         basetypes.StringType{},
		"from_port":         basetypes.Int64Type{},
		"id":                basetypes.Int64Type{},
		"remote_group":      basetypes.StringType{},
		"remote_group_name": basetypes.StringType{},
		"remote_group_uuid": basetypes.StringType{},
		"to_port":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RancherClusterType{}

type RancherClusterType struct {
	basetypes.ObjectType
}

func (t RancherClusterType) Equal(o attr.Type) bool {
	other, ok := o.(RancherClusterType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RancherClusterType) String() string {
	return "RancherClusterType"
}

func (t RancherClusterType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	marketplaceUuidAttribute, ok := attributes["marketplace_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_uuid is missing from object`)

		return nil, diags
	}

	marketplaceUuidVal, ok := marketplaceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_uuid expected to be basetypes.StringValue, was: %T`, marketplaceUuidAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RancherClusterValue{
		MarketplaceUuid: marketplaceUuidVal,
		Name:            nameVal,
		Uuid:            uuidVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRancherClusterValueNull() RancherClusterValue {
	return RancherClusterValue{
		state: attr.ValueStateNull,
	}
}

func NewRancherClusterValueUnknown() RancherClusterValue {
	return RancherClusterValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRancherClusterValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RancherClusterValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RancherClusterValue Attribute Value",
				"While creating a RancherClusterValue value, a missing attribute value was detected. "+
					"A RancherClusterValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RancherClusterValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RancherClusterValue Attribute Type",
				"While creating a RancherClusterValue value, an invalid attribute value was detected. "+
					"A RancherClusterValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RancherClusterValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RancherClusterValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RancherClusterValue Attribute Value",
				"While creating a RancherClusterValue value, an extra attribute value was detected. "+
					"A RancherClusterValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RancherClusterValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRancherClusterValueUnknown(), diags
	}

	marketplaceUuidAttribute, ok := attributes["marketplace_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_uuid is missing from object`)

		return NewRancherClusterValueUnknown(), diags
	}

	marketplaceUuidVal, ok := marketplaceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_uuid expected to be basetypes.StringValue, was: %T`, marketplaceUuidAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRancherClusterValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewRancherClusterValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewRancherClusterValueUnknown(), diags
	}

	return RancherClusterValue{
		MarketplaceUuid: marketplaceUuidVal,
		Name:            nameVal,
		Uuid:            uuidVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRancherClusterValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RancherClusterValue {
	object, diags := NewRancherClusterValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRancherClusterValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RancherClusterType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRancherClusterValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRancherClusterValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRancherClusterValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRancherClusterValueMust(RancherClusterValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RancherClusterType) ValueType(ctx context.Context) attr.Value {
	return RancherClusterValue{}
}

var _ basetypes.ObjectValuable = RancherClusterValue{}

type RancherClusterValue struct {
	MarketplaceUuid basetypes.StringValue `tfsdk:"marketplace_uuid"`
	Name            basetypes.StringValue `tfsdk:"name"`
	Uuid            basetypes.StringValue `tfsdk:"uuid"`
	state           attr.ValueState
}

func (v RancherClusterValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["marketplace_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.MarketplaceUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_uuid"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RancherClusterValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RancherClusterValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RancherClusterValue) String() string {
	return "RancherClusterValue"
}

func (v RancherClusterValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"marketplace_uuid": basetypes.StringType{},
		"name":             basetypes.StringType{},
		"uuid":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"marketplace_uuid": v.MarketplaceUuid,
			"name":             v.Name,
			"uuid":             v.Uuid,
		})

	return objVal, diags
}

func (v RancherClusterValue) Equal(o attr.Value) bool {
	other, ok := o.(RancherClusterValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MarketplaceUuid.Equal(other.MarketplaceUuid) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v RancherClusterValue) Type(ctx context.Context) attr.Type {
	return RancherClusterType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RancherClusterValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"marketplace_uuid": basetypes.StringType{},
		"name":             basetypes.StringType{},
		"uuid":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ServerGroupType{}

type ServerGroupType struct {
	basetypes.ObjectType
}

func (t ServerGroupType) Equal(o attr.Type) bool {
	other, ok := o.(ServerGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ServerGroupType) String() string {
	return "ServerGroupType"
}

func (t ServerGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return nil, diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ServerGroupValue{
		Name:   nameVal,
		Policy: policyVal,
		State:  stateVal,
		Url:    urlVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewServerGroupValueNull() ServerGroupValue {
	return ServerGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewServerGroupValueUnknown() ServerGroupValue {
	return ServerGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewServerGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ServerGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ServerGroupValue Attribute Value",
				"While creating a ServerGroupValue value, a missing attribute value was detected. "+
					"A ServerGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ServerGroupValue Attribute Type",
				"While creating a ServerGroupValue value, an invalid attribute value was detected. "+
					"A ServerGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ServerGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ServerGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ServerGroupValue Attribute Value",
				"While creating a ServerGroupValue value, an extra attribute value was detected. "+
					"A ServerGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ServerGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewServerGroupValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewServerGroupValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	policyAttribute, ok := attributes["policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy is missing from object`)

		return NewServerGroupValueUnknown(), diags
	}

	policyVal, ok := policyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy expected to be basetypes.StringValue, was: %T`, policyAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewServerGroupValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewServerGroupValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewServerGroupValueUnknown(), diags
	}

	return ServerGroupValue{
		Name:   nameVal,
		Policy: policyVal,
		State:  stateVal,
		Url:    urlVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewServerGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ServerGroupValue {
	object, diags := NewServerGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewServerGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ServerGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewServerGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewServerGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewServerGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewServerGroupValueMust(ServerGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ServerGroupType) ValueType(ctx context.Context) attr.Value {
	return ServerGroupValue{}
}

var _ basetypes.ObjectValuable = ServerGroupValue{}

type ServerGroupValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Policy basetypes.StringValue `tfsdk:"policy"`
	State  basetypes.StringValue `tfsdk:"state"`
	Url    basetypes.StringValue `tfsdk:"url"`
	state  attr.ValueState
}

func (v ServerGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Policy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ServerGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ServerGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ServerGroupValue) String() string {
	return "ServerGroupValue"
}

func (v ServerGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":   basetypes.StringType{},
		"policy": basetypes.StringType{},
		"state":  basetypes.StringType{},
		"url":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":   v.Name,
			"policy": v.Policy,
			"state":  v.State,
			"url":    v.Url,
		})

	return objVal, diags
}

func (v ServerGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(ServerGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Policy.Equal(other.Policy) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v ServerGroupValue) Type(ctx context.Context) attr.Type {
	return ServerGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ServerGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":   basetypes.StringType{},
		"policy": basetypes.StringType{},
		"state":  basetypes.StringType{},
		"url":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesType{}

type VolumesType struct {
	basetypes.ObjectType
}

func (t VolumesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesType) String() string {
	return "VolumesType"
}

func (t VolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bootableAttribute, ok := attributes["bootable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootable is missing from object`)

		return nil, diags
	}

	bootableVal, ok := bootableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootable expected to be basetypes.BoolValue, was: %T`, bootableAttribute))
	}

	deviceAttribute, ok := attributes["device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device is missing from object`)

		return nil, diags
	}

	deviceVal, ok := deviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device expected to be basetypes.StringValue, was: %T`, deviceAttribute))
	}

	imageNameAttribute, ok := attributes["image_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_name is missing from object`)

		return nil, diags
	}

	imageNameVal, ok := imageNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_name expected to be basetypes.StringValue, was: %T`, imageNameAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return nil, diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return nil, diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	typeNameAttribute, ok := attributes["type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type_name is missing from object`)

		return nil, diags
	}

	typeNameVal, ok := typeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type_name expected to be basetypes.StringValue, was: %T`, typeNameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesValue{
		Bootable:                bootableVal,
		Device:                  deviceVal,
		ImageName:               imageNameVal,
		MarketplaceResourceUuid: marketplaceResourceUuidVal,
		Name:                    nameVal,
		ResourceType:            resourceTypeVal,
		Size:                    sizeVal,
		State:                   stateVal,
		VolumesType:             typeVal,
		TypeName:                typeNameVal,
		Url:                     urlVal,
		Uuid:                    uuidVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueNull() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesValueUnknown() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesValue Attribute Value",
				"While creating a VolumesValue value, a missing attribute value was detected. "+
					"A VolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesValue Attribute Type",
				"While creating a VolumesValue value, an invalid attribute value was detected. "+
					"A VolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesValue Attribute Value",
				"While creating a VolumesValue value, an extra attribute value was detected. "+
					"A VolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	bootableAttribute, ok := attributes["bootable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bootable is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	bootableVal, ok := bootableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bootable expected to be basetypes.BoolValue, was: %T`, bootableAttribute))
	}

	deviceAttribute, ok := attributes["device"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	deviceVal, ok := deviceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device expected to be basetypes.StringValue, was: %T`, deviceAttribute))
	}

	imageNameAttribute, ok := attributes["image_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image_name is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	imageNameVal, ok := imageNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image_name expected to be basetypes.StringValue, was: %T`, imageNameAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	typeNameAttribute, ok := attributes["type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type_name is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	typeNameVal, ok := typeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type_name expected to be basetypes.StringValue, was: %T`, typeNameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	return VolumesValue{
		Bootable:                bootableVal,
		Device:                  deviceVal,
		ImageName:               imageNameVal,
		MarketplaceResourceUuid: marketplaceResourceUuidVal,
		Name:                    nameVal,
		ResourceType:            resourceTypeVal,
		Size:                    sizeVal,
		State:                   stateVal,
		VolumesType:             typeVal,
		TypeName:                typeNameVal,
		Url:                     urlVal,
		Uuid:                    uuidVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesValue {
	object, diags := NewVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesValueMust(VolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesType) ValueType(ctx context.Context) attr.Value {
	return VolumesValue{}
}

var _ basetypes.ObjectValuable = VolumesValue{}

type VolumesValue struct {
	Bootable                basetypes.BoolValue   `tfsdk:"bootable"`
	Device                  basetypes.StringValue `tfsdk:"device"`
	ImageName               basetypes.StringValue `tfsdk:"image_name"`
	MarketplaceResourceUuid basetypes.StringValue `tfsdk:"marketplace_resource_uuid"`
	Name                    basetypes.StringValue `tfsdk:"name"`
	ResourceType            basetypes.StringValue `tfsdk:"resource_type"`
	Size                    basetypes.Int64Value  `tfsdk:"size"`
	State                   basetypes.StringValue `tfsdk:"state"`
	VolumesType             basetypes.StringValue `tfsdk:"type"`
	TypeName                basetypes.StringValue `tfsdk:"type_name"`
	Url                     basetypes.StringValue `tfsdk:"url"`
	Uuid                    basetypes.StringValue `tfsdk:"uuid"`
	state                   attr.ValueState
}

func (v VolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["bootable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["device"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.Bootable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bootable"] = val

		val, err = v.Device.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device"] = val

		val, err = v.ImageName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image_name"] = val

		val, err = v.MarketplaceResourceUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_uuid"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ResourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_type"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.VolumesType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.TypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type_name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesValue) String() string {
	return "VolumesValue"
}

func (v VolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"bootable":                  basetypes.BoolType{},
		"device":                    basetypes.StringType{},
		"image_name":                basetypes.StringType{},
		"marketplace_resource_uuid": basetypes.StringType{},
		"name":                      basetypes.StringType{},
		"resource_type":             basetypes.StringType{},
		"size":                      basetypes.Int64Type{},
		"state":                     basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"type_name":                 basetypes.StringType{},
		"url":                       basetypes.StringType{},
		"uuid":                      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bootable":                  v.Bootable,
			"device":                    v.Device,
			"image_name":                v.ImageName,
			"marketplace_resource_uuid": v.MarketplaceResourceUuid,
			"name":                      v.Name,
			"resource_type":             v.ResourceType,
			"size":                      v.Size,
			"state":                     v.State,
			"type":                      v.VolumesType,
			"type_name":                 v.TypeName,
			"url":                       v.Url,
			"uuid":                      v.Uuid,
		})

	return objVal, diags
}

func (v VolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bootable.Equal(other.Bootable) {
		return false
	}

	if !v.Device.Equal(other.Device) {
		return false
	}

	if !v.ImageName.Equal(other.ImageName) {
		return false
	}

	if !v.MarketplaceResourceUuid.Equal(other.MarketplaceResourceUuid) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ResourceType.Equal(other.ResourceType) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.VolumesType.Equal(other.VolumesType) {
		return false
	}

	if !v.TypeName.Equal(other.TypeName) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v VolumesValue) Type(ctx context.Context) attr.Type {
	return VolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bootable":                  basetypes.BoolType{},
		"device":                    basetypes.StringType{},
		"image_name":                basetypes.StringType{},
		"marketplace_resource_uuid": basetypes.StringType{},
		"name":                      basetypes.StringType{},
		"resource_type":             basetypes.StringType{},
		"size":                      basetypes.Int64Type{},
		"state":                     basetypes.StringType{},
		"type":                      basetypes.StringType{},
		"type_name":                 basetypes.StringType{},
		"url":                       basetypes.StringType{},
		"uuid":                      basetypes.StringType{},
	}
}
