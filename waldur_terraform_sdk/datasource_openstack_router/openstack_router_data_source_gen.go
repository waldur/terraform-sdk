// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_openstack_router

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func OpenstackRouterDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"access_url": schema.StringAttribute{
				Computed: true,
			},
			"backend_id": schema.StringAttribute{
				Computed:            true,
				Description:         "Router ID in OpenStack",
				MarkdownDescription: "Router ID in OpenStack",
			},
			"created": schema.StringAttribute{
				Computed: true,
			},
			"customer": schema.StringAttribute{
				Computed: true,
			},
			"customer_abbreviation": schema.StringAttribute{
				Computed: true,
			},
			"customer_name": schema.StringAttribute{
				Computed: true,
			},
			"customer_native_name": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Computed: true,
			},
			"error_message": schema.StringAttribute{
				Computed: true,
			},
			"error_traceback": schema.StringAttribute{
				Computed: true,
			},
			"field": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"fixed_ips": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ip_address": schema.StringAttribute{
							Computed:            true,
							Description:         "IP address to assign to the port",
							MarkdownDescription: "IP address to assign to the port",
						},
						"subnet_id": schema.StringAttribute{
							Computed:            true,
							Description:         "ID of the subnet in which to assign the IP address",
							MarkdownDescription: "ID of the subnet in which to assign the IP address",
						},
					},
					CustomType: FixedIpsType{
						ObjectType: types.ObjectType{
							AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"is_limit_based": schema.BoolAttribute{
				Computed: true,
			},
			"is_usage_based": schema.BoolAttribute{
				Computed: true,
			},
			"marketplace_category_name": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_category_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_offering_name": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_offering_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_plan_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_resource_state": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_resource_uuid": schema.StringAttribute{
				Computed: true,
			},
			"modified": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"offering_external_ips": schema.ListAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"ports": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"allowed_address_pairs": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"mac_address": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: AllowedAddressPairsType{
									ObjectType: types.ObjectType{
										AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"device_id": schema.StringAttribute{
							Computed:            true,
							Description:         "ID of device (instance, router etc) to which this port is connected",
							MarkdownDescription: "ID of device (instance, router etc) to which this port is connected",
						},
						"device_owner": schema.StringAttribute{
							Computed:            true,
							Description:         "Entity that uses this port (e.g. network:router_interface)",
							MarkdownDescription: "Entity that uses this port (e.g. network:router_interface)",
						},
						"fixed_ips": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ip_address": schema.StringAttribute{
										Computed:            true,
										Description:         "IP address to assign to the port",
										MarkdownDescription: "IP address to assign to the port",
									},
									"subnet_id": schema.StringAttribute{
										Computed:            true,
										Description:         "ID of the subnet in which to assign the IP address",
										MarkdownDescription: "ID of the subnet in which to assign the IP address",
									},
								},
								CustomType: FixedIpsType{
									ObjectType: types.ObjectType{
										AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"mac_address": schema.StringAttribute{
							Computed:            true,
							Description:         "MAC address of the port",
							MarkdownDescription: "MAC address of the port",
						},
						"security_groups": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"access_url": schema.StringAttribute{
										Computed: true,
									},
									"backend_id": schema.StringAttribute{
										Computed: true,
									},
									"created": schema.StringAttribute{
										Computed: true,
									},
									"customer": schema.StringAttribute{
										Computed: true,
									},
									"customer_abbreviation": schema.StringAttribute{
										Computed: true,
									},
									"customer_name": schema.StringAttribute{
										Computed: true,
									},
									"customer_native_name": schema.StringAttribute{
										Computed: true,
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"error_message": schema.StringAttribute{
										Computed: true,
									},
									"error_traceback": schema.StringAttribute{
										Computed: true,
									},
									"is_limit_based": schema.BoolAttribute{
										Computed: true,
									},
									"is_usage_based": schema.BoolAttribute{
										Computed: true,
									},
									"marketplace_category_name": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_category_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_offering_name": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_offering_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_plan_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_resource_state": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_resource_uuid": schema.StringAttribute{
										Computed: true,
									},
									"modified": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"project": schema.StringAttribute{
										Computed: true,
									},
									"project_name": schema.StringAttribute{
										Computed: true,
									},
									"project_uuid": schema.StringAttribute{
										Computed: true,
									},
									"resource_type": schema.StringAttribute{
										Computed: true,
									},
									"rules": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"cidr": schema.StringAttribute{
													Computed:            true,
													Description:         "CIDR notation for the source/destination network address range",
													MarkdownDescription: "CIDR notation for the source/destination network address range",
												},
												"description": schema.StringAttribute{
													Computed: true,
												},
												"direction": schema.StringAttribute{
													Computed:            true,
													Description:         "Traffic direction - either 'ingress' (incoming) or 'egress' (outgoing)",
													MarkdownDescription: "Traffic direction - either 'ingress' (incoming) or 'egress' (outgoing)",
												},
												"ethertype": schema.StringAttribute{
													Computed:            true,
													Description:         "IP protocol version - either 'IPv4' or 'IPv6'",
													MarkdownDescription: "IP protocol version - either 'IPv4' or 'IPv6'",
												},
												"from_port": schema.Int64Attribute{
													Computed:            true,
													Description:         "Starting port number in the range (1-65535)",
													MarkdownDescription: "Starting port number in the range (1-65535)",
												},
												"id": schema.Int64Attribute{
													Computed: true,
												},
												"remote_group": schema.StringAttribute{
													Computed:            true,
													Description:         "Remote security group that this rule references, if any",
													MarkdownDescription: "Remote security group that this rule references, if any",
												},
												"remote_group_name": schema.StringAttribute{
													Computed: true,
												},
												"remote_group_uuid": schema.StringAttribute{
													Computed: true,
												},
												"to_port": schema.Int64Attribute{
													Computed:            true,
													Description:         "Ending port number in the range (1-65535)",
													MarkdownDescription: "Ending port number in the range (1-65535)",
												},
											},
											CustomType: RulesType{
												ObjectType: types.ObjectType{
													AttrTypes: RulesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"service_name": schema.StringAttribute{
										Computed: true,
									},
									"service_settings": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_error_message": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_state": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_uuid": schema.StringAttribute{
										Computed: true,
									},
									"state": schema.StringAttribute{
										Computed: true,
									},
									"tenant": schema.StringAttribute{
										Computed: true,
									},
									"tenant_name": schema.StringAttribute{
										Computed: true,
									},
									"tenant_uuid": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SecurityGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"subnet": schema.StringAttribute{
							Computed:            true,
							Description:         "Subnet to which this port belongs",
							MarkdownDescription: "Subnet to which this port belongs",
						},
						"subnet_cidr": schema.StringAttribute{
							Computed:            true,
							Description:         "IPv4 network address in CIDR format (e.g. 192.168.0.0/24)",
							MarkdownDescription: "IPv4 network address in CIDR format (e.g. 192.168.0.0/24)",
						},
						"subnet_description": schema.StringAttribute{
							Computed: true,
						},
						"subnet_name": schema.StringAttribute{
							Computed: true,
						},
						"subnet_uuid": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: PortsType{
						ObjectType: types.ObjectType{
							AttrTypes: PortsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"project": schema.StringAttribute{
				Computed: true,
			},
			"project_name": schema.StringAttribute{
				Computed: true,
			},
			"project_uuid": schema.StringAttribute{
				Computed: true,
			},
			"resource_type": schema.StringAttribute{
				Computed: true,
			},
			"routes": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"destination": schema.StringAttribute{
							Computed: true,
						},
						"nexthop": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: RoutesType{
						ObjectType: types.ObjectType{
							AttrTypes: RoutesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"service_name": schema.StringAttribute{
				Computed: true,
			},
			"service_settings": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_error_message": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_state": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_uuid": schema.StringAttribute{
				Computed: true,
			},
			"state": schema.StringAttribute{
				Computed: true,
			},
			"tenant": schema.StringAttribute{
				Computed:            true,
				Description:         "OpenStack tenant this router belongs to",
				MarkdownDescription: "OpenStack tenant this router belongs to",
			},
			"tenant_name": schema.StringAttribute{
				Computed: true,
			},
			"tenant_uuid": schema.StringAttribute{
				Computed: true,
			},
			"url": schema.StringAttribute{
				Computed: true,
			},
			"uuid": schema.StringAttribute{
				Required: true,
			},
		},
	}
}

type OpenstackRouterModel struct {
	AccessUrl                   types.String `tfsdk:"access_url"`
	BackendId                   types.String `tfsdk:"backend_id"`
	Created                     types.String `tfsdk:"created"`
	Customer                    types.String `tfsdk:"customer"`
	CustomerAbbreviation        types.String `tfsdk:"customer_abbreviation"`
	CustomerName                types.String `tfsdk:"customer_name"`
	CustomerNativeName          types.String `tfsdk:"customer_native_name"`
	Description                 types.String `tfsdk:"description"`
	ErrorMessage                types.String `tfsdk:"error_message"`
	ErrorTraceback              types.String `tfsdk:"error_traceback"`
	Field                       types.List   `tfsdk:"field"`
	FixedIps                    types.List   `tfsdk:"fixed_ips"`
	IsLimitBased                types.Bool   `tfsdk:"is_limit_based"`
	IsUsageBased                types.Bool   `tfsdk:"is_usage_based"`
	MarketplaceCategoryName     types.String `tfsdk:"marketplace_category_name"`
	MarketplaceCategoryUuid     types.String `tfsdk:"marketplace_category_uuid"`
	MarketplaceOfferingName     types.String `tfsdk:"marketplace_offering_name"`
	MarketplaceOfferingUuid     types.String `tfsdk:"marketplace_offering_uuid"`
	MarketplacePlanUuid         types.String `tfsdk:"marketplace_plan_uuid"`
	MarketplaceResourceState    types.String `tfsdk:"marketplace_resource_state"`
	MarketplaceResourceUuid     types.String `tfsdk:"marketplace_resource_uuid"`
	Modified                    types.String `tfsdk:"modified"`
	Name                        types.String `tfsdk:"name"`
	OfferingExternalIps         types.List   `tfsdk:"offering_external_ips"`
	Ports                       types.List   `tfsdk:"ports"`
	Project                     types.String `tfsdk:"project"`
	ProjectName                 types.String `tfsdk:"project_name"`
	ProjectUuid                 types.String `tfsdk:"project_uuid"`
	ResourceType                types.String `tfsdk:"resource_type"`
	Routes                      types.List   `tfsdk:"routes"`
	ServiceName                 types.String `tfsdk:"service_name"`
	ServiceSettings             types.String `tfsdk:"service_settings"`
	ServiceSettingsErrorMessage types.String `tfsdk:"service_settings_error_message"`
	ServiceSettingsState        types.String `tfsdk:"service_settings_state"`
	ServiceSettingsUuid         types.String `tfsdk:"service_settings_uuid"`
	State                       types.String `tfsdk:"state"`
	Tenant                      types.String `tfsdk:"tenant"`
	TenantName                  types.String `tfsdk:"tenant_name"`
	TenantUuid                  types.String `tfsdk:"tenant_uuid"`
	Url                         types.String `tfsdk:"url"`
	Uuid                        types.String `tfsdk:"uuid"`
}

var _ basetypes.ObjectTypable = FixedIpsType{}

type FixedIpsType struct {
	basetypes.ObjectType
}

func (t FixedIpsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedIpsType) String() string {
	return "FixedIpsType"
}

func (t FixedIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueNull() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedIpsValueUnknown() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, a missing attribute value was detected. "+
					"A FixedIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedIpsValue Attribute Type",
				"While creating a FixedIpsValue value, an invalid attribute value was detected. "+
					"A FixedIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, an extra attribute value was detected. "+
					"A FixedIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedIpsValue {
	object, diags := NewFixedIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedIpsValueMust(FixedIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedIpsType) ValueType(ctx context.Context) attr.Value {
	return FixedIpsValue{}
}

var _ basetypes.ObjectValuable = FixedIpsValue{}

type FixedIpsValue struct {
	IpAddress basetypes.StringValue `tfsdk:"ip_address"`
	SubnetId  basetypes.StringValue `tfsdk:"subnet_id"`
	state     attr.ValueState
}

func (v FixedIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedIpsValue) String() string {
	return "FixedIpsValue"
}

func (v FixedIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address": v.IpAddress,
			"subnet_id":  v.SubnetId,
		})

	return objVal, diags
}

func (v FixedIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v FixedIpsValue) Type(ctx context.Context) attr.Type {
	return FixedIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortsType{}

type PortsType struct {
	basetypes.ObjectType
}

func (t PortsType) Equal(o attr.Type) bool {
	other, ok := o.(PortsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortsType) String() string {
	return "PortsType"
}

func (t PortsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedAddressPairsAttribute, ok := attributes["allowed_address_pairs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_address_pairs is missing from object`)

		return nil, diags
	}

	allowedAddressPairsVal, ok := allowedAddressPairsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_address_pairs expected to be basetypes.ListValue, was: %T`, allowedAddressPairsAttribute))
	}

	deviceIdAttribute, ok := attributes["device_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_id is missing from object`)

		return nil, diags
	}

	deviceIdVal, ok := deviceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_id expected to be basetypes.StringValue, was: %T`, deviceIdAttribute))
	}

	deviceOwnerAttribute, ok := attributes["device_owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_owner is missing from object`)

		return nil, diags
	}

	deviceOwnerVal, ok := deviceOwnerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_owner expected to be basetypes.StringValue, was: %T`, deviceOwnerAttribute))
	}

	fixedIpsAttribute, ok := attributes["fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ips is missing from object`)

		return nil, diags
	}

	fixedIpsVal, ok := fixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ips expected to be basetypes.ListValue, was: %T`, fixedIpsAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return nil, diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return nil, diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return nil, diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortsValue{
		AllowedAddressPairs: allowedAddressPairsVal,
		DeviceId:            deviceIdVal,
		DeviceOwner:         deviceOwnerVal,
		FixedIps:            fixedIpsVal,
		MacAddress:          macAddressVal,
		SecurityGroups:      securityGroupsVal,
		Subnet:              subnetVal,
		SubnetCidr:          subnetCidrVal,
		SubnetDescription:   subnetDescriptionVal,
		SubnetName:          subnetNameVal,
		SubnetUuid:          subnetUuidVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPortsValueNull() PortsValue {
	return PortsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortsValueUnknown() PortsValue {
	return PortsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortsValue Attribute Value",
				"While creating a PortsValue value, a missing attribute value was detected. "+
					"A PortsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortsValue Attribute Type",
				"While creating a PortsValue value, an invalid attribute value was detected. "+
					"A PortsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortsValue Attribute Value",
				"While creating a PortsValue value, an extra attribute value was detected. "+
					"A PortsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	allowedAddressPairsAttribute, ok := attributes["allowed_address_pairs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_address_pairs is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	allowedAddressPairsVal, ok := allowedAddressPairsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_address_pairs expected to be basetypes.ListValue, was: %T`, allowedAddressPairsAttribute))
	}

	deviceIdAttribute, ok := attributes["device_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_id is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	deviceIdVal, ok := deviceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_id expected to be basetypes.StringValue, was: %T`, deviceIdAttribute))
	}

	deviceOwnerAttribute, ok := attributes["device_owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_owner is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	deviceOwnerVal, ok := deviceOwnerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_owner expected to be basetypes.StringValue, was: %T`, deviceOwnerAttribute))
	}

	fixedIpsAttribute, ok := attributes["fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ips is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	fixedIpsVal, ok := fixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ips expected to be basetypes.ListValue, was: %T`, fixedIpsAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	return PortsValue{
		AllowedAddressPairs: allowedAddressPairsVal,
		DeviceId:            deviceIdVal,
		DeviceOwner:         deviceOwnerVal,
		FixedIps:            fixedIpsVal,
		MacAddress:          macAddressVal,
		SecurityGroups:      securityGroupsVal,
		Subnet:              subnetVal,
		SubnetCidr:          subnetCidrVal,
		SubnetDescription:   subnetDescriptionVal,
		SubnetName:          subnetNameVal,
		SubnetUuid:          subnetUuidVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPortsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortsValue {
	object, diags := NewPortsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortsValueMust(PortsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortsType) ValueType(ctx context.Context) attr.Value {
	return PortsValue{}
}

var _ basetypes.ObjectValuable = PortsValue{}

type PortsValue struct {
	AllowedAddressPairs basetypes.ListValue   `tfsdk:"allowed_address_pairs"`
	DeviceId            basetypes.StringValue `tfsdk:"device_id"`
	DeviceOwner         basetypes.StringValue `tfsdk:"device_owner"`
	FixedIps            basetypes.ListValue   `tfsdk:"fixed_ips"`
	MacAddress          basetypes.StringValue `tfsdk:"mac_address"`
	SecurityGroups      basetypes.ListValue   `tfsdk:"security_groups"`
	Subnet              basetypes.StringValue `tfsdk:"subnet"`
	SubnetCidr          basetypes.StringValue `tfsdk:"subnet_cidr"`
	SubnetDescription   basetypes.StringValue `tfsdk:"subnet_description"`
	SubnetName          basetypes.StringValue `tfsdk:"subnet_name"`
	SubnetUuid          basetypes.StringValue `tfsdk:"subnet_uuid"`
	Url                 basetypes.StringValue `tfsdk:"url"`
	state               attr.ValueState
}

func (v PortsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["allowed_address_pairs"] = basetypes.ListType{
		ElemType: AllowedAddressPairsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["device_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["device_owner"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_ips"] = basetypes.ListType{
		ElemType: FixedIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AllowedAddressPairs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_address_pairs"] = val

		val, err = v.DeviceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_id"] = val

		val, err = v.DeviceOwner.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_owner"] = val

		val, err = v.FixedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_ips"] = val

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.SubnetDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_description"] = val

		val, err = v.SubnetName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_name"] = val

		val, err = v.SubnetUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortsValue) String() string {
	return "PortsValue"
}

func (v PortsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	allowedAddressPairs := types.ListValueMust(
		AllowedAddressPairsType{
			basetypes.ObjectType{
				AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
			},
		},
		v.AllowedAddressPairs.Elements(),
	)

	if v.AllowedAddressPairs.IsNull() {
		allowedAddressPairs = types.ListNull(
			AllowedAddressPairsType{
				basetypes.ObjectType{
					AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AllowedAddressPairs.IsUnknown() {
		allowedAddressPairs = types.ListUnknown(
			AllowedAddressPairsType{
				basetypes.ObjectType{
					AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	fixedIps := types.ListValueMust(
		FixedIpsType{
			basetypes.ObjectType{
				AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.FixedIps.Elements(),
	)

	if v.FixedIps.IsNull() {
		fixedIps = types.ListNull(
			FixedIpsType{
				basetypes.ObjectType{
					AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FixedIps.IsUnknown() {
		fixedIps = types.ListUnknown(
			FixedIpsType{
				basetypes.ObjectType{
					AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroups := types.ListValueMust(
		SecurityGroupsType{
			basetypes.ObjectType{
				AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups.Elements(),
	)

	if v.SecurityGroups.IsNull() {
		securityGroups = types.ListNull(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups.IsUnknown() {
		securityGroups = types.ListUnknown(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"allowed_address_pairs": basetypes.ListType{
			ElemType: AllowedAddressPairsValue{}.Type(ctx),
		},
		"device_id":    basetypes.StringType{},
		"device_owner": basetypes.StringType{},
		"fixed_ips": basetypes.ListType{
			ElemType: FixedIpsValue{}.Type(ctx),
		},
		"mac_address": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_address_pairs": allowedAddressPairs,
			"device_id":             v.DeviceId,
			"device_owner":          v.DeviceOwner,
			"fixed_ips":             fixedIps,
			"mac_address":           v.MacAddress,
			"security_groups":       securityGroups,
			"subnet":                v.Subnet,
			"subnet_cidr":           v.SubnetCidr,
			"subnet_description":    v.SubnetDescription,
			"subnet_name":           v.SubnetName,
			"subnet_uuid":           v.SubnetUuid,
			"url":                   v.Url,
		})

	return objVal, diags
}

func (v PortsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedAddressPairs.Equal(other.AllowedAddressPairs) {
		return false
	}

	if !v.DeviceId.Equal(other.DeviceId) {
		return false
	}

	if !v.DeviceOwner.Equal(other.DeviceOwner) {
		return false
	}

	if !v.FixedIps.Equal(other.FixedIps) {
		return false
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.SubnetDescription.Equal(other.SubnetDescription) {
		return false
	}

	if !v.SubnetName.Equal(other.SubnetName) {
		return false
	}

	if !v.SubnetUuid.Equal(other.SubnetUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PortsValue) Type(ctx context.Context) attr.Type {
	return PortsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_address_pairs": basetypes.ListType{
			ElemType: AllowedAddressPairsValue{}.Type(ctx),
		},
		"device_id":    basetypes.StringType{},
		"device_owner": basetypes.StringType{},
		"fixed_ips": basetypes.ListType{
			ElemType: FixedIpsValue{}.Type(ctx),
		},
		"mac_address": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AllowedAddressPairsType{}

type AllowedAddressPairsType struct {
	basetypes.ObjectType
}

func (t AllowedAddressPairsType) Equal(o attr.Type) bool {
	other, ok := o.(AllowedAddressPairsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AllowedAddressPairsType) String() string {
	return "AllowedAddressPairsType"
}

func (t AllowedAddressPairsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AllowedAddressPairsValue{
		MacAddress: macAddressVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAllowedAddressPairsValueNull() AllowedAddressPairsValue {
	return AllowedAddressPairsValue{
		state: attr.ValueStateNull,
	}
}

func NewAllowedAddressPairsValueUnknown() AllowedAddressPairsValue {
	return AllowedAddressPairsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAllowedAddressPairsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AllowedAddressPairsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AllowedAddressPairsValue Attribute Value",
				"While creating a AllowedAddressPairsValue value, a missing attribute value was detected. "+
					"A AllowedAddressPairsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AllowedAddressPairsValue Attribute Type",
				"While creating a AllowedAddressPairsValue value, an invalid attribute value was detected. "+
					"A AllowedAddressPairsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AllowedAddressPairsValue Attribute Value",
				"While creating a AllowedAddressPairsValue value, an extra attribute value was detected. "+
					"A AllowedAddressPairsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AllowedAddressPairsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAllowedAddressPairsValueUnknown(), diags
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewAllowedAddressPairsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	if diags.HasError() {
		return NewAllowedAddressPairsValueUnknown(), diags
	}

	return AllowedAddressPairsValue{
		MacAddress: macAddressVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAllowedAddressPairsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AllowedAddressPairsValue {
	object, diags := NewAllowedAddressPairsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAllowedAddressPairsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AllowedAddressPairsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAllowedAddressPairsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAllowedAddressPairsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAllowedAddressPairsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAllowedAddressPairsValueMust(AllowedAddressPairsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AllowedAddressPairsType) ValueType(ctx context.Context) attr.Value {
	return AllowedAddressPairsValue{}
}

var _ basetypes.ObjectValuable = AllowedAddressPairsValue{}

type AllowedAddressPairsValue struct {
	MacAddress basetypes.StringValue `tfsdk:"mac_address"`
	state      attr.ValueState
}

func (v AllowedAddressPairsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AllowedAddressPairsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AllowedAddressPairsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AllowedAddressPairsValue) String() string {
	return "AllowedAddressPairsValue"
}

func (v AllowedAddressPairsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mac_address": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mac_address": v.MacAddress,
		})

	return objVal, diags
}

func (v AllowedAddressPairsValue) Equal(o attr.Value) bool {
	other, ok := o.(AllowedAddressPairsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	return true
}

func (v AllowedAddressPairsValue) Type(ctx context.Context) attr.Type {
	return AllowedAddressPairsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AllowedAddressPairsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mac_address": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FixedIpsType{}

type FixedIpsType struct {
	basetypes.ObjectType
}

func (t FixedIpsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedIpsType) String() string {
	return "FixedIpsType"
}

func (t FixedIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueNull() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedIpsValueUnknown() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, a missing attribute value was detected. "+
					"A FixedIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedIpsValue Attribute Type",
				"While creating a FixedIpsValue value, an invalid attribute value was detected. "+
					"A FixedIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, an extra attribute value was detected. "+
					"A FixedIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedIpsValue {
	object, diags := NewFixedIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedIpsValueMust(FixedIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedIpsType) ValueType(ctx context.Context) attr.Value {
	return FixedIpsValue{}
}

var _ basetypes.ObjectValuable = FixedIpsValue{}

type FixedIpsValue struct {
	IpAddress basetypes.StringValue `tfsdk:"ip_address"`
	SubnetId  basetypes.StringValue `tfsdk:"subnet_id"`
	state     attr.ValueState
}

func (v FixedIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedIpsValue) String() string {
	return "FixedIpsValue"
}

func (v FixedIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address": v.IpAddress,
			"subnet_id":  v.SubnetId,
		})

	return objVal, diags
}

func (v FixedIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v FixedIpsValue) Type(ctx context.Context) attr.Type {
	return FixedIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroupsType{}

type SecurityGroupsType struct {
	basetypes.ObjectType
}

func (t SecurityGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroupsType) String() string {
	return "SecurityGroupsType"
}

func (t SecurityGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return nil, diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return nil, diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return nil, diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerAbbreviationAttribute, ok := attributes["customer_abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_abbreviation is missing from object`)

		return nil, diags
	}

	customerAbbreviationVal, ok := customerAbbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_abbreviation expected to be basetypes.StringValue, was: %T`, customerAbbreviationAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return nil, diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerNativeNameAttribute, ok := attributes["customer_native_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_native_name is missing from object`)

		return nil, diags
	}

	customerNativeNameVal, ok := customerNativeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_native_name expected to be basetypes.StringValue, was: %T`, customerNativeNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return nil, diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	errorTracebackAttribute, ok := attributes["error_traceback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_traceback is missing from object`)

		return nil, diags
	}

	errorTracebackVal, ok := errorTracebackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_traceback expected to be basetypes.StringValue, was: %T`, errorTracebackAttribute))
	}

	isLimitBasedAttribute, ok := attributes["is_limit_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_limit_based is missing from object`)

		return nil, diags
	}

	isLimitBasedVal, ok := isLimitBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_limit_based expected to be basetypes.BoolValue, was: %T`, isLimitBasedAttribute))
	}

	isUsageBasedAttribute, ok := attributes["is_usage_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_usage_based is missing from object`)

		return nil, diags
	}

	isUsageBasedVal, ok := isUsageBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_usage_based expected to be basetypes.BoolValue, was: %T`, isUsageBasedAttribute))
	}

	marketplaceCategoryNameAttribute, ok := attributes["marketplace_category_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_name is missing from object`)

		return nil, diags
	}

	marketplaceCategoryNameVal, ok := marketplaceCategoryNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_name expected to be basetypes.StringValue, was: %T`, marketplaceCategoryNameAttribute))
	}

	marketplaceCategoryUuidAttribute, ok := attributes["marketplace_category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_uuid is missing from object`)

		return nil, diags
	}

	marketplaceCategoryUuidVal, ok := marketplaceCategoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_uuid expected to be basetypes.StringValue, was: %T`, marketplaceCategoryUuidAttribute))
	}

	marketplaceOfferingNameAttribute, ok := attributes["marketplace_offering_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_name is missing from object`)

		return nil, diags
	}

	marketplaceOfferingNameVal, ok := marketplaceOfferingNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_name expected to be basetypes.StringValue, was: %T`, marketplaceOfferingNameAttribute))
	}

	marketplaceOfferingUuidAttribute, ok := attributes["marketplace_offering_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_uuid is missing from object`)

		return nil, diags
	}

	marketplaceOfferingUuidVal, ok := marketplaceOfferingUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_uuid expected to be basetypes.StringValue, was: %T`, marketplaceOfferingUuidAttribute))
	}

	marketplacePlanUuidAttribute, ok := attributes["marketplace_plan_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_plan_uuid is missing from object`)

		return nil, diags
	}

	marketplacePlanUuidVal, ok := marketplacePlanUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_plan_uuid expected to be basetypes.StringValue, was: %T`, marketplacePlanUuidAttribute))
	}

	marketplaceResourceStateAttribute, ok := attributes["marketplace_resource_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_state is missing from object`)

		return nil, diags
	}

	marketplaceResourceStateVal, ok := marketplaceResourceStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_state expected to be basetypes.StringValue, was: %T`, marketplaceResourceStateAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return nil, diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	modifiedAttribute, ok := attributes["modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified is missing from object`)

		return nil, diags
	}

	modifiedVal, ok := modifiedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified expected to be basetypes.StringValue, was: %T`, modifiedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return nil, diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return nil, diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return nil, diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serviceNameAttribute, ok := attributes["service_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_name is missing from object`)

		return nil, diags
	}

	serviceNameVal, ok := serviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_name expected to be basetypes.StringValue, was: %T`, serviceNameAttribute))
	}

	serviceSettingsAttribute, ok := attributes["service_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings is missing from object`)

		return nil, diags
	}

	serviceSettingsVal, ok := serviceSettingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings expected to be basetypes.StringValue, was: %T`, serviceSettingsAttribute))
	}

	serviceSettingsErrorMessageAttribute, ok := attributes["service_settings_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_error_message is missing from object`)

		return nil, diags
	}

	serviceSettingsErrorMessageVal, ok := serviceSettingsErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_error_message expected to be basetypes.StringValue, was: %T`, serviceSettingsErrorMessageAttribute))
	}

	serviceSettingsStateAttribute, ok := attributes["service_settings_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_state is missing from object`)

		return nil, diags
	}

	serviceSettingsStateVal, ok := serviceSettingsStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_state expected to be basetypes.StringValue, was: %T`, serviceSettingsStateAttribute))
	}

	serviceSettingsUuidAttribute, ok := attributes["service_settings_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_uuid is missing from object`)

		return nil, diags
	}

	serviceSettingsUuidVal, ok := serviceSettingsUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_uuid expected to be basetypes.StringValue, was: %T`, serviceSettingsUuidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	tenantNameAttribute, ok := attributes["tenant_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_name is missing from object`)

		return nil, diags
	}

	tenantNameVal, ok := tenantNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_name expected to be basetypes.StringValue, was: %T`, tenantNameAttribute))
	}

	tenantUuidAttribute, ok := attributes["tenant_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_uuid is missing from object`)

		return nil, diags
	}

	tenantUuidVal, ok := tenantUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_uuid expected to be basetypes.StringValue, was: %T`, tenantUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroupsValue{
		AccessUrl:                   accessUrlVal,
		BackendId:                   backendIdVal,
		Created:                     createdVal,
		Customer:                    customerVal,
		CustomerAbbreviation:        customerAbbreviationVal,
		CustomerName:                customerNameVal,
		CustomerNativeName:          customerNativeNameVal,
		Description:                 descriptionVal,
		ErrorMessage:                errorMessageVal,
		ErrorTraceback:              errorTracebackVal,
		IsLimitBased:                isLimitBasedVal,
		IsUsageBased:                isUsageBasedVal,
		MarketplaceCategoryName:     marketplaceCategoryNameVal,
		MarketplaceCategoryUuid:     marketplaceCategoryUuidVal,
		MarketplaceOfferingName:     marketplaceOfferingNameVal,
		MarketplaceOfferingUuid:     marketplaceOfferingUuidVal,
		MarketplacePlanUuid:         marketplacePlanUuidVal,
		MarketplaceResourceState:    marketplaceResourceStateVal,
		MarketplaceResourceUuid:     marketplaceResourceUuidVal,
		Modified:                    modifiedVal,
		Name:                        nameVal,
		Project:                     projectVal,
		ProjectName:                 projectNameVal,
		ProjectUuid:                 projectUuidVal,
		ResourceType:                resourceTypeVal,
		Rules:                       rulesVal,
		ServiceName:                 serviceNameVal,
		ServiceSettings:             serviceSettingsVal,
		ServiceSettingsErrorMessage: serviceSettingsErrorMessageVal,
		ServiceSettingsState:        serviceSettingsStateVal,
		ServiceSettingsUuid:         serviceSettingsUuidVal,
		State:                       stateVal,
		Tenant:                      tenantVal,
		TenantName:                  tenantNameVal,
		TenantUuid:                  tenantUuidVal,
		Url:                         urlVal,
		Uuid:                        uuidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueNull() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroupsValueUnknown() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, a missing attribute value was detected. "+
					"A SecurityGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroupsValue Attribute Type",
				"While creating a SecurityGroupsValue value, an invalid attribute value was detected. "+
					"A SecurityGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, an extra attribute value was detected. "+
					"A SecurityGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerAbbreviationAttribute, ok := attributes["customer_abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_abbreviation is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerAbbreviationVal, ok := customerAbbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_abbreviation expected to be basetypes.StringValue, was: %T`, customerAbbreviationAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerNativeNameAttribute, ok := attributes["customer_native_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_native_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerNativeNameVal, ok := customerNativeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_native_name expected to be basetypes.StringValue, was: %T`, customerNativeNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	errorTracebackAttribute, ok := attributes["error_traceback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_traceback is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	errorTracebackVal, ok := errorTracebackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_traceback expected to be basetypes.StringValue, was: %T`, errorTracebackAttribute))
	}

	isLimitBasedAttribute, ok := attributes["is_limit_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_limit_based is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	isLimitBasedVal, ok := isLimitBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_limit_based expected to be basetypes.BoolValue, was: %T`, isLimitBasedAttribute))
	}

	isUsageBasedAttribute, ok := attributes["is_usage_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_usage_based is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	isUsageBasedVal, ok := isUsageBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_usage_based expected to be basetypes.BoolValue, was: %T`, isUsageBasedAttribute))
	}

	marketplaceCategoryNameAttribute, ok := attributes["marketplace_category_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceCategoryNameVal, ok := marketplaceCategoryNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_name expected to be basetypes.StringValue, was: %T`, marketplaceCategoryNameAttribute))
	}

	marketplaceCategoryUuidAttribute, ok := attributes["marketplace_category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceCategoryUuidVal, ok := marketplaceCategoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_uuid expected to be basetypes.StringValue, was: %T`, marketplaceCategoryUuidAttribute))
	}

	marketplaceOfferingNameAttribute, ok := attributes["marketplace_offering_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceOfferingNameVal, ok := marketplaceOfferingNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_name expected to be basetypes.StringValue, was: %T`, marketplaceOfferingNameAttribute))
	}

	marketplaceOfferingUuidAttribute, ok := attributes["marketplace_offering_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceOfferingUuidVal, ok := marketplaceOfferingUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_uuid expected to be basetypes.StringValue, was: %T`, marketplaceOfferingUuidAttribute))
	}

	marketplacePlanUuidAttribute, ok := attributes["marketplace_plan_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_plan_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplacePlanUuidVal, ok := marketplacePlanUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_plan_uuid expected to be basetypes.StringValue, was: %T`, marketplacePlanUuidAttribute))
	}

	marketplaceResourceStateAttribute, ok := attributes["marketplace_resource_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceResourceStateVal, ok := marketplaceResourceStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_state expected to be basetypes.StringValue, was: %T`, marketplaceResourceStateAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	modifiedAttribute, ok := attributes["modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	modifiedVal, ok := modifiedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified expected to be basetypes.StringValue, was: %T`, modifiedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serviceNameAttribute, ok := attributes["service_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceNameVal, ok := serviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_name expected to be basetypes.StringValue, was: %T`, serviceNameAttribute))
	}

	serviceSettingsAttribute, ok := attributes["service_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsVal, ok := serviceSettingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings expected to be basetypes.StringValue, was: %T`, serviceSettingsAttribute))
	}

	serviceSettingsErrorMessageAttribute, ok := attributes["service_settings_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_error_message is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsErrorMessageVal, ok := serviceSettingsErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_error_message expected to be basetypes.StringValue, was: %T`, serviceSettingsErrorMessageAttribute))
	}

	serviceSettingsStateAttribute, ok := attributes["service_settings_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsStateVal, ok := serviceSettingsStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_state expected to be basetypes.StringValue, was: %T`, serviceSettingsStateAttribute))
	}

	serviceSettingsUuidAttribute, ok := attributes["service_settings_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsUuidVal, ok := serviceSettingsUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_uuid expected to be basetypes.StringValue, was: %T`, serviceSettingsUuidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	tenantNameAttribute, ok := attributes["tenant_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantNameVal, ok := tenantNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_name expected to be basetypes.StringValue, was: %T`, tenantNameAttribute))
	}

	tenantUuidAttribute, ok := attributes["tenant_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantUuidVal, ok := tenantUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_uuid expected to be basetypes.StringValue, was: %T`, tenantUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	return SecurityGroupsValue{
		AccessUrl:                   accessUrlVal,
		BackendId:                   backendIdVal,
		Created:                     createdVal,
		Customer:                    customerVal,
		CustomerAbbreviation:        customerAbbreviationVal,
		CustomerName:                customerNameVal,
		CustomerNativeName:          customerNativeNameVal,
		Description:                 descriptionVal,
		ErrorMessage:                errorMessageVal,
		ErrorTraceback:              errorTracebackVal,
		IsLimitBased:                isLimitBasedVal,
		IsUsageBased:                isUsageBasedVal,
		MarketplaceCategoryName:     marketplaceCategoryNameVal,
		MarketplaceCategoryUuid:     marketplaceCategoryUuidVal,
		MarketplaceOfferingName:     marketplaceOfferingNameVal,
		MarketplaceOfferingUuid:     marketplaceOfferingUuidVal,
		MarketplacePlanUuid:         marketplacePlanUuidVal,
		MarketplaceResourceState:    marketplaceResourceStateVal,
		MarketplaceResourceUuid:     marketplaceResourceUuidVal,
		Modified:                    modifiedVal,
		Name:                        nameVal,
		Project:                     projectVal,
		ProjectName:                 projectNameVal,
		ProjectUuid:                 projectUuidVal,
		ResourceType:                resourceTypeVal,
		Rules:                       rulesVal,
		ServiceName:                 serviceNameVal,
		ServiceSettings:             serviceSettingsVal,
		ServiceSettingsErrorMessage: serviceSettingsErrorMessageVal,
		ServiceSettingsState:        serviceSettingsStateVal,
		ServiceSettingsUuid:         serviceSettingsUuidVal,
		State:                       stateVal,
		Tenant:                      tenantVal,
		TenantName:                  tenantNameVal,
		TenantUuid:                  tenantUuidVal,
		Url:                         urlVal,
		Uuid:                        uuidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroupsValue {
	object, diags := NewSecurityGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroupsValueMust(SecurityGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroupsType) ValueType(ctx context.Context) attr.Value {
	return SecurityGroupsValue{}
}

var _ basetypes.ObjectValuable = SecurityGroupsValue{}

type SecurityGroupsValue struct {
	AccessUrl                   basetypes.StringValue `tfsdk:"access_url"`
	BackendId                   basetypes.StringValue `tfsdk:"backend_id"`
	Created                     basetypes.StringValue `tfsdk:"created"`
	Customer                    basetypes.StringValue `tfsdk:"customer"`
	CustomerAbbreviation        basetypes.StringValue `tfsdk:"customer_abbreviation"`
	CustomerName                basetypes.StringValue `tfsdk:"customer_name"`
	CustomerNativeName          basetypes.StringValue `tfsdk:"customer_native_name"`
	Description                 basetypes.StringValue `tfsdk:"description"`
	ErrorMessage                basetypes.StringValue `tfsdk:"error_message"`
	ErrorTraceback              basetypes.StringValue `tfsdk:"error_traceback"`
	IsLimitBased                basetypes.BoolValue   `tfsdk:"is_limit_based"`
	IsUsageBased                basetypes.BoolValue   `tfsdk:"is_usage_based"`
	MarketplaceCategoryName     basetypes.StringValue `tfsdk:"marketplace_category_name"`
	MarketplaceCategoryUuid     basetypes.StringValue `tfsdk:"marketplace_category_uuid"`
	MarketplaceOfferingName     basetypes.StringValue `tfsdk:"marketplace_offering_name"`
	MarketplaceOfferingUuid     basetypes.StringValue `tfsdk:"marketplace_offering_uuid"`
	MarketplacePlanUuid         basetypes.StringValue `tfsdk:"marketplace_plan_uuid"`
	MarketplaceResourceState    basetypes.StringValue `tfsdk:"marketplace_resource_state"`
	MarketplaceResourceUuid     basetypes.StringValue `tfsdk:"marketplace_resource_uuid"`
	Modified                    basetypes.StringValue `tfsdk:"modified"`
	Name                        basetypes.StringValue `tfsdk:"name"`
	Project                     basetypes.StringValue `tfsdk:"project"`
	ProjectName                 basetypes.StringValue `tfsdk:"project_name"`
	ProjectUuid                 basetypes.StringValue `tfsdk:"project_uuid"`
	ResourceType                basetypes.StringValue `tfsdk:"resource_type"`
	Rules                       basetypes.ListValue   `tfsdk:"rules"`
	ServiceName                 basetypes.StringValue `tfsdk:"service_name"`
	ServiceSettings             basetypes.StringValue `tfsdk:"service_settings"`
	ServiceSettingsErrorMessage basetypes.StringValue `tfsdk:"service_settings_error_message"`
	ServiceSettingsState        basetypes.StringValue `tfsdk:"service_settings_state"`
	ServiceSettingsUuid         basetypes.StringValue `tfsdk:"service_settings_uuid"`
	State                       basetypes.StringValue `tfsdk:"state"`
	Tenant                      basetypes.StringValue `tfsdk:"tenant"`
	TenantName                  basetypes.StringValue `tfsdk:"tenant_name"`
	TenantUuid                  basetypes.StringValue `tfsdk:"tenant_uuid"`
	Url                         basetypes.StringValue `tfsdk:"url"`
	Uuid                        basetypes.StringValue `tfsdk:"uuid"`
	state                       attr.ValueState
}

func (v SecurityGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 37)

	var val tftypes.Value
	var err error

	attrTypes["access_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backend_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_abbreviation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_native_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["error_traceback"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_limit_based"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_usage_based"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["marketplace_category_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_category_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_offering_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_offering_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_plan_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: RulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 37)

		val, err = v.AccessUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_url"] = val

		val, err = v.BackendId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_id"] = val

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Customer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer"] = val

		val, err = v.CustomerAbbreviation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_abbreviation"] = val

		val, err = v.CustomerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_name"] = val

		val, err = v.CustomerNativeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_native_name"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.ErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_message"] = val

		val, err = v.ErrorTraceback.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_traceback"] = val

		val, err = v.IsLimitBased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_limit_based"] = val

		val, err = v.IsUsageBased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_usage_based"] = val

		val, err = v.MarketplaceCategoryName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_category_name"] = val

		val, err = v.MarketplaceCategoryUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_category_uuid"] = val

		val, err = v.MarketplaceOfferingName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_offering_name"] = val

		val, err = v.MarketplaceOfferingUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_offering_uuid"] = val

		val, err = v.MarketplacePlanUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_plan_uuid"] = val

		val, err = v.MarketplaceResourceState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_state"] = val

		val, err = v.MarketplaceResourceUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_uuid"] = val

		val, err = v.Modified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		val, err = v.ProjectName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_name"] = val

		val, err = v.ProjectUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_uuid"] = val

		val, err = v.ResourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_type"] = val

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		val, err = v.ServiceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_name"] = val

		val, err = v.ServiceSettings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings"] = val

		val, err = v.ServiceSettingsErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_error_message"] = val

		val, err = v.ServiceSettingsState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_state"] = val

		val, err = v.ServiceSettingsUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_uuid"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.TenantName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_name"] = val

		val, err = v.TenantUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroupsValue) String() string {
	return "SecurityGroupsValue"
}

func (v SecurityGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	rules := types.ListValueMust(
		RulesType{
			basetypes.ObjectType{
				AttrTypes: RulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Rules.Elements(),
	)

	if v.Rules.IsNull() {
		rules = types.ListNull(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rules.IsUnknown() {
		rules = types.ListUnknown(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"access_url":                 basetypes.StringType{},
		"backend_id":                 basetypes.StringType{},
		"created":                    basetypes.StringType{},
		"customer":                   basetypes.StringType{},
		"customer_abbreviation":      basetypes.StringType{},
		"customer_name":              basetypes.StringType{},
		"customer_native_name":       basetypes.StringType{},
		"description":                basetypes.StringType{},
		"error_message":              basetypes.StringType{},
		"error_traceback":            basetypes.StringType{},
		"is_limit_based":             basetypes.BoolType{},
		"is_usage_based":             basetypes.BoolType{},
		"marketplace_category_name":  basetypes.StringType{},
		"marketplace_category_uuid":  basetypes.StringType{},
		"marketplace_offering_name":  basetypes.StringType{},
		"marketplace_offering_uuid":  basetypes.StringType{},
		"marketplace_plan_uuid":      basetypes.StringType{},
		"marketplace_resource_state": basetypes.StringType{},
		"marketplace_resource_uuid":  basetypes.StringType{},
		"modified":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"project":                    basetypes.StringType{},
		"project_name":               basetypes.StringType{},
		"project_uuid":               basetypes.StringType{},
		"resource_type":              basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"service_name":                   basetypes.StringType{},
		"service_settings":               basetypes.StringType{},
		"service_settings_error_message": basetypes.StringType{},
		"service_settings_state":         basetypes.StringType{},
		"service_settings_uuid":          basetypes.StringType{},
		"state":                          basetypes.StringType{},
		"tenant":                         basetypes.StringType{},
		"tenant_name":                    basetypes.StringType{},
		"tenant_uuid":                    basetypes.StringType{},
		"url":                            basetypes.StringType{},
		"uuid":                           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_url":                     v.AccessUrl,
			"backend_id":                     v.BackendId,
			"created":                        v.Created,
			"customer":                       v.Customer,
			"customer_abbreviation":          v.CustomerAbbreviation,
			"customer_name":                  v.CustomerName,
			"customer_native_name":           v.CustomerNativeName,
			"description":                    v.Description,
			"error_message":                  v.ErrorMessage,
			"error_traceback":                v.ErrorTraceback,
			"is_limit_based":                 v.IsLimitBased,
			"is_usage_based":                 v.IsUsageBased,
			"marketplace_category_name":      v.MarketplaceCategoryName,
			"marketplace_category_uuid":      v.MarketplaceCategoryUuid,
			"marketplace_offering_name":      v.MarketplaceOfferingName,
			"marketplace_offering_uuid":      v.MarketplaceOfferingUuid,
			"marketplace_plan_uuid":          v.MarketplacePlanUuid,
			"marketplace_resource_state":     v.MarketplaceResourceState,
			"marketplace_resource_uuid":      v.MarketplaceResourceUuid,
			"modified":                       v.Modified,
			"name":                           v.Name,
			"project":                        v.Project,
			"project_name":                   v.ProjectName,
			"project_uuid":                   v.ProjectUuid,
			"resource_type":                  v.ResourceType,
			"rules":                          rules,
			"service_name":                   v.ServiceName,
			"service_settings":               v.ServiceSettings,
			"service_settings_error_message": v.ServiceSettingsErrorMessage,
			"service_settings_state":         v.ServiceSettingsState,
			"service_settings_uuid":          v.ServiceSettingsUuid,
			"state":                          v.State,
			"tenant":                         v.Tenant,
			"tenant_name":                    v.TenantName,
			"tenant_uuid":                    v.TenantUuid,
			"url":                            v.Url,
			"uuid":                           v.Uuid,
		})

	return objVal, diags
}

func (v SecurityGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessUrl.Equal(other.AccessUrl) {
		return false
	}

	if !v.BackendId.Equal(other.BackendId) {
		return false
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Customer.Equal(other.Customer) {
		return false
	}

	if !v.CustomerAbbreviation.Equal(other.CustomerAbbreviation) {
		return false
	}

	if !v.CustomerName.Equal(other.CustomerName) {
		return false
	}

	if !v.CustomerNativeName.Equal(other.CustomerNativeName) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.ErrorMessage.Equal(other.ErrorMessage) {
		return false
	}

	if !v.ErrorTraceback.Equal(other.ErrorTraceback) {
		return false
	}

	if !v.IsLimitBased.Equal(other.IsLimitBased) {
		return false
	}

	if !v.IsUsageBased.Equal(other.IsUsageBased) {
		return false
	}

	if !v.MarketplaceCategoryName.Equal(other.MarketplaceCategoryName) {
		return false
	}

	if !v.MarketplaceCategoryUuid.Equal(other.MarketplaceCategoryUuid) {
		return false
	}

	if !v.MarketplaceOfferingName.Equal(other.MarketplaceOfferingName) {
		return false
	}

	if !v.MarketplaceOfferingUuid.Equal(other.MarketplaceOfferingUuid) {
		return false
	}

	if !v.MarketplacePlanUuid.Equal(other.MarketplacePlanUuid) {
		return false
	}

	if !v.MarketplaceResourceState.Equal(other.MarketplaceResourceState) {
		return false
	}

	if !v.MarketplaceResourceUuid.Equal(other.MarketplaceResourceUuid) {
		return false
	}

	if !v.Modified.Equal(other.Modified) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	if !v.ProjectName.Equal(other.ProjectName) {
		return false
	}

	if !v.ProjectUuid.Equal(other.ProjectUuid) {
		return false
	}

	if !v.ResourceType.Equal(other.ResourceType) {
		return false
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	if !v.ServiceName.Equal(other.ServiceName) {
		return false
	}

	if !v.ServiceSettings.Equal(other.ServiceSettings) {
		return false
	}

	if !v.ServiceSettingsErrorMessage.Equal(other.ServiceSettingsErrorMessage) {
		return false
	}

	if !v.ServiceSettingsState.Equal(other.ServiceSettingsState) {
		return false
	}

	if !v.ServiceSettingsUuid.Equal(other.ServiceSettingsUuid) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.TenantName.Equal(other.TenantName) {
		return false
	}

	if !v.TenantUuid.Equal(other.TenantUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v SecurityGroupsValue) Type(ctx context.Context) attr.Type {
	return SecurityGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_url":                 basetypes.StringType{},
		"backend_id":                 basetypes.StringType{},
		"created":                    basetypes.StringType{},
		"customer":                   basetypes.StringType{},
		"customer_abbreviation":      basetypes.StringType{},
		"customer_name":              basetypes.StringType{},
		"customer_native_name":       basetypes.StringType{},
		"description":                basetypes.StringType{},
		"error_message":              basetypes.StringType{},
		"error_traceback":            basetypes.StringType{},
		"is_limit_based":             basetypes.BoolType{},
		"is_usage_based":             basetypes.BoolType{},
		"marketplace_category_name":  basetypes.StringType{},
		"marketplace_category_uuid":  basetypes.StringType{},
		"marketplace_offering_name":  basetypes.StringType{},
		"marketplace_offering_uuid":  basetypes.StringType{},
		"marketplace_plan_uuid":      basetypes.StringType{},
		"marketplace_resource_state": basetypes.StringType{},
		"marketplace_resource_uuid":  basetypes.StringType{},
		"modified":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"project":                    basetypes.StringType{},
		"project_name":               basetypes.StringType{},
		"project_uuid":               basetypes.StringType{},
		"resource_type":              basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"service_name":                   basetypes.StringType{},
		"service_settings":               basetypes.StringType{},
		"service_settings_error_message": basetypes.StringType{},
		"service_settings_state":         basetypes.StringType{},
		"service_settings_uuid":          basetypes.StringType{},
		"state":                          basetypes.StringType{},
		"tenant":                         basetypes.StringType{},
		"tenant_name":                    basetypes.StringType{},
		"tenant_uuid":                    basetypes.StringType{},
		"url":                            basetypes.StringType{},
		"uuid":                           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RulesType{}

type RulesType struct {
	basetypes.ObjectType
}

func (t RulesType) Equal(o attr.Type) bool {
	other, ok := o.(RulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RulesType) String() string {
	return "RulesType"
}

func (t RulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return nil, diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	fromPortAttribute, ok := attributes["from_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_port is missing from object`)

		return nil, diags
	}

	fromPortVal, ok := fromPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_port expected to be basetypes.Int64Value, was: %T`, fromPortAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	remoteGroupAttribute, ok := attributes["remote_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group is missing from object`)

		return nil, diags
	}

	remoteGroupVal, ok := remoteGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group expected to be basetypes.StringValue, was: %T`, remoteGroupAttribute))
	}

	remoteGroupNameAttribute, ok := attributes["remote_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_name is missing from object`)

		return nil, diags
	}

	remoteGroupNameVal, ok := remoteGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_name expected to be basetypes.StringValue, was: %T`, remoteGroupNameAttribute))
	}

	remoteGroupUuidAttribute, ok := attributes["remote_group_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_uuid is missing from object`)

		return nil, diags
	}

	remoteGroupUuidVal, ok := remoteGroupUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_uuid expected to be basetypes.StringValue, was: %T`, remoteGroupUuidAttribute))
	}

	toPortAttribute, ok := attributes["to_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_port is missing from object`)

		return nil, diags
	}

	toPortVal, ok := toPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_port expected to be basetypes.Int64Value, was: %T`, toPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RulesValue{
		Cidr:            cidrVal,
		Description:     descriptionVal,
		Direction:       directionVal,
		Ethertype:       ethertypeVal,
		FromPort:        fromPortVal,
		Id:              idVal,
		RemoteGroup:     remoteGroupVal,
		RemoteGroupName: remoteGroupNameVal,
		RemoteGroupUuid: remoteGroupUuidVal,
		ToPort:          toPortVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRulesValueNull() RulesValue {
	return RulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRulesValueUnknown() RulesValue {
	return RulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RulesValue Attribute Value",
				"While creating a RulesValue value, a missing attribute value was detected. "+
					"A RulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RulesValue Attribute Type",
				"While creating a RulesValue value, an invalid attribute value was detected. "+
					"A RulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RulesValue Attribute Value",
				"While creating a RulesValue value, an extra attribute value was detected. "+
					"A RulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	fromPortAttribute, ok := attributes["from_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_port is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	fromPortVal, ok := fromPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_port expected to be basetypes.Int64Value, was: %T`, fromPortAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	remoteGroupAttribute, ok := attributes["remote_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupVal, ok := remoteGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group expected to be basetypes.StringValue, was: %T`, remoteGroupAttribute))
	}

	remoteGroupNameAttribute, ok := attributes["remote_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_name is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupNameVal, ok := remoteGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_name expected to be basetypes.StringValue, was: %T`, remoteGroupNameAttribute))
	}

	remoteGroupUuidAttribute, ok := attributes["remote_group_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_uuid is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupUuidVal, ok := remoteGroupUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_uuid expected to be basetypes.StringValue, was: %T`, remoteGroupUuidAttribute))
	}

	toPortAttribute, ok := attributes["to_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_port is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	toPortVal, ok := toPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_port expected to be basetypes.Int64Value, was: %T`, toPortAttribute))
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	return RulesValue{
		Cidr:            cidrVal,
		Description:     descriptionVal,
		Direction:       directionVal,
		Ethertype:       ethertypeVal,
		FromPort:        fromPortVal,
		Id:              idVal,
		RemoteGroup:     remoteGroupVal,
		RemoteGroupName: remoteGroupNameVal,
		RemoteGroupUuid: remoteGroupUuidVal,
		ToPort:          toPortVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RulesValue {
	object, diags := NewRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRulesValueMust(RulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RulesType) ValueType(ctx context.Context) attr.Value {
	return RulesValue{}
}

var _ basetypes.ObjectValuable = RulesValue{}

type RulesValue struct {
	Cidr            basetypes.StringValue `tfsdk:"cidr"`
	Description     basetypes.StringValue `tfsdk:"description"`
	Direction       basetypes.StringValue `tfsdk:"direction"`
	Ethertype       basetypes.StringValue `tfsdk:"ethertype"`
	FromPort        basetypes.Int64Value  `tfsdk:"from_port"`
	Id              basetypes.Int64Value  `tfsdk:"id"`
	RemoteGroup     basetypes.StringValue `tfsdk:"remote_group"`
	RemoteGroupName basetypes.StringValue `tfsdk:"remote_group_name"`
	RemoteGroupUuid basetypes.StringValue `tfsdk:"remote_group_uuid"`
	ToPort          basetypes.Int64Value  `tfsdk:"to_port"`
	state           attr.ValueState
}

func (v RulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ethertype"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_group_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_group_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Ethertype.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethertype"] = val

		val, err = v.FromPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_port"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.RemoteGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group"] = val

		val, err = v.RemoteGroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group_name"] = val

		val, err = v.RemoteGroupUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group_uuid"] = val

		val, err = v.ToPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RulesValue) String() string {
	return "RulesValue"
}

func (v RulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cidr":              basetypes.StringType{},
		"description":       basetypes.StringType{},
		"direction":         basetypes.StringType{},
		"ethertype":         basetypes.StringType{},
		"from_port":         basetypes.Int64Type{},
		"id":                basetypes.Int64Type{},
		"remote_group":      basetypes.StringType{},
		"remote_group_name": basetypes.StringType{},
		"remote_group_uuid": basetypes.StringType{},
		"to_port":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cidr":              v.Cidr,
			"description":       v.Description,
			"direction":         v.Direction,
			"ethertype":         v.Ethertype,
			"from_port":         v.FromPort,
			"id":                v.Id,
			"remote_group":      v.RemoteGroup,
			"remote_group_name": v.RemoteGroupName,
			"remote_group_uuid": v.RemoteGroupUuid,
			"to_port":           v.ToPort,
		})

	return objVal, diags
}

func (v RulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Ethertype.Equal(other.Ethertype) {
		return false
	}

	if !v.FromPort.Equal(other.FromPort) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.RemoteGroup.Equal(other.RemoteGroup) {
		return false
	}

	if !v.RemoteGroupName.Equal(other.RemoteGroupName) {
		return false
	}

	if !v.RemoteGroupUuid.Equal(other.RemoteGroupUuid) {
		return false
	}

	if !v.ToPort.Equal(other.ToPort) {
		return false
	}

	return true
}

func (v RulesValue) Type(ctx context.Context) attr.Type {
	return RulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":              basetypes.StringType{},
		"description":       basetypes.StringType{},
		"direction":         basetypes.StringType{},
		"ethertype":         basetypes.StringType{},
		"from_port":         basetypes.Int64Type{},
		"id":                basetypes.Int64Type{},
		"remote_group":      basetypes.StringType{},
		"remote_group_name": basetypes.StringType{},
		"remote_group_uuid": basetypes.StringType{},
		"to_port":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RoutesType{}

type RoutesType struct {
	basetypes.ObjectType
}

func (t RoutesType) Equal(o attr.Type) bool {
	other, ok := o.(RoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutesType) String() string {
	return "RoutesType"
}

func (t RoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	destinationAttribute, ok := attributes["destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination is missing from object`)

		return nil, diags
	}

	destinationVal, ok := destinationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination expected to be basetypes.StringValue, was: %T`, destinationAttribute))
	}

	nexthopAttribute, ok := attributes["nexthop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthop is missing from object`)

		return nil, diags
	}

	nexthopVal, ok := nexthopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthop expected to be basetypes.StringValue, was: %T`, nexthopAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutesValue{
		Destination: destinationVal,
		Nexthop:     nexthopVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRoutesValueNull() RoutesValue {
	return RoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutesValueUnknown() RoutesValue {
	return RoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutesValue Attribute Value",
				"While creating a RoutesValue value, a missing attribute value was detected. "+
					"A RoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutesValue Attribute Type",
				"While creating a RoutesValue value, an invalid attribute value was detected. "+
					"A RoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutesValue Attribute Value",
				"While creating a RoutesValue value, an extra attribute value was detected. "+
					"A RoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutesValueUnknown(), diags
	}

	destinationAttribute, ok := attributes["destination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`destination is missing from object`)

		return NewRoutesValueUnknown(), diags
	}

	destinationVal, ok := destinationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`destination expected to be basetypes.StringValue, was: %T`, destinationAttribute))
	}

	nexthopAttribute, ok := attributes["nexthop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthop is missing from object`)

		return NewRoutesValueUnknown(), diags
	}

	nexthopVal, ok := nexthopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthop expected to be basetypes.StringValue, was: %T`, nexthopAttribute))
	}

	if diags.HasError() {
		return NewRoutesValueUnknown(), diags
	}

	return RoutesValue{
		Destination: destinationVal,
		Nexthop:     nexthopVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutesValue {
	object, diags := NewRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutesValueMust(RoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutesType) ValueType(ctx context.Context) attr.Value {
	return RoutesValue{}
}

var _ basetypes.ObjectValuable = RoutesValue{}

type RoutesValue struct {
	Destination basetypes.StringValue `tfsdk:"destination"`
	Nexthop     basetypes.StringValue `tfsdk:"nexthop"`
	state       attr.ValueState
}

func (v RoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["destination"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nexthop"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Destination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["destination"] = val

		val, err = v.Nexthop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nexthop"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutesValue) String() string {
	return "RoutesValue"
}

func (v RoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"destination": basetypes.StringType{},
		"nexthop":     basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"destination": v.Destination,
			"nexthop":     v.Nexthop,
		})

	return objVal, diags
}

func (v RoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Destination.Equal(other.Destination) {
		return false
	}

	if !v.Nexthop.Equal(other.Nexthop) {
		return false
	}

	return true
}

func (v RoutesValue) Type(ctx context.Context) attr.Type {
	return RoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"destination": basetypes.StringType{},
		"nexthop":     basetypes.StringType{},
	}
}
