// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_openstack_backup

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func OpenstackBackupDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"access_url": schema.StringAttribute{
				Computed: true,
			},
			"backend_id": schema.StringAttribute{
				Computed: true,
			},
			"created": schema.StringAttribute{
				Computed: true,
			},
			"customer": schema.StringAttribute{
				Computed: true,
			},
			"customer_abbreviation": schema.StringAttribute{
				Computed: true,
			},
			"customer_name": schema.StringAttribute{
				Computed: true,
			},
			"customer_native_name": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Computed: true,
			},
			"error_message": schema.StringAttribute{
				Computed: true,
			},
			"error_traceback": schema.StringAttribute{
				Computed: true,
			},
			"field": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"instance": schema.StringAttribute{
				Computed: true,
			},
			"instance_floating_ips": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"address": schema.StringAttribute{
							Computed: true,
						},
						"port_fixed_ips": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ip_address": schema.StringAttribute{
										Computed: true,
									},
									"subnet_id": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: PortFixedIpsType{
									ObjectType: types.ObjectType{
										AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"port_mac_address": schema.StringAttribute{
							Computed: true,
						},
						"subnet": schema.StringAttribute{
							Computed: true,
						},
						"subnet_cidr": schema.StringAttribute{
							Computed: true,
						},
						"subnet_description": schema.StringAttribute{
							Computed: true,
						},
						"subnet_name": schema.StringAttribute{
							Computed: true,
						},
						"subnet_uuid": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: InstanceFloatingIpsType{
						ObjectType: types.ObjectType{
							AttrTypes: InstanceFloatingIpsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"instance_marketplace_uuid": schema.StringAttribute{
				Computed: true,
			},
			"instance_name": schema.StringAttribute{
				Computed: true,
			},
			"instance_ports": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"allowed_address_pairs": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"mac_address": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: AllowedAddressPairsType{
									ObjectType: types.ObjectType{
										AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"device_id": schema.StringAttribute{
							Computed: true,
						},
						"device_owner": schema.StringAttribute{
							Computed: true,
						},
						"fixed_ips": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"ip_address": schema.StringAttribute{
										Computed: true,
									},
									"subnet_id": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: FixedIpsType{
									ObjectType: types.ObjectType{
										AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"mac_address": schema.StringAttribute{
							Computed: true,
						},
						"security_groups": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"access_url": schema.StringAttribute{
										Computed: true,
									},
									"backend_id": schema.StringAttribute{
										Computed: true,
									},
									"created": schema.StringAttribute{
										Computed: true,
									},
									"customer": schema.StringAttribute{
										Computed: true,
									},
									"customer_abbreviation": schema.StringAttribute{
										Computed: true,
									},
									"customer_name": schema.StringAttribute{
										Computed: true,
									},
									"customer_native_name": schema.StringAttribute{
										Computed: true,
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"error_message": schema.StringAttribute{
										Computed: true,
									},
									"error_traceback": schema.StringAttribute{
										Computed: true,
									},
									"is_limit_based": schema.BoolAttribute{
										Computed: true,
									},
									"is_usage_based": schema.BoolAttribute{
										Computed: true,
									},
									"marketplace_category_name": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_category_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_offering_name": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_offering_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_plan_uuid": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_resource_state": schema.StringAttribute{
										Computed: true,
									},
									"marketplace_resource_uuid": schema.StringAttribute{
										Computed: true,
									},
									"modified": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"project": schema.StringAttribute{
										Computed: true,
									},
									"project_name": schema.StringAttribute{
										Computed: true,
									},
									"project_uuid": schema.StringAttribute{
										Computed: true,
									},
									"resource_type": schema.StringAttribute{
										Computed: true,
									},
									"rules": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"cidr": schema.StringAttribute{
													Computed: true,
												},
												"description": schema.StringAttribute{
													Computed: true,
												},
												"direction": schema.StringAttribute{
													Computed: true,
												},
												"ethertype": schema.StringAttribute{
													Computed: true,
												},
												"from_port": schema.Int64Attribute{
													Computed: true,
												},
												"id": schema.Int64Attribute{
													Computed: true,
												},
												"remote_group": schema.StringAttribute{
													Computed: true,
												},
												"remote_group_name": schema.StringAttribute{
													Computed: true,
												},
												"remote_group_uuid": schema.StringAttribute{
													Computed: true,
												},
												"to_port": schema.Int64Attribute{
													Computed: true,
												},
											},
											CustomType: RulesType{
												ObjectType: types.ObjectType{
													AttrTypes: RulesValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"service_name": schema.StringAttribute{
										Computed: true,
									},
									"service_settings": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_error_message": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_state": schema.StringAttribute{
										Computed: true,
									},
									"service_settings_uuid": schema.StringAttribute{
										Computed: true,
									},
									"state": schema.StringAttribute{
										Computed: true,
									},
									"tenant": schema.StringAttribute{
										Computed: true,
									},
									"tenant_name": schema.StringAttribute{
										Computed: true,
									},
									"tenant_uuid": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SecurityGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"subnet": schema.StringAttribute{
							Computed: true,
						},
						"subnet_cidr": schema.StringAttribute{
							Computed: true,
						},
						"subnet_description": schema.StringAttribute{
							Computed: true,
						},
						"subnet_name": schema.StringAttribute{
							Computed: true,
						},
						"subnet_uuid": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: InstancePortsType{
						ObjectType: types.ObjectType{
							AttrTypes: InstancePortsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"instance_security_groups": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"url": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: InstanceSecurityGroupsType{
						ObjectType: types.ObjectType{
							AttrTypes: InstanceSecurityGroupsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"is_limit_based": schema.BoolAttribute{
				Computed: true,
			},
			"is_usage_based": schema.BoolAttribute{
				Computed: true,
			},
			"kept_until": schema.StringAttribute{
				Computed:            true,
				Description:         "Guaranteed time of backup retention. If null - keep forever.",
				MarkdownDescription: "Guaranteed time of backup retention. If null - keep forever.",
			},
			"marketplace_category_name": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_category_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_offering_name": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_offering_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_plan_uuid": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_resource_state": schema.StringAttribute{
				Computed: true,
			},
			"marketplace_resource_uuid": schema.StringAttribute{
				Computed: true,
			},
			"modified": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"project": schema.StringAttribute{
				Computed: true,
			},
			"project_name": schema.StringAttribute{
				Computed: true,
			},
			"project_uuid": schema.StringAttribute{
				Computed: true,
			},
			"resource_type": schema.StringAttribute{
				Computed: true,
			},
			"restorations": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created": schema.StringAttribute{
							Computed: true,
						},
						"flavor": schema.StringAttribute{
							Computed: true,
						},
						"floating_ips": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"address": schema.StringAttribute{
										Computed: true,
									},
									"port_fixed_ips": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"ip_address": schema.StringAttribute{
													Computed: true,
												},
												"subnet_id": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: PortFixedIpsType{
												ObjectType: types.ObjectType{
													AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"port_mac_address": schema.StringAttribute{
										Computed: true,
									},
									"subnet": schema.StringAttribute{
										Computed: true,
									},
									"subnet_cidr": schema.StringAttribute{
										Computed: true,
									},
									"subnet_description": schema.StringAttribute{
										Computed: true,
									},
									"subnet_name": schema.StringAttribute{
										Computed: true,
									},
									"subnet_uuid": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: FloatingIpsType{
									ObjectType: types.ObjectType{
										AttrTypes: FloatingIpsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"instance": schema.StringAttribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed:            true,
							Description:         "New instance name. Leave blank to use source instance name.",
							MarkdownDescription: "New instance name. Leave blank to use source instance name.",
						},
						"ports": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"allowed_address_pairs": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"mac_address": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: AllowedAddressPairsType{
												ObjectType: types.ObjectType{
													AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"device_id": schema.StringAttribute{
										Computed: true,
									},
									"device_owner": schema.StringAttribute{
										Computed: true,
									},
									"fixed_ips": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"ip_address": schema.StringAttribute{
													Computed: true,
												},
												"subnet_id": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: FixedIpsType{
												ObjectType: types.ObjectType{
													AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"mac_address": schema.StringAttribute{
										Computed: true,
									},
									"security_groups": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"access_url": schema.StringAttribute{
													Computed: true,
												},
												"backend_id": schema.StringAttribute{
													Computed: true,
												},
												"created": schema.StringAttribute{
													Computed: true,
												},
												"customer": schema.StringAttribute{
													Computed: true,
												},
												"customer_abbreviation": schema.StringAttribute{
													Computed: true,
												},
												"customer_name": schema.StringAttribute{
													Computed: true,
												},
												"customer_native_name": schema.StringAttribute{
													Computed: true,
												},
												"description": schema.StringAttribute{
													Computed: true,
												},
												"error_message": schema.StringAttribute{
													Computed: true,
												},
												"error_traceback": schema.StringAttribute{
													Computed: true,
												},
												"is_limit_based": schema.BoolAttribute{
													Computed: true,
												},
												"is_usage_based": schema.BoolAttribute{
													Computed: true,
												},
												"marketplace_category_name": schema.StringAttribute{
													Computed: true,
												},
												"marketplace_category_uuid": schema.StringAttribute{
													Computed: true,
												},
												"marketplace_offering_name": schema.StringAttribute{
													Computed: true,
												},
												"marketplace_offering_uuid": schema.StringAttribute{
													Computed: true,
												},
												"marketplace_plan_uuid": schema.StringAttribute{
													Computed: true,
												},
												"marketplace_resource_state": schema.StringAttribute{
													Computed: true,
												},
												"marketplace_resource_uuid": schema.StringAttribute{
													Computed: true,
												},
												"modified": schema.StringAttribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"project": schema.StringAttribute{
													Computed: true,
												},
												"project_name": schema.StringAttribute{
													Computed: true,
												},
												"project_uuid": schema.StringAttribute{
													Computed: true,
												},
												"resource_type": schema.StringAttribute{
													Computed: true,
												},
												"rules": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"cidr": schema.StringAttribute{
																Computed: true,
															},
															"description": schema.StringAttribute{
																Computed: true,
															},
															"direction": schema.StringAttribute{
																Computed: true,
															},
															"ethertype": schema.StringAttribute{
																Computed: true,
															},
															"from_port": schema.Int64Attribute{
																Computed: true,
															},
															"id": schema.Int64Attribute{
																Computed: true,
															},
															"remote_group": schema.StringAttribute{
																Computed: true,
															},
															"remote_group_name": schema.StringAttribute{
																Computed: true,
															},
															"remote_group_uuid": schema.StringAttribute{
																Computed: true,
															},
															"to_port": schema.Int64Attribute{
																Computed: true,
															},
														},
														CustomType: RulesType{
															ObjectType: types.ObjectType{
																AttrTypes: RulesValue{}.AttributeTypes(ctx),
															},
														},
													},
													Computed: true,
												},
												"service_name": schema.StringAttribute{
													Computed: true,
												},
												"service_settings": schema.StringAttribute{
													Computed: true,
												},
												"service_settings_error_message": schema.StringAttribute{
													Computed: true,
												},
												"service_settings_state": schema.StringAttribute{
													Computed: true,
												},
												"service_settings_uuid": schema.StringAttribute{
													Computed: true,
												},
												"state": schema.StringAttribute{
													Computed: true,
												},
												"tenant": schema.StringAttribute{
													Computed: true,
												},
												"tenant_name": schema.StringAttribute{
													Computed: true,
												},
												"tenant_uuid": schema.StringAttribute{
													Computed: true,
												},
												"url": schema.StringAttribute{
													Computed: true,
												},
												"uuid": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: SecurityGroupsType{
												ObjectType: types.ObjectType{
													AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"subnet": schema.StringAttribute{
										Computed: true,
									},
									"subnet_cidr": schema.StringAttribute{
										Computed: true,
									},
									"subnet_description": schema.StringAttribute{
										Computed: true,
									},
									"subnet_name": schema.StringAttribute{
										Computed: true,
									},
									"subnet_uuid": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: PortsType{
									ObjectType: types.ObjectType{
										AttrTypes: PortsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"security_groups": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"url": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: SecurityGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: RestorationsType{
						ObjectType: types.ObjectType{
							AttrTypes: RestorationsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"service_name": schema.StringAttribute{
				Computed: true,
			},
			"service_settings": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_error_message": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_state": schema.StringAttribute{
				Computed: true,
			},
			"service_settings_uuid": schema.StringAttribute{
				Computed: true,
			},
			"state": schema.StringAttribute{
				Computed: true,
			},
			"tenant_uuid": schema.StringAttribute{
				Computed: true,
			},
			"url": schema.StringAttribute{
				Computed: true,
			},
			"uuid": schema.StringAttribute{
				Required: true,
			},
		},
	}
}

type OpenstackBackupModel struct {
	AccessUrl                   types.String `tfsdk:"access_url"`
	BackendId                   types.String `tfsdk:"backend_id"`
	Created                     types.String `tfsdk:"created"`
	Customer                    types.String `tfsdk:"customer"`
	CustomerAbbreviation        types.String `tfsdk:"customer_abbreviation"`
	CustomerName                types.String `tfsdk:"customer_name"`
	CustomerNativeName          types.String `tfsdk:"customer_native_name"`
	Description                 types.String `tfsdk:"description"`
	ErrorMessage                types.String `tfsdk:"error_message"`
	ErrorTraceback              types.String `tfsdk:"error_traceback"`
	Field                       types.List   `tfsdk:"field"`
	Instance                    types.String `tfsdk:"instance"`
	InstanceFloatingIps         types.List   `tfsdk:"instance_floating_ips"`
	InstanceMarketplaceUuid     types.String `tfsdk:"instance_marketplace_uuid"`
	InstanceName                types.String `tfsdk:"instance_name"`
	InstancePorts               types.List   `tfsdk:"instance_ports"`
	InstanceSecurityGroups      types.List   `tfsdk:"instance_security_groups"`
	IsLimitBased                types.Bool   `tfsdk:"is_limit_based"`
	IsUsageBased                types.Bool   `tfsdk:"is_usage_based"`
	KeptUntil                   types.String `tfsdk:"kept_until"`
	MarketplaceCategoryName     types.String `tfsdk:"marketplace_category_name"`
	MarketplaceCategoryUuid     types.String `tfsdk:"marketplace_category_uuid"`
	MarketplaceOfferingName     types.String `tfsdk:"marketplace_offering_name"`
	MarketplaceOfferingUuid     types.String `tfsdk:"marketplace_offering_uuid"`
	MarketplacePlanUuid         types.String `tfsdk:"marketplace_plan_uuid"`
	MarketplaceResourceState    types.String `tfsdk:"marketplace_resource_state"`
	MarketplaceResourceUuid     types.String `tfsdk:"marketplace_resource_uuid"`
	Modified                    types.String `tfsdk:"modified"`
	Name                        types.String `tfsdk:"name"`
	Project                     types.String `tfsdk:"project"`
	ProjectName                 types.String `tfsdk:"project_name"`
	ProjectUuid                 types.String `tfsdk:"project_uuid"`
	ResourceType                types.String `tfsdk:"resource_type"`
	Restorations                types.List   `tfsdk:"restorations"`
	ServiceName                 types.String `tfsdk:"service_name"`
	ServiceSettings             types.String `tfsdk:"service_settings"`
	ServiceSettingsErrorMessage types.String `tfsdk:"service_settings_error_message"`
	ServiceSettingsState        types.String `tfsdk:"service_settings_state"`
	ServiceSettingsUuid         types.String `tfsdk:"service_settings_uuid"`
	State                       types.String `tfsdk:"state"`
	TenantUuid                  types.String `tfsdk:"tenant_uuid"`
	Url                         types.String `tfsdk:"url"`
	Uuid                        types.String `tfsdk:"uuid"`
}

var _ basetypes.ObjectTypable = InstanceFloatingIpsType{}

type InstanceFloatingIpsType struct {
	basetypes.ObjectType
}

func (t InstanceFloatingIpsType) Equal(o attr.Type) bool {
	other, ok := o.(InstanceFloatingIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstanceFloatingIpsType) String() string {
	return "InstanceFloatingIpsType"
}

func (t InstanceFloatingIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	portFixedIpsAttribute, ok := attributes["port_fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_fixed_ips is missing from object`)

		return nil, diags
	}

	portFixedIpsVal, ok := portFixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_fixed_ips expected to be basetypes.ListValue, was: %T`, portFixedIpsAttribute))
	}

	portMacAddressAttribute, ok := attributes["port_mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mac_address is missing from object`)

		return nil, diags
	}

	portMacAddressVal, ok := portMacAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mac_address expected to be basetypes.StringValue, was: %T`, portMacAddressAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return nil, diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return nil, diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return nil, diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstanceFloatingIpsValue{
		Address:           addressVal,
		PortFixedIps:      portFixedIpsVal,
		PortMacAddress:    portMacAddressVal,
		Subnet:            subnetVal,
		SubnetCidr:        subnetCidrVal,
		SubnetDescription: subnetDescriptionVal,
		SubnetName:        subnetNameVal,
		SubnetUuid:        subnetUuidVal,
		Url:               urlVal,
		Uuid:              uuidVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewInstanceFloatingIpsValueNull() InstanceFloatingIpsValue {
	return InstanceFloatingIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewInstanceFloatingIpsValueUnknown() InstanceFloatingIpsValue {
	return InstanceFloatingIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstanceFloatingIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstanceFloatingIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstanceFloatingIpsValue Attribute Value",
				"While creating a InstanceFloatingIpsValue value, a missing attribute value was detected. "+
					"A InstanceFloatingIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceFloatingIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstanceFloatingIpsValue Attribute Type",
				"While creating a InstanceFloatingIpsValue value, an invalid attribute value was detected. "+
					"A InstanceFloatingIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceFloatingIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstanceFloatingIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstanceFloatingIpsValue Attribute Value",
				"While creating a InstanceFloatingIpsValue value, an extra attribute value was detected. "+
					"A InstanceFloatingIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstanceFloatingIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	portFixedIpsAttribute, ok := attributes["port_fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_fixed_ips is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	portFixedIpsVal, ok := portFixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_fixed_ips expected to be basetypes.ListValue, was: %T`, portFixedIpsAttribute))
	}

	portMacAddressAttribute, ok := attributes["port_mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mac_address is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	portMacAddressVal, ok := portMacAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mac_address expected to be basetypes.StringValue, was: %T`, portMacAddressAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewInstanceFloatingIpsValueUnknown(), diags
	}

	return InstanceFloatingIpsValue{
		Address:           addressVal,
		PortFixedIps:      portFixedIpsVal,
		PortMacAddress:    portMacAddressVal,
		Subnet:            subnetVal,
		SubnetCidr:        subnetCidrVal,
		SubnetDescription: subnetDescriptionVal,
		SubnetName:        subnetNameVal,
		SubnetUuid:        subnetUuidVal,
		Url:               urlVal,
		Uuid:              uuidVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewInstanceFloatingIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstanceFloatingIpsValue {
	object, diags := NewInstanceFloatingIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstanceFloatingIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstanceFloatingIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstanceFloatingIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstanceFloatingIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstanceFloatingIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstanceFloatingIpsValueMust(InstanceFloatingIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstanceFloatingIpsType) ValueType(ctx context.Context) attr.Value {
	return InstanceFloatingIpsValue{}
}

var _ basetypes.ObjectValuable = InstanceFloatingIpsValue{}

type InstanceFloatingIpsValue struct {
	Address           basetypes.StringValue `tfsdk:"address"`
	PortFixedIps      basetypes.ListValue   `tfsdk:"port_fixed_ips"`
	PortMacAddress    basetypes.StringValue `tfsdk:"port_mac_address"`
	Subnet            basetypes.StringValue `tfsdk:"subnet"`
	SubnetCidr        basetypes.StringValue `tfsdk:"subnet_cidr"`
	SubnetDescription basetypes.StringValue `tfsdk:"subnet_description"`
	SubnetName        basetypes.StringValue `tfsdk:"subnet_name"`
	SubnetUuid        basetypes.StringValue `tfsdk:"subnet_uuid"`
	Url               basetypes.StringValue `tfsdk:"url"`
	Uuid              basetypes.StringValue `tfsdk:"uuid"`
	state             attr.ValueState
}

func (v InstanceFloatingIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_fixed_ips"] = basetypes.ListType{
		ElemType: PortFixedIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["port_mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.PortFixedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_fixed_ips"] = val

		val, err = v.PortMacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mac_address"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.SubnetDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_description"] = val

		val, err = v.SubnetName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_name"] = val

		val, err = v.SubnetUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstanceFloatingIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstanceFloatingIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstanceFloatingIpsValue) String() string {
	return "InstanceFloatingIpsValue"
}

func (v InstanceFloatingIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	portFixedIps := types.ListValueMust(
		PortFixedIpsType{
			basetypes.ObjectType{
				AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.PortFixedIps.Elements(),
	)

	if v.PortFixedIps.IsNull() {
		portFixedIps = types.ListNull(
			PortFixedIpsType{
				basetypes.ObjectType{
					AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortFixedIps.IsUnknown() {
		portFixedIps = types.ListUnknown(
			PortFixedIpsType{
				basetypes.ObjectType{
					AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"address": basetypes.StringType{},
		"port_fixed_ips": basetypes.ListType{
			ElemType: PortFixedIpsValue{}.Type(ctx),
		},
		"port_mac_address":   basetypes.StringType{},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
		"uuid":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":            v.Address,
			"port_fixed_ips":     portFixedIps,
			"port_mac_address":   v.PortMacAddress,
			"subnet":             v.Subnet,
			"subnet_cidr":        v.SubnetCidr,
			"subnet_description": v.SubnetDescription,
			"subnet_name":        v.SubnetName,
			"subnet_uuid":        v.SubnetUuid,
			"url":                v.Url,
			"uuid":               v.Uuid,
		})

	return objVal, diags
}

func (v InstanceFloatingIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(InstanceFloatingIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.PortFixedIps.Equal(other.PortFixedIps) {
		return false
	}

	if !v.PortMacAddress.Equal(other.PortMacAddress) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.SubnetDescription.Equal(other.SubnetDescription) {
		return false
	}

	if !v.SubnetName.Equal(other.SubnetName) {
		return false
	}

	if !v.SubnetUuid.Equal(other.SubnetUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v InstanceFloatingIpsValue) Type(ctx context.Context) attr.Type {
	return InstanceFloatingIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstanceFloatingIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address": basetypes.StringType{},
		"port_fixed_ips": basetypes.ListType{
			ElemType: PortFixedIpsValue{}.Type(ctx),
		},
		"port_mac_address":   basetypes.StringType{},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
		"uuid":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortFixedIpsType{}

type PortFixedIpsType struct {
	basetypes.ObjectType
}

func (t PortFixedIpsType) Equal(o attr.Type) bool {
	other, ok := o.(PortFixedIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortFixedIpsType) String() string {
	return "PortFixedIpsType"
}

func (t PortFixedIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortFixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPortFixedIpsValueNull() PortFixedIpsValue {
	return PortFixedIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortFixedIpsValueUnknown() PortFixedIpsValue {
	return PortFixedIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortFixedIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortFixedIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortFixedIpsValue Attribute Value",
				"While creating a PortFixedIpsValue value, a missing attribute value was detected. "+
					"A PortFixedIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortFixedIpsValue Attribute Type",
				"While creating a PortFixedIpsValue value, an invalid attribute value was detected. "+
					"A PortFixedIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortFixedIpsValue Attribute Value",
				"While creating a PortFixedIpsValue value, an extra attribute value was detected. "+
					"A PortFixedIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortFixedIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortFixedIpsValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewPortFixedIpsValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewPortFixedIpsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewPortFixedIpsValueUnknown(), diags
	}

	return PortFixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPortFixedIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortFixedIpsValue {
	object, diags := NewPortFixedIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortFixedIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortFixedIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortFixedIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortFixedIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortFixedIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortFixedIpsValueMust(PortFixedIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortFixedIpsType) ValueType(ctx context.Context) attr.Value {
	return PortFixedIpsValue{}
}

var _ basetypes.ObjectValuable = PortFixedIpsValue{}

type PortFixedIpsValue struct {
	IpAddress basetypes.StringValue `tfsdk:"ip_address"`
	SubnetId  basetypes.StringValue `tfsdk:"subnet_id"`
	state     attr.ValueState
}

func (v PortFixedIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortFixedIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortFixedIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortFixedIpsValue) String() string {
	return "PortFixedIpsValue"
}

func (v PortFixedIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address": v.IpAddress,
			"subnet_id":  v.SubnetId,
		})

	return objVal, diags
}

func (v PortFixedIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortFixedIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v PortFixedIpsValue) Type(ctx context.Context) attr.Type {
	return PortFixedIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortFixedIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InstancePortsType{}

type InstancePortsType struct {
	basetypes.ObjectType
}

func (t InstancePortsType) Equal(o attr.Type) bool {
	other, ok := o.(InstancePortsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstancePortsType) String() string {
	return "InstancePortsType"
}

func (t InstancePortsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedAddressPairsAttribute, ok := attributes["allowed_address_pairs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_address_pairs is missing from object`)

		return nil, diags
	}

	allowedAddressPairsVal, ok := allowedAddressPairsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_address_pairs expected to be basetypes.ListValue, was: %T`, allowedAddressPairsAttribute))
	}

	deviceIdAttribute, ok := attributes["device_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_id is missing from object`)

		return nil, diags
	}

	deviceIdVal, ok := deviceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_id expected to be basetypes.StringValue, was: %T`, deviceIdAttribute))
	}

	deviceOwnerAttribute, ok := attributes["device_owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_owner is missing from object`)

		return nil, diags
	}

	deviceOwnerVal, ok := deviceOwnerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_owner expected to be basetypes.StringValue, was: %T`, deviceOwnerAttribute))
	}

	fixedIpsAttribute, ok := attributes["fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ips is missing from object`)

		return nil, diags
	}

	fixedIpsVal, ok := fixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ips expected to be basetypes.ListValue, was: %T`, fixedIpsAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return nil, diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return nil, diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return nil, diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstancePortsValue{
		AllowedAddressPairs: allowedAddressPairsVal,
		DeviceId:            deviceIdVal,
		DeviceOwner:         deviceOwnerVal,
		FixedIps:            fixedIpsVal,
		MacAddress:          macAddressVal,
		SecurityGroups:      securityGroupsVal,
		Subnet:              subnetVal,
		SubnetCidr:          subnetCidrVal,
		SubnetDescription:   subnetDescriptionVal,
		SubnetName:          subnetNameVal,
		SubnetUuid:          subnetUuidVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewInstancePortsValueNull() InstancePortsValue {
	return InstancePortsValue{
		state: attr.ValueStateNull,
	}
}

func NewInstancePortsValueUnknown() InstancePortsValue {
	return InstancePortsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstancePortsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstancePortsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstancePortsValue Attribute Value",
				"While creating a InstancePortsValue value, a missing attribute value was detected. "+
					"A InstancePortsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancePortsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstancePortsValue Attribute Type",
				"While creating a InstancePortsValue value, an invalid attribute value was detected. "+
					"A InstancePortsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstancePortsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstancePortsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstancePortsValue Attribute Value",
				"While creating a InstancePortsValue value, an extra attribute value was detected. "+
					"A InstancePortsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstancePortsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstancePortsValueUnknown(), diags
	}

	allowedAddressPairsAttribute, ok := attributes["allowed_address_pairs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_address_pairs is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	allowedAddressPairsVal, ok := allowedAddressPairsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_address_pairs expected to be basetypes.ListValue, was: %T`, allowedAddressPairsAttribute))
	}

	deviceIdAttribute, ok := attributes["device_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_id is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	deviceIdVal, ok := deviceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_id expected to be basetypes.StringValue, was: %T`, deviceIdAttribute))
	}

	deviceOwnerAttribute, ok := attributes["device_owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_owner is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	deviceOwnerVal, ok := deviceOwnerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_owner expected to be basetypes.StringValue, was: %T`, deviceOwnerAttribute))
	}

	fixedIpsAttribute, ok := attributes["fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ips is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	fixedIpsVal, ok := fixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ips expected to be basetypes.ListValue, was: %T`, fixedIpsAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewInstancePortsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewInstancePortsValueUnknown(), diags
	}

	return InstancePortsValue{
		AllowedAddressPairs: allowedAddressPairsVal,
		DeviceId:            deviceIdVal,
		DeviceOwner:         deviceOwnerVal,
		FixedIps:            fixedIpsVal,
		MacAddress:          macAddressVal,
		SecurityGroups:      securityGroupsVal,
		Subnet:              subnetVal,
		SubnetCidr:          subnetCidrVal,
		SubnetDescription:   subnetDescriptionVal,
		SubnetName:          subnetNameVal,
		SubnetUuid:          subnetUuidVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewInstancePortsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstancePortsValue {
	object, diags := NewInstancePortsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstancePortsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstancePortsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstancePortsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstancePortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstancePortsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstancePortsValueMust(InstancePortsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstancePortsType) ValueType(ctx context.Context) attr.Value {
	return InstancePortsValue{}
}

var _ basetypes.ObjectValuable = InstancePortsValue{}

type InstancePortsValue struct {
	AllowedAddressPairs basetypes.ListValue   `tfsdk:"allowed_address_pairs"`
	DeviceId            basetypes.StringValue `tfsdk:"device_id"`
	DeviceOwner         basetypes.StringValue `tfsdk:"device_owner"`
	FixedIps            basetypes.ListValue   `tfsdk:"fixed_ips"`
	MacAddress          basetypes.StringValue `tfsdk:"mac_address"`
	SecurityGroups      basetypes.ListValue   `tfsdk:"security_groups"`
	Subnet              basetypes.StringValue `tfsdk:"subnet"`
	SubnetCidr          basetypes.StringValue `tfsdk:"subnet_cidr"`
	SubnetDescription   basetypes.StringValue `tfsdk:"subnet_description"`
	SubnetName          basetypes.StringValue `tfsdk:"subnet_name"`
	SubnetUuid          basetypes.StringValue `tfsdk:"subnet_uuid"`
	Url                 basetypes.StringValue `tfsdk:"url"`
	state               attr.ValueState
}

func (v InstancePortsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["allowed_address_pairs"] = basetypes.ListType{
		ElemType: AllowedAddressPairsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["device_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["device_owner"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_ips"] = basetypes.ListType{
		ElemType: FixedIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AllowedAddressPairs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_address_pairs"] = val

		val, err = v.DeviceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_id"] = val

		val, err = v.DeviceOwner.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_owner"] = val

		val, err = v.FixedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_ips"] = val

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.SubnetDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_description"] = val

		val, err = v.SubnetName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_name"] = val

		val, err = v.SubnetUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstancePortsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstancePortsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstancePortsValue) String() string {
	return "InstancePortsValue"
}

func (v InstancePortsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	allowedAddressPairs := types.ListValueMust(
		AllowedAddressPairsType{
			basetypes.ObjectType{
				AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
			},
		},
		v.AllowedAddressPairs.Elements(),
	)

	if v.AllowedAddressPairs.IsNull() {
		allowedAddressPairs = types.ListNull(
			AllowedAddressPairsType{
				basetypes.ObjectType{
					AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AllowedAddressPairs.IsUnknown() {
		allowedAddressPairs = types.ListUnknown(
			AllowedAddressPairsType{
				basetypes.ObjectType{
					AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	fixedIps := types.ListValueMust(
		FixedIpsType{
			basetypes.ObjectType{
				AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.FixedIps.Elements(),
	)

	if v.FixedIps.IsNull() {
		fixedIps = types.ListNull(
			FixedIpsType{
				basetypes.ObjectType{
					AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FixedIps.IsUnknown() {
		fixedIps = types.ListUnknown(
			FixedIpsType{
				basetypes.ObjectType{
					AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroups := types.ListValueMust(
		SecurityGroupsType{
			basetypes.ObjectType{
				AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups.Elements(),
	)

	if v.SecurityGroups.IsNull() {
		securityGroups = types.ListNull(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups.IsUnknown() {
		securityGroups = types.ListUnknown(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"allowed_address_pairs": basetypes.ListType{
			ElemType: AllowedAddressPairsValue{}.Type(ctx),
		},
		"device_id":    basetypes.StringType{},
		"device_owner": basetypes.StringType{},
		"fixed_ips": basetypes.ListType{
			ElemType: FixedIpsValue{}.Type(ctx),
		},
		"mac_address": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_address_pairs": allowedAddressPairs,
			"device_id":             v.DeviceId,
			"device_owner":          v.DeviceOwner,
			"fixed_ips":             fixedIps,
			"mac_address":           v.MacAddress,
			"security_groups":       securityGroups,
			"subnet":                v.Subnet,
			"subnet_cidr":           v.SubnetCidr,
			"subnet_description":    v.SubnetDescription,
			"subnet_name":           v.SubnetName,
			"subnet_uuid":           v.SubnetUuid,
			"url":                   v.Url,
		})

	return objVal, diags
}

func (v InstancePortsValue) Equal(o attr.Value) bool {
	other, ok := o.(InstancePortsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedAddressPairs.Equal(other.AllowedAddressPairs) {
		return false
	}

	if !v.DeviceId.Equal(other.DeviceId) {
		return false
	}

	if !v.DeviceOwner.Equal(other.DeviceOwner) {
		return false
	}

	if !v.FixedIps.Equal(other.FixedIps) {
		return false
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.SubnetDescription.Equal(other.SubnetDescription) {
		return false
	}

	if !v.SubnetName.Equal(other.SubnetName) {
		return false
	}

	if !v.SubnetUuid.Equal(other.SubnetUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v InstancePortsValue) Type(ctx context.Context) attr.Type {
	return InstancePortsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstancePortsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_address_pairs": basetypes.ListType{
			ElemType: AllowedAddressPairsValue{}.Type(ctx),
		},
		"device_id":    basetypes.StringType{},
		"device_owner": basetypes.StringType{},
		"fixed_ips": basetypes.ListType{
			ElemType: FixedIpsValue{}.Type(ctx),
		},
		"mac_address": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AllowedAddressPairsType{}

type AllowedAddressPairsType struct {
	basetypes.ObjectType
}

func (t AllowedAddressPairsType) Equal(o attr.Type) bool {
	other, ok := o.(AllowedAddressPairsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AllowedAddressPairsType) String() string {
	return "AllowedAddressPairsType"
}

func (t AllowedAddressPairsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AllowedAddressPairsValue{
		MacAddress: macAddressVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAllowedAddressPairsValueNull() AllowedAddressPairsValue {
	return AllowedAddressPairsValue{
		state: attr.ValueStateNull,
	}
}

func NewAllowedAddressPairsValueUnknown() AllowedAddressPairsValue {
	return AllowedAddressPairsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAllowedAddressPairsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AllowedAddressPairsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AllowedAddressPairsValue Attribute Value",
				"While creating a AllowedAddressPairsValue value, a missing attribute value was detected. "+
					"A AllowedAddressPairsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AllowedAddressPairsValue Attribute Type",
				"While creating a AllowedAddressPairsValue value, an invalid attribute value was detected. "+
					"A AllowedAddressPairsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AllowedAddressPairsValue Attribute Value",
				"While creating a AllowedAddressPairsValue value, an extra attribute value was detected. "+
					"A AllowedAddressPairsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AllowedAddressPairsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAllowedAddressPairsValueUnknown(), diags
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewAllowedAddressPairsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	if diags.HasError() {
		return NewAllowedAddressPairsValueUnknown(), diags
	}

	return AllowedAddressPairsValue{
		MacAddress: macAddressVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAllowedAddressPairsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AllowedAddressPairsValue {
	object, diags := NewAllowedAddressPairsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAllowedAddressPairsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AllowedAddressPairsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAllowedAddressPairsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAllowedAddressPairsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAllowedAddressPairsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAllowedAddressPairsValueMust(AllowedAddressPairsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AllowedAddressPairsType) ValueType(ctx context.Context) attr.Value {
	return AllowedAddressPairsValue{}
}

var _ basetypes.ObjectValuable = AllowedAddressPairsValue{}

type AllowedAddressPairsValue struct {
	MacAddress basetypes.StringValue `tfsdk:"mac_address"`
	state      attr.ValueState
}

func (v AllowedAddressPairsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AllowedAddressPairsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AllowedAddressPairsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AllowedAddressPairsValue) String() string {
	return "AllowedAddressPairsValue"
}

func (v AllowedAddressPairsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mac_address": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mac_address": v.MacAddress,
		})

	return objVal, diags
}

func (v AllowedAddressPairsValue) Equal(o attr.Value) bool {
	other, ok := o.(AllowedAddressPairsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	return true
}

func (v AllowedAddressPairsValue) Type(ctx context.Context) attr.Type {
	return AllowedAddressPairsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AllowedAddressPairsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mac_address": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FixedIpsType{}

type FixedIpsType struct {
	basetypes.ObjectType
}

func (t FixedIpsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedIpsType) String() string {
	return "FixedIpsType"
}

func (t FixedIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueNull() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedIpsValueUnknown() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, a missing attribute value was detected. "+
					"A FixedIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedIpsValue Attribute Type",
				"While creating a FixedIpsValue value, an invalid attribute value was detected. "+
					"A FixedIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, an extra attribute value was detected. "+
					"A FixedIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedIpsValue {
	object, diags := NewFixedIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedIpsValueMust(FixedIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedIpsType) ValueType(ctx context.Context) attr.Value {
	return FixedIpsValue{}
}

var _ basetypes.ObjectValuable = FixedIpsValue{}

type FixedIpsValue struct {
	IpAddress basetypes.StringValue `tfsdk:"ip_address"`
	SubnetId  basetypes.StringValue `tfsdk:"subnet_id"`
	state     attr.ValueState
}

func (v FixedIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedIpsValue) String() string {
	return "FixedIpsValue"
}

func (v FixedIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address": v.IpAddress,
			"subnet_id":  v.SubnetId,
		})

	return objVal, diags
}

func (v FixedIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v FixedIpsValue) Type(ctx context.Context) attr.Type {
	return FixedIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroupsType{}

type SecurityGroupsType struct {
	basetypes.ObjectType
}

func (t SecurityGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroupsType) String() string {
	return "SecurityGroupsType"
}

func (t SecurityGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return nil, diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return nil, diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return nil, diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerAbbreviationAttribute, ok := attributes["customer_abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_abbreviation is missing from object`)

		return nil, diags
	}

	customerAbbreviationVal, ok := customerAbbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_abbreviation expected to be basetypes.StringValue, was: %T`, customerAbbreviationAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return nil, diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerNativeNameAttribute, ok := attributes["customer_native_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_native_name is missing from object`)

		return nil, diags
	}

	customerNativeNameVal, ok := customerNativeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_native_name expected to be basetypes.StringValue, was: %T`, customerNativeNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return nil, diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	errorTracebackAttribute, ok := attributes["error_traceback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_traceback is missing from object`)

		return nil, diags
	}

	errorTracebackVal, ok := errorTracebackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_traceback expected to be basetypes.StringValue, was: %T`, errorTracebackAttribute))
	}

	isLimitBasedAttribute, ok := attributes["is_limit_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_limit_based is missing from object`)

		return nil, diags
	}

	isLimitBasedVal, ok := isLimitBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_limit_based expected to be basetypes.BoolValue, was: %T`, isLimitBasedAttribute))
	}

	isUsageBasedAttribute, ok := attributes["is_usage_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_usage_based is missing from object`)

		return nil, diags
	}

	isUsageBasedVal, ok := isUsageBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_usage_based expected to be basetypes.BoolValue, was: %T`, isUsageBasedAttribute))
	}

	marketplaceCategoryNameAttribute, ok := attributes["marketplace_category_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_name is missing from object`)

		return nil, diags
	}

	marketplaceCategoryNameVal, ok := marketplaceCategoryNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_name expected to be basetypes.StringValue, was: %T`, marketplaceCategoryNameAttribute))
	}

	marketplaceCategoryUuidAttribute, ok := attributes["marketplace_category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_uuid is missing from object`)

		return nil, diags
	}

	marketplaceCategoryUuidVal, ok := marketplaceCategoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_uuid expected to be basetypes.StringValue, was: %T`, marketplaceCategoryUuidAttribute))
	}

	marketplaceOfferingNameAttribute, ok := attributes["marketplace_offering_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_name is missing from object`)

		return nil, diags
	}

	marketplaceOfferingNameVal, ok := marketplaceOfferingNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_name expected to be basetypes.StringValue, was: %T`, marketplaceOfferingNameAttribute))
	}

	marketplaceOfferingUuidAttribute, ok := attributes["marketplace_offering_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_uuid is missing from object`)

		return nil, diags
	}

	marketplaceOfferingUuidVal, ok := marketplaceOfferingUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_uuid expected to be basetypes.StringValue, was: %T`, marketplaceOfferingUuidAttribute))
	}

	marketplacePlanUuidAttribute, ok := attributes["marketplace_plan_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_plan_uuid is missing from object`)

		return nil, diags
	}

	marketplacePlanUuidVal, ok := marketplacePlanUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_plan_uuid expected to be basetypes.StringValue, was: %T`, marketplacePlanUuidAttribute))
	}

	marketplaceResourceStateAttribute, ok := attributes["marketplace_resource_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_state is missing from object`)

		return nil, diags
	}

	marketplaceResourceStateVal, ok := marketplaceResourceStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_state expected to be basetypes.StringValue, was: %T`, marketplaceResourceStateAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return nil, diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	modifiedAttribute, ok := attributes["modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified is missing from object`)

		return nil, diags
	}

	modifiedVal, ok := modifiedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified expected to be basetypes.StringValue, was: %T`, modifiedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return nil, diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return nil, diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return nil, diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serviceNameAttribute, ok := attributes["service_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_name is missing from object`)

		return nil, diags
	}

	serviceNameVal, ok := serviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_name expected to be basetypes.StringValue, was: %T`, serviceNameAttribute))
	}

	serviceSettingsAttribute, ok := attributes["service_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings is missing from object`)

		return nil, diags
	}

	serviceSettingsVal, ok := serviceSettingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings expected to be basetypes.StringValue, was: %T`, serviceSettingsAttribute))
	}

	serviceSettingsErrorMessageAttribute, ok := attributes["service_settings_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_error_message is missing from object`)

		return nil, diags
	}

	serviceSettingsErrorMessageVal, ok := serviceSettingsErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_error_message expected to be basetypes.StringValue, was: %T`, serviceSettingsErrorMessageAttribute))
	}

	serviceSettingsStateAttribute, ok := attributes["service_settings_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_state is missing from object`)

		return nil, diags
	}

	serviceSettingsStateVal, ok := serviceSettingsStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_state expected to be basetypes.StringValue, was: %T`, serviceSettingsStateAttribute))
	}

	serviceSettingsUuidAttribute, ok := attributes["service_settings_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_uuid is missing from object`)

		return nil, diags
	}

	serviceSettingsUuidVal, ok := serviceSettingsUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_uuid expected to be basetypes.StringValue, was: %T`, serviceSettingsUuidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	tenantNameAttribute, ok := attributes["tenant_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_name is missing from object`)

		return nil, diags
	}

	tenantNameVal, ok := tenantNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_name expected to be basetypes.StringValue, was: %T`, tenantNameAttribute))
	}

	tenantUuidAttribute, ok := attributes["tenant_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_uuid is missing from object`)

		return nil, diags
	}

	tenantUuidVal, ok := tenantUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_uuid expected to be basetypes.StringValue, was: %T`, tenantUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroupsValue{
		AccessUrl:                   accessUrlVal,
		BackendId:                   backendIdVal,
		Created:                     createdVal,
		Customer:                    customerVal,
		CustomerAbbreviation:        customerAbbreviationVal,
		CustomerName:                customerNameVal,
		CustomerNativeName:          customerNativeNameVal,
		Description:                 descriptionVal,
		ErrorMessage:                errorMessageVal,
		ErrorTraceback:              errorTracebackVal,
		IsLimitBased:                isLimitBasedVal,
		IsUsageBased:                isUsageBasedVal,
		MarketplaceCategoryName:     marketplaceCategoryNameVal,
		MarketplaceCategoryUuid:     marketplaceCategoryUuidVal,
		MarketplaceOfferingName:     marketplaceOfferingNameVal,
		MarketplaceOfferingUuid:     marketplaceOfferingUuidVal,
		MarketplacePlanUuid:         marketplacePlanUuidVal,
		MarketplaceResourceState:    marketplaceResourceStateVal,
		MarketplaceResourceUuid:     marketplaceResourceUuidVal,
		Modified:                    modifiedVal,
		Name:                        nameVal,
		Project:                     projectVal,
		ProjectName:                 projectNameVal,
		ProjectUuid:                 projectUuidVal,
		ResourceType:                resourceTypeVal,
		Rules:                       rulesVal,
		ServiceName:                 serviceNameVal,
		ServiceSettings:             serviceSettingsVal,
		ServiceSettingsErrorMessage: serviceSettingsErrorMessageVal,
		ServiceSettingsState:        serviceSettingsStateVal,
		ServiceSettingsUuid:         serviceSettingsUuidVal,
		State:                       stateVal,
		Tenant:                      tenantVal,
		TenantName:                  tenantNameVal,
		TenantUuid:                  tenantUuidVal,
		Url:                         urlVal,
		Uuid:                        uuidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueNull() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroupsValueUnknown() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, a missing attribute value was detected. "+
					"A SecurityGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroupsValue Attribute Type",
				"While creating a SecurityGroupsValue value, an invalid attribute value was detected. "+
					"A SecurityGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, an extra attribute value was detected. "+
					"A SecurityGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerAbbreviationAttribute, ok := attributes["customer_abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_abbreviation is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerAbbreviationVal, ok := customerAbbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_abbreviation expected to be basetypes.StringValue, was: %T`, customerAbbreviationAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerNativeNameAttribute, ok := attributes["customer_native_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_native_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerNativeNameVal, ok := customerNativeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_native_name expected to be basetypes.StringValue, was: %T`, customerNativeNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	errorTracebackAttribute, ok := attributes["error_traceback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_traceback is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	errorTracebackVal, ok := errorTracebackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_traceback expected to be basetypes.StringValue, was: %T`, errorTracebackAttribute))
	}

	isLimitBasedAttribute, ok := attributes["is_limit_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_limit_based is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	isLimitBasedVal, ok := isLimitBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_limit_based expected to be basetypes.BoolValue, was: %T`, isLimitBasedAttribute))
	}

	isUsageBasedAttribute, ok := attributes["is_usage_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_usage_based is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	isUsageBasedVal, ok := isUsageBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_usage_based expected to be basetypes.BoolValue, was: %T`, isUsageBasedAttribute))
	}

	marketplaceCategoryNameAttribute, ok := attributes["marketplace_category_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceCategoryNameVal, ok := marketplaceCategoryNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_name expected to be basetypes.StringValue, was: %T`, marketplaceCategoryNameAttribute))
	}

	marketplaceCategoryUuidAttribute, ok := attributes["marketplace_category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceCategoryUuidVal, ok := marketplaceCategoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_uuid expected to be basetypes.StringValue, was: %T`, marketplaceCategoryUuidAttribute))
	}

	marketplaceOfferingNameAttribute, ok := attributes["marketplace_offering_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceOfferingNameVal, ok := marketplaceOfferingNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_name expected to be basetypes.StringValue, was: %T`, marketplaceOfferingNameAttribute))
	}

	marketplaceOfferingUuidAttribute, ok := attributes["marketplace_offering_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceOfferingUuidVal, ok := marketplaceOfferingUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_uuid expected to be basetypes.StringValue, was: %T`, marketplaceOfferingUuidAttribute))
	}

	marketplacePlanUuidAttribute, ok := attributes["marketplace_plan_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_plan_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplacePlanUuidVal, ok := marketplacePlanUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_plan_uuid expected to be basetypes.StringValue, was: %T`, marketplacePlanUuidAttribute))
	}

	marketplaceResourceStateAttribute, ok := attributes["marketplace_resource_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceResourceStateVal, ok := marketplaceResourceStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_state expected to be basetypes.StringValue, was: %T`, marketplaceResourceStateAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	modifiedAttribute, ok := attributes["modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	modifiedVal, ok := modifiedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified expected to be basetypes.StringValue, was: %T`, modifiedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serviceNameAttribute, ok := attributes["service_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceNameVal, ok := serviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_name expected to be basetypes.StringValue, was: %T`, serviceNameAttribute))
	}

	serviceSettingsAttribute, ok := attributes["service_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsVal, ok := serviceSettingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings expected to be basetypes.StringValue, was: %T`, serviceSettingsAttribute))
	}

	serviceSettingsErrorMessageAttribute, ok := attributes["service_settings_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_error_message is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsErrorMessageVal, ok := serviceSettingsErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_error_message expected to be basetypes.StringValue, was: %T`, serviceSettingsErrorMessageAttribute))
	}

	serviceSettingsStateAttribute, ok := attributes["service_settings_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsStateVal, ok := serviceSettingsStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_state expected to be basetypes.StringValue, was: %T`, serviceSettingsStateAttribute))
	}

	serviceSettingsUuidAttribute, ok := attributes["service_settings_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsUuidVal, ok := serviceSettingsUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_uuid expected to be basetypes.StringValue, was: %T`, serviceSettingsUuidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	tenantNameAttribute, ok := attributes["tenant_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantNameVal, ok := tenantNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_name expected to be basetypes.StringValue, was: %T`, tenantNameAttribute))
	}

	tenantUuidAttribute, ok := attributes["tenant_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantUuidVal, ok := tenantUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_uuid expected to be basetypes.StringValue, was: %T`, tenantUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	return SecurityGroupsValue{
		AccessUrl:                   accessUrlVal,
		BackendId:                   backendIdVal,
		Created:                     createdVal,
		Customer:                    customerVal,
		CustomerAbbreviation:        customerAbbreviationVal,
		CustomerName:                customerNameVal,
		CustomerNativeName:          customerNativeNameVal,
		Description:                 descriptionVal,
		ErrorMessage:                errorMessageVal,
		ErrorTraceback:              errorTracebackVal,
		IsLimitBased:                isLimitBasedVal,
		IsUsageBased:                isUsageBasedVal,
		MarketplaceCategoryName:     marketplaceCategoryNameVal,
		MarketplaceCategoryUuid:     marketplaceCategoryUuidVal,
		MarketplaceOfferingName:     marketplaceOfferingNameVal,
		MarketplaceOfferingUuid:     marketplaceOfferingUuidVal,
		MarketplacePlanUuid:         marketplacePlanUuidVal,
		MarketplaceResourceState:    marketplaceResourceStateVal,
		MarketplaceResourceUuid:     marketplaceResourceUuidVal,
		Modified:                    modifiedVal,
		Name:                        nameVal,
		Project:                     projectVal,
		ProjectName:                 projectNameVal,
		ProjectUuid:                 projectUuidVal,
		ResourceType:                resourceTypeVal,
		Rules:                       rulesVal,
		ServiceName:                 serviceNameVal,
		ServiceSettings:             serviceSettingsVal,
		ServiceSettingsErrorMessage: serviceSettingsErrorMessageVal,
		ServiceSettingsState:        serviceSettingsStateVal,
		ServiceSettingsUuid:         serviceSettingsUuidVal,
		State:                       stateVal,
		Tenant:                      tenantVal,
		TenantName:                  tenantNameVal,
		TenantUuid:                  tenantUuidVal,
		Url:                         urlVal,
		Uuid:                        uuidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroupsValue {
	object, diags := NewSecurityGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroupsValueMust(SecurityGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroupsType) ValueType(ctx context.Context) attr.Value {
	return SecurityGroupsValue{}
}

var _ basetypes.ObjectValuable = SecurityGroupsValue{}

type SecurityGroupsValue struct {
	AccessUrl                   basetypes.StringValue `tfsdk:"access_url"`
	BackendId                   basetypes.StringValue `tfsdk:"backend_id"`
	Created                     basetypes.StringValue `tfsdk:"created"`
	Customer                    basetypes.StringValue `tfsdk:"customer"`
	CustomerAbbreviation        basetypes.StringValue `tfsdk:"customer_abbreviation"`
	CustomerName                basetypes.StringValue `tfsdk:"customer_name"`
	CustomerNativeName          basetypes.StringValue `tfsdk:"customer_native_name"`
	Description                 basetypes.StringValue `tfsdk:"description"`
	ErrorMessage                basetypes.StringValue `tfsdk:"error_message"`
	ErrorTraceback              basetypes.StringValue `tfsdk:"error_traceback"`
	IsLimitBased                basetypes.BoolValue   `tfsdk:"is_limit_based"`
	IsUsageBased                basetypes.BoolValue   `tfsdk:"is_usage_based"`
	MarketplaceCategoryName     basetypes.StringValue `tfsdk:"marketplace_category_name"`
	MarketplaceCategoryUuid     basetypes.StringValue `tfsdk:"marketplace_category_uuid"`
	MarketplaceOfferingName     basetypes.StringValue `tfsdk:"marketplace_offering_name"`
	MarketplaceOfferingUuid     basetypes.StringValue `tfsdk:"marketplace_offering_uuid"`
	MarketplacePlanUuid         basetypes.StringValue `tfsdk:"marketplace_plan_uuid"`
	MarketplaceResourceState    basetypes.StringValue `tfsdk:"marketplace_resource_state"`
	MarketplaceResourceUuid     basetypes.StringValue `tfsdk:"marketplace_resource_uuid"`
	Modified                    basetypes.StringValue `tfsdk:"modified"`
	Name                        basetypes.StringValue `tfsdk:"name"`
	Project                     basetypes.StringValue `tfsdk:"project"`
	ProjectName                 basetypes.StringValue `tfsdk:"project_name"`
	ProjectUuid                 basetypes.StringValue `tfsdk:"project_uuid"`
	ResourceType                basetypes.StringValue `tfsdk:"resource_type"`
	Rules                       basetypes.ListValue   `tfsdk:"rules"`
	ServiceName                 basetypes.StringValue `tfsdk:"service_name"`
	ServiceSettings             basetypes.StringValue `tfsdk:"service_settings"`
	ServiceSettingsErrorMessage basetypes.StringValue `tfsdk:"service_settings_error_message"`
	ServiceSettingsState        basetypes.StringValue `tfsdk:"service_settings_state"`
	ServiceSettingsUuid         basetypes.StringValue `tfsdk:"service_settings_uuid"`
	State                       basetypes.StringValue `tfsdk:"state"`
	Tenant                      basetypes.StringValue `tfsdk:"tenant"`
	TenantName                  basetypes.StringValue `tfsdk:"tenant_name"`
	TenantUuid                  basetypes.StringValue `tfsdk:"tenant_uuid"`
	Url                         basetypes.StringValue `tfsdk:"url"`
	Uuid                        basetypes.StringValue `tfsdk:"uuid"`
	state                       attr.ValueState
}

func (v SecurityGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 37)

	var val tftypes.Value
	var err error

	attrTypes["access_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backend_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_abbreviation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_native_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["error_traceback"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_limit_based"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_usage_based"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["marketplace_category_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_category_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_offering_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_offering_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_plan_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: RulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 37)

		val, err = v.AccessUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_url"] = val

		val, err = v.BackendId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_id"] = val

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Customer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer"] = val

		val, err = v.CustomerAbbreviation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_abbreviation"] = val

		val, err = v.CustomerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_name"] = val

		val, err = v.CustomerNativeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_native_name"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.ErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_message"] = val

		val, err = v.ErrorTraceback.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_traceback"] = val

		val, err = v.IsLimitBased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_limit_based"] = val

		val, err = v.IsUsageBased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_usage_based"] = val

		val, err = v.MarketplaceCategoryName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_category_name"] = val

		val, err = v.MarketplaceCategoryUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_category_uuid"] = val

		val, err = v.MarketplaceOfferingName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_offering_name"] = val

		val, err = v.MarketplaceOfferingUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_offering_uuid"] = val

		val, err = v.MarketplacePlanUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_plan_uuid"] = val

		val, err = v.MarketplaceResourceState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_state"] = val

		val, err = v.MarketplaceResourceUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_uuid"] = val

		val, err = v.Modified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		val, err = v.ProjectName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_name"] = val

		val, err = v.ProjectUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_uuid"] = val

		val, err = v.ResourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_type"] = val

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		val, err = v.ServiceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_name"] = val

		val, err = v.ServiceSettings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings"] = val

		val, err = v.ServiceSettingsErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_error_message"] = val

		val, err = v.ServiceSettingsState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_state"] = val

		val, err = v.ServiceSettingsUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_uuid"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.TenantName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_name"] = val

		val, err = v.TenantUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroupsValue) String() string {
	return "SecurityGroupsValue"
}

func (v SecurityGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	rules := types.ListValueMust(
		RulesType{
			basetypes.ObjectType{
				AttrTypes: RulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Rules.Elements(),
	)

	if v.Rules.IsNull() {
		rules = types.ListNull(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rules.IsUnknown() {
		rules = types.ListUnknown(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"access_url":                 basetypes.StringType{},
		"backend_id":                 basetypes.StringType{},
		"created":                    basetypes.StringType{},
		"customer":                   basetypes.StringType{},
		"customer_abbreviation":      basetypes.StringType{},
		"customer_name":              basetypes.StringType{},
		"customer_native_name":       basetypes.StringType{},
		"description":                basetypes.StringType{},
		"error_message":              basetypes.StringType{},
		"error_traceback":            basetypes.StringType{},
		"is_limit_based":             basetypes.BoolType{},
		"is_usage_based":             basetypes.BoolType{},
		"marketplace_category_name":  basetypes.StringType{},
		"marketplace_category_uuid":  basetypes.StringType{},
		"marketplace_offering_name":  basetypes.StringType{},
		"marketplace_offering_uuid":  basetypes.StringType{},
		"marketplace_plan_uuid":      basetypes.StringType{},
		"marketplace_resource_state": basetypes.StringType{},
		"marketplace_resource_uuid":  basetypes.StringType{},
		"modified":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"project":                    basetypes.StringType{},
		"project_name":               basetypes.StringType{},
		"project_uuid":               basetypes.StringType{},
		"resource_type":              basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"service_name":                   basetypes.StringType{},
		"service_settings":               basetypes.StringType{},
		"service_settings_error_message": basetypes.StringType{},
		"service_settings_state":         basetypes.StringType{},
		"service_settings_uuid":          basetypes.StringType{},
		"state":                          basetypes.StringType{},
		"tenant":                         basetypes.StringType{},
		"tenant_name":                    basetypes.StringType{},
		"tenant_uuid":                    basetypes.StringType{},
		"url":                            basetypes.StringType{},
		"uuid":                           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_url":                     v.AccessUrl,
			"backend_id":                     v.BackendId,
			"created":                        v.Created,
			"customer":                       v.Customer,
			"customer_abbreviation":          v.CustomerAbbreviation,
			"customer_name":                  v.CustomerName,
			"customer_native_name":           v.CustomerNativeName,
			"description":                    v.Description,
			"error_message":                  v.ErrorMessage,
			"error_traceback":                v.ErrorTraceback,
			"is_limit_based":                 v.IsLimitBased,
			"is_usage_based":                 v.IsUsageBased,
			"marketplace_category_name":      v.MarketplaceCategoryName,
			"marketplace_category_uuid":      v.MarketplaceCategoryUuid,
			"marketplace_offering_name":      v.MarketplaceOfferingName,
			"marketplace_offering_uuid":      v.MarketplaceOfferingUuid,
			"marketplace_plan_uuid":          v.MarketplacePlanUuid,
			"marketplace_resource_state":     v.MarketplaceResourceState,
			"marketplace_resource_uuid":      v.MarketplaceResourceUuid,
			"modified":                       v.Modified,
			"name":                           v.Name,
			"project":                        v.Project,
			"project_name":                   v.ProjectName,
			"project_uuid":                   v.ProjectUuid,
			"resource_type":                  v.ResourceType,
			"rules":                          rules,
			"service_name":                   v.ServiceName,
			"service_settings":               v.ServiceSettings,
			"service_settings_error_message": v.ServiceSettingsErrorMessage,
			"service_settings_state":         v.ServiceSettingsState,
			"service_settings_uuid":          v.ServiceSettingsUuid,
			"state":                          v.State,
			"tenant":                         v.Tenant,
			"tenant_name":                    v.TenantName,
			"tenant_uuid":                    v.TenantUuid,
			"url":                            v.Url,
			"uuid":                           v.Uuid,
		})

	return objVal, diags
}

func (v SecurityGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessUrl.Equal(other.AccessUrl) {
		return false
	}

	if !v.BackendId.Equal(other.BackendId) {
		return false
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Customer.Equal(other.Customer) {
		return false
	}

	if !v.CustomerAbbreviation.Equal(other.CustomerAbbreviation) {
		return false
	}

	if !v.CustomerName.Equal(other.CustomerName) {
		return false
	}

	if !v.CustomerNativeName.Equal(other.CustomerNativeName) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.ErrorMessage.Equal(other.ErrorMessage) {
		return false
	}

	if !v.ErrorTraceback.Equal(other.ErrorTraceback) {
		return false
	}

	if !v.IsLimitBased.Equal(other.IsLimitBased) {
		return false
	}

	if !v.IsUsageBased.Equal(other.IsUsageBased) {
		return false
	}

	if !v.MarketplaceCategoryName.Equal(other.MarketplaceCategoryName) {
		return false
	}

	if !v.MarketplaceCategoryUuid.Equal(other.MarketplaceCategoryUuid) {
		return false
	}

	if !v.MarketplaceOfferingName.Equal(other.MarketplaceOfferingName) {
		return false
	}

	if !v.MarketplaceOfferingUuid.Equal(other.MarketplaceOfferingUuid) {
		return false
	}

	if !v.MarketplacePlanUuid.Equal(other.MarketplacePlanUuid) {
		return false
	}

	if !v.MarketplaceResourceState.Equal(other.MarketplaceResourceState) {
		return false
	}

	if !v.MarketplaceResourceUuid.Equal(other.MarketplaceResourceUuid) {
		return false
	}

	if !v.Modified.Equal(other.Modified) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	if !v.ProjectName.Equal(other.ProjectName) {
		return false
	}

	if !v.ProjectUuid.Equal(other.ProjectUuid) {
		return false
	}

	if !v.ResourceType.Equal(other.ResourceType) {
		return false
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	if !v.ServiceName.Equal(other.ServiceName) {
		return false
	}

	if !v.ServiceSettings.Equal(other.ServiceSettings) {
		return false
	}

	if !v.ServiceSettingsErrorMessage.Equal(other.ServiceSettingsErrorMessage) {
		return false
	}

	if !v.ServiceSettingsState.Equal(other.ServiceSettingsState) {
		return false
	}

	if !v.ServiceSettingsUuid.Equal(other.ServiceSettingsUuid) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.TenantName.Equal(other.TenantName) {
		return false
	}

	if !v.TenantUuid.Equal(other.TenantUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v SecurityGroupsValue) Type(ctx context.Context) attr.Type {
	return SecurityGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_url":                 basetypes.StringType{},
		"backend_id":                 basetypes.StringType{},
		"created":                    basetypes.StringType{},
		"customer":                   basetypes.StringType{},
		"customer_abbreviation":      basetypes.StringType{},
		"customer_name":              basetypes.StringType{},
		"customer_native_name":       basetypes.StringType{},
		"description":                basetypes.StringType{},
		"error_message":              basetypes.StringType{},
		"error_traceback":            basetypes.StringType{},
		"is_limit_based":             basetypes.BoolType{},
		"is_usage_based":             basetypes.BoolType{},
		"marketplace_category_name":  basetypes.StringType{},
		"marketplace_category_uuid":  basetypes.StringType{},
		"marketplace_offering_name":  basetypes.StringType{},
		"marketplace_offering_uuid":  basetypes.StringType{},
		"marketplace_plan_uuid":      basetypes.StringType{},
		"marketplace_resource_state": basetypes.StringType{},
		"marketplace_resource_uuid":  basetypes.StringType{},
		"modified":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"project":                    basetypes.StringType{},
		"project_name":               basetypes.StringType{},
		"project_uuid":               basetypes.StringType{},
		"resource_type":              basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"service_name":                   basetypes.StringType{},
		"service_settings":               basetypes.StringType{},
		"service_settings_error_message": basetypes.StringType{},
		"service_settings_state":         basetypes.StringType{},
		"service_settings_uuid":          basetypes.StringType{},
		"state":                          basetypes.StringType{},
		"tenant":                         basetypes.StringType{},
		"tenant_name":                    basetypes.StringType{},
		"tenant_uuid":                    basetypes.StringType{},
		"url":                            basetypes.StringType{},
		"uuid":                           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RulesType{}

type RulesType struct {
	basetypes.ObjectType
}

func (t RulesType) Equal(o attr.Type) bool {
	other, ok := o.(RulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RulesType) String() string {
	return "RulesType"
}

func (t RulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return nil, diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	fromPortAttribute, ok := attributes["from_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_port is missing from object`)

		return nil, diags
	}

	fromPortVal, ok := fromPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_port expected to be basetypes.Int64Value, was: %T`, fromPortAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	remoteGroupAttribute, ok := attributes["remote_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group is missing from object`)

		return nil, diags
	}

	remoteGroupVal, ok := remoteGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group expected to be basetypes.StringValue, was: %T`, remoteGroupAttribute))
	}

	remoteGroupNameAttribute, ok := attributes["remote_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_name is missing from object`)

		return nil, diags
	}

	remoteGroupNameVal, ok := remoteGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_name expected to be basetypes.StringValue, was: %T`, remoteGroupNameAttribute))
	}

	remoteGroupUuidAttribute, ok := attributes["remote_group_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_uuid is missing from object`)

		return nil, diags
	}

	remoteGroupUuidVal, ok := remoteGroupUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_uuid expected to be basetypes.StringValue, was: %T`, remoteGroupUuidAttribute))
	}

	toPortAttribute, ok := attributes["to_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_port is missing from object`)

		return nil, diags
	}

	toPortVal, ok := toPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_port expected to be basetypes.Int64Value, was: %T`, toPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RulesValue{
		Cidr:            cidrVal,
		Description:     descriptionVal,
		Direction:       directionVal,
		Ethertype:       ethertypeVal,
		FromPort:        fromPortVal,
		Id:              idVal,
		RemoteGroup:     remoteGroupVal,
		RemoteGroupName: remoteGroupNameVal,
		RemoteGroupUuid: remoteGroupUuidVal,
		ToPort:          toPortVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRulesValueNull() RulesValue {
	return RulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRulesValueUnknown() RulesValue {
	return RulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RulesValue Attribute Value",
				"While creating a RulesValue value, a missing attribute value was detected. "+
					"A RulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RulesValue Attribute Type",
				"While creating a RulesValue value, an invalid attribute value was detected. "+
					"A RulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RulesValue Attribute Value",
				"While creating a RulesValue value, an extra attribute value was detected. "+
					"A RulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	fromPortAttribute, ok := attributes["from_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_port is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	fromPortVal, ok := fromPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_port expected to be basetypes.Int64Value, was: %T`, fromPortAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	remoteGroupAttribute, ok := attributes["remote_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupVal, ok := remoteGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group expected to be basetypes.StringValue, was: %T`, remoteGroupAttribute))
	}

	remoteGroupNameAttribute, ok := attributes["remote_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_name is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupNameVal, ok := remoteGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_name expected to be basetypes.StringValue, was: %T`, remoteGroupNameAttribute))
	}

	remoteGroupUuidAttribute, ok := attributes["remote_group_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_uuid is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupUuidVal, ok := remoteGroupUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_uuid expected to be basetypes.StringValue, was: %T`, remoteGroupUuidAttribute))
	}

	toPortAttribute, ok := attributes["to_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_port is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	toPortVal, ok := toPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_port expected to be basetypes.Int64Value, was: %T`, toPortAttribute))
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	return RulesValue{
		Cidr:            cidrVal,
		Description:     descriptionVal,
		Direction:       directionVal,
		Ethertype:       ethertypeVal,
		FromPort:        fromPortVal,
		Id:              idVal,
		RemoteGroup:     remoteGroupVal,
		RemoteGroupName: remoteGroupNameVal,
		RemoteGroupUuid: remoteGroupUuidVal,
		ToPort:          toPortVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RulesValue {
	object, diags := NewRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRulesValueMust(RulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RulesType) ValueType(ctx context.Context) attr.Value {
	return RulesValue{}
}

var _ basetypes.ObjectValuable = RulesValue{}

type RulesValue struct {
	Cidr            basetypes.StringValue `tfsdk:"cidr"`
	Description     basetypes.StringValue `tfsdk:"description"`
	Direction       basetypes.StringValue `tfsdk:"direction"`
	Ethertype       basetypes.StringValue `tfsdk:"ethertype"`
	FromPort        basetypes.Int64Value  `tfsdk:"from_port"`
	Id              basetypes.Int64Value  `tfsdk:"id"`
	RemoteGroup     basetypes.StringValue `tfsdk:"remote_group"`
	RemoteGroupName basetypes.StringValue `tfsdk:"remote_group_name"`
	RemoteGroupUuid basetypes.StringValue `tfsdk:"remote_group_uuid"`
	ToPort          basetypes.Int64Value  `tfsdk:"to_port"`
	state           attr.ValueState
}

func (v RulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ethertype"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_group_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_group_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Ethertype.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethertype"] = val

		val, err = v.FromPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_port"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.RemoteGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group"] = val

		val, err = v.RemoteGroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group_name"] = val

		val, err = v.RemoteGroupUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group_uuid"] = val

		val, err = v.ToPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RulesValue) String() string {
	return "RulesValue"
}

func (v RulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cidr":              basetypes.StringType{},
		"description":       basetypes.StringType{},
		"direction":         basetypes.StringType{},
		"ethertype":         basetypes.StringType{},
		"from_port":         basetypes.Int64Type{},
		"id":                basetypes.Int64Type{},
		"remote_group":      basetypes.StringType{},
		"remote_group_name": basetypes.StringType{},
		"remote_group_uuid": basetypes.StringType{},
		"to_port":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cidr":              v.Cidr,
			"description":       v.Description,
			"direction":         v.Direction,
			"ethertype":         v.Ethertype,
			"from_port":         v.FromPort,
			"id":                v.Id,
			"remote_group":      v.RemoteGroup,
			"remote_group_name": v.RemoteGroupName,
			"remote_group_uuid": v.RemoteGroupUuid,
			"to_port":           v.ToPort,
		})

	return objVal, diags
}

func (v RulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Ethertype.Equal(other.Ethertype) {
		return false
	}

	if !v.FromPort.Equal(other.FromPort) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.RemoteGroup.Equal(other.RemoteGroup) {
		return false
	}

	if !v.RemoteGroupName.Equal(other.RemoteGroupName) {
		return false
	}

	if !v.RemoteGroupUuid.Equal(other.RemoteGroupUuid) {
		return false
	}

	if !v.ToPort.Equal(other.ToPort) {
		return false
	}

	return true
}

func (v RulesValue) Type(ctx context.Context) attr.Type {
	return RulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":              basetypes.StringType{},
		"description":       basetypes.StringType{},
		"direction":         basetypes.StringType{},
		"ethertype":         basetypes.StringType{},
		"from_port":         basetypes.Int64Type{},
		"id":                basetypes.Int64Type{},
		"remote_group":      basetypes.StringType{},
		"remote_group_name": basetypes.StringType{},
		"remote_group_uuid": basetypes.StringType{},
		"to_port":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = InstanceSecurityGroupsType{}

type InstanceSecurityGroupsType struct {
	basetypes.ObjectType
}

func (t InstanceSecurityGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(InstanceSecurityGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InstanceSecurityGroupsType) String() string {
	return "InstanceSecurityGroupsType"
}

func (t InstanceSecurityGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InstanceSecurityGroupsValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewInstanceSecurityGroupsValueNull() InstanceSecurityGroupsValue {
	return InstanceSecurityGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewInstanceSecurityGroupsValueUnknown() InstanceSecurityGroupsValue {
	return InstanceSecurityGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInstanceSecurityGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InstanceSecurityGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InstanceSecurityGroupsValue Attribute Value",
				"While creating a InstanceSecurityGroupsValue value, a missing attribute value was detected. "+
					"A InstanceSecurityGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSecurityGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InstanceSecurityGroupsValue Attribute Type",
				"While creating a InstanceSecurityGroupsValue value, an invalid attribute value was detected. "+
					"A InstanceSecurityGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InstanceSecurityGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InstanceSecurityGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InstanceSecurityGroupsValue Attribute Value",
				"While creating a InstanceSecurityGroupsValue value, an extra attribute value was detected. "+
					"A InstanceSecurityGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InstanceSecurityGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInstanceSecurityGroupsValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewInstanceSecurityGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewInstanceSecurityGroupsValueUnknown(), diags
	}

	return InstanceSecurityGroupsValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewInstanceSecurityGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InstanceSecurityGroupsValue {
	object, diags := NewInstanceSecurityGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInstanceSecurityGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InstanceSecurityGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInstanceSecurityGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInstanceSecurityGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInstanceSecurityGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInstanceSecurityGroupsValueMust(InstanceSecurityGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InstanceSecurityGroupsType) ValueType(ctx context.Context) attr.Value {
	return InstanceSecurityGroupsValue{}
}

var _ basetypes.ObjectValuable = InstanceSecurityGroupsValue{}

type InstanceSecurityGroupsValue struct {
	Url   basetypes.StringValue `tfsdk:"url"`
	state attr.ValueState
}

func (v InstanceSecurityGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InstanceSecurityGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InstanceSecurityGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InstanceSecurityGroupsValue) String() string {
	return "InstanceSecurityGroupsValue"
}

func (v InstanceSecurityGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v InstanceSecurityGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(InstanceSecurityGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v InstanceSecurityGroupsValue) Type(ctx context.Context) attr.Type {
	return InstanceSecurityGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InstanceSecurityGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RestorationsType{}

type RestorationsType struct {
	basetypes.ObjectType
}

func (t RestorationsType) Equal(o attr.Type) bool {
	other, ok := o.(RestorationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RestorationsType) String() string {
	return "RestorationsType"
}

func (t RestorationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	flavorAttribute, ok := attributes["flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor is missing from object`)

		return nil, diags
	}

	flavorVal, ok := flavorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor expected to be basetypes.StringValue, was: %T`, flavorAttribute))
	}

	floatingIpsAttribute, ok := attributes["floating_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ips is missing from object`)

		return nil, diags
	}

	floatingIpsVal, ok := floatingIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ips expected to be basetypes.ListValue, was: %T`, floatingIpsAttribute))
	}

	instanceAttribute, ok := attributes["instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance is missing from object`)

		return nil, diags
	}

	instanceVal, ok := instanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance expected to be basetypes.StringValue, was: %T`, instanceAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return nil, diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RestorationsValue{
		Created:        createdVal,
		Flavor:         flavorVal,
		FloatingIps:    floatingIpsVal,
		Instance:       instanceVal,
		Name:           nameVal,
		Ports:          portsVal,
		SecurityGroups: securityGroupsVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRestorationsValueNull() RestorationsValue {
	return RestorationsValue{
		state: attr.ValueStateNull,
	}
}

func NewRestorationsValueUnknown() RestorationsValue {
	return RestorationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRestorationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RestorationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RestorationsValue Attribute Value",
				"While creating a RestorationsValue value, a missing attribute value was detected. "+
					"A RestorationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RestorationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RestorationsValue Attribute Type",
				"While creating a RestorationsValue value, an invalid attribute value was detected. "+
					"A RestorationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RestorationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RestorationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RestorationsValue Attribute Value",
				"While creating a RestorationsValue value, an extra attribute value was detected. "+
					"A RestorationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RestorationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRestorationsValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewRestorationsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	flavorAttribute, ok := attributes["flavor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavor is missing from object`)

		return NewRestorationsValueUnknown(), diags
	}

	flavorVal, ok := flavorAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavor expected to be basetypes.StringValue, was: %T`, flavorAttribute))
	}

	floatingIpsAttribute, ok := attributes["floating_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`floating_ips is missing from object`)

		return NewRestorationsValueUnknown(), diags
	}

	floatingIpsVal, ok := floatingIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`floating_ips expected to be basetypes.ListValue, was: %T`, floatingIpsAttribute))
	}

	instanceAttribute, ok := attributes["instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`instance is missing from object`)

		return NewRestorationsValueUnknown(), diags
	}

	instanceVal, ok := instanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`instance expected to be basetypes.StringValue, was: %T`, instanceAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRestorationsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portsAttribute, ok := attributes["ports"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ports is missing from object`)

		return NewRestorationsValueUnknown(), diags
	}

	portsVal, ok := portsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ports expected to be basetypes.ListValue, was: %T`, portsAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewRestorationsValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewRestorationsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewRestorationsValueUnknown(), diags
	}

	return RestorationsValue{
		Created:        createdVal,
		Flavor:         flavorVal,
		FloatingIps:    floatingIpsVal,
		Instance:       instanceVal,
		Name:           nameVal,
		Ports:          portsVal,
		SecurityGroups: securityGroupsVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewRestorationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RestorationsValue {
	object, diags := NewRestorationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRestorationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RestorationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRestorationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRestorationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRestorationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRestorationsValueMust(RestorationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RestorationsType) ValueType(ctx context.Context) attr.Value {
	return RestorationsValue{}
}

var _ basetypes.ObjectValuable = RestorationsValue{}

type RestorationsValue struct {
	Created        basetypes.StringValue `tfsdk:"created"`
	Flavor         basetypes.StringValue `tfsdk:"flavor"`
	FloatingIps    basetypes.ListValue   `tfsdk:"floating_ips"`
	Instance       basetypes.StringValue `tfsdk:"instance"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Ports          basetypes.ListValue   `tfsdk:"ports"`
	SecurityGroups basetypes.ListValue   `tfsdk:"security_groups"`
	Uuid           basetypes.StringValue `tfsdk:"uuid"`
	state          attr.ValueState
}

func (v RestorationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["flavor"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["floating_ips"] = basetypes.ListType{
		ElemType: FloatingIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ports"] = basetypes.ListType{
		ElemType: PortsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Flavor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flavor"] = val

		val, err = v.FloatingIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["floating_ips"] = val

		val, err = v.Instance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["instance"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Ports.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ports"] = val

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RestorationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RestorationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RestorationsValue) String() string {
	return "RestorationsValue"
}

func (v RestorationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	floatingIps := types.ListValueMust(
		FloatingIpsType{
			basetypes.ObjectType{
				AttrTypes: FloatingIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.FloatingIps.Elements(),
	)

	if v.FloatingIps.IsNull() {
		floatingIps = types.ListNull(
			FloatingIpsType{
				basetypes.ObjectType{
					AttrTypes: FloatingIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FloatingIps.IsUnknown() {
		floatingIps = types.ListUnknown(
			FloatingIpsType{
				basetypes.ObjectType{
					AttrTypes: FloatingIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ports := types.ListValueMust(
		PortsType{
			basetypes.ObjectType{
				AttrTypes: PortsValue{}.AttributeTypes(ctx),
			},
		},
		v.Ports.Elements(),
	)

	if v.Ports.IsNull() {
		ports = types.ListNull(
			PortsType{
				basetypes.ObjectType{
					AttrTypes: PortsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ports.IsUnknown() {
		ports = types.ListUnknown(
			PortsType{
				basetypes.ObjectType{
					AttrTypes: PortsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroups := types.ListValueMust(
		SecurityGroupsType{
			basetypes.ObjectType{
				AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups.Elements(),
	)

	if v.SecurityGroups.IsNull() {
		securityGroups = types.ListNull(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups.IsUnknown() {
		securityGroups = types.ListUnknown(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"created": basetypes.StringType{},
		"flavor":  basetypes.StringType{},
		"floating_ips": basetypes.ListType{
			ElemType: FloatingIpsValue{}.Type(ctx),
		},
		"instance": basetypes.StringType{},
		"name":     basetypes.StringType{},
		"ports": basetypes.ListType{
			ElemType: PortsValue{}.Type(ctx),
		},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created":         v.Created,
			"flavor":          v.Flavor,
			"floating_ips":    floatingIps,
			"instance":        v.Instance,
			"name":            v.Name,
			"ports":           ports,
			"security_groups": securityGroups,
			"uuid":            v.Uuid,
		})

	return objVal, diags
}

func (v RestorationsValue) Equal(o attr.Value) bool {
	other, ok := o.(RestorationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Flavor.Equal(other.Flavor) {
		return false
	}

	if !v.FloatingIps.Equal(other.FloatingIps) {
		return false
	}

	if !v.Instance.Equal(other.Instance) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Ports.Equal(other.Ports) {
		return false
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v RestorationsValue) Type(ctx context.Context) attr.Type {
	return RestorationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RestorationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.StringType{},
		"flavor":  basetypes.StringType{},
		"floating_ips": basetypes.ListType{
			ElemType: FloatingIpsValue{}.Type(ctx),
		},
		"instance": basetypes.StringType{},
		"name":     basetypes.StringType{},
		"ports": basetypes.ListType{
			ElemType: PortsValue{}.Type(ctx),
		},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FloatingIpsType{}

type FloatingIpsType struct {
	basetypes.ObjectType
}

func (t FloatingIpsType) Equal(o attr.Type) bool {
	other, ok := o.(FloatingIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FloatingIpsType) String() string {
	return "FloatingIpsType"
}

func (t FloatingIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	portFixedIpsAttribute, ok := attributes["port_fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_fixed_ips is missing from object`)

		return nil, diags
	}

	portFixedIpsVal, ok := portFixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_fixed_ips expected to be basetypes.ListValue, was: %T`, portFixedIpsAttribute))
	}

	portMacAddressAttribute, ok := attributes["port_mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mac_address is missing from object`)

		return nil, diags
	}

	portMacAddressVal, ok := portMacAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mac_address expected to be basetypes.StringValue, was: %T`, portMacAddressAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return nil, diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return nil, diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return nil, diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FloatingIpsValue{
		Address:           addressVal,
		PortFixedIps:      portFixedIpsVal,
		PortMacAddress:    portMacAddressVal,
		Subnet:            subnetVal,
		SubnetCidr:        subnetCidrVal,
		SubnetDescription: subnetDescriptionVal,
		SubnetName:        subnetNameVal,
		SubnetUuid:        subnetUuidVal,
		Url:               urlVal,
		Uuid:              uuidVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewFloatingIpsValueNull() FloatingIpsValue {
	return FloatingIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewFloatingIpsValueUnknown() FloatingIpsValue {
	return FloatingIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFloatingIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FloatingIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FloatingIpsValue Attribute Value",
				"While creating a FloatingIpsValue value, a missing attribute value was detected. "+
					"A FloatingIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FloatingIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FloatingIpsValue Attribute Type",
				"While creating a FloatingIpsValue value, an invalid attribute value was detected. "+
					"A FloatingIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FloatingIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FloatingIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FloatingIpsValue Attribute Value",
				"While creating a FloatingIpsValue value, an extra attribute value was detected. "+
					"A FloatingIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FloatingIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFloatingIpsValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	portFixedIpsAttribute, ok := attributes["port_fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_fixed_ips is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	portFixedIpsVal, ok := portFixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_fixed_ips expected to be basetypes.ListValue, was: %T`, portFixedIpsAttribute))
	}

	portMacAddressAttribute, ok := attributes["port_mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port_mac_address is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	portMacAddressVal, ok := portMacAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port_mac_address expected to be basetypes.StringValue, was: %T`, portMacAddressAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewFloatingIpsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewFloatingIpsValueUnknown(), diags
	}

	return FloatingIpsValue{
		Address:           addressVal,
		PortFixedIps:      portFixedIpsVal,
		PortMacAddress:    portMacAddressVal,
		Subnet:            subnetVal,
		SubnetCidr:        subnetCidrVal,
		SubnetDescription: subnetDescriptionVal,
		SubnetName:        subnetNameVal,
		SubnetUuid:        subnetUuidVal,
		Url:               urlVal,
		Uuid:              uuidVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewFloatingIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FloatingIpsValue {
	object, diags := NewFloatingIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFloatingIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FloatingIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFloatingIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFloatingIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFloatingIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFloatingIpsValueMust(FloatingIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FloatingIpsType) ValueType(ctx context.Context) attr.Value {
	return FloatingIpsValue{}
}

var _ basetypes.ObjectValuable = FloatingIpsValue{}

type FloatingIpsValue struct {
	Address           basetypes.StringValue `tfsdk:"address"`
	PortFixedIps      basetypes.ListValue   `tfsdk:"port_fixed_ips"`
	PortMacAddress    basetypes.StringValue `tfsdk:"port_mac_address"`
	Subnet            basetypes.StringValue `tfsdk:"subnet"`
	SubnetCidr        basetypes.StringValue `tfsdk:"subnet_cidr"`
	SubnetDescription basetypes.StringValue `tfsdk:"subnet_description"`
	SubnetName        basetypes.StringValue `tfsdk:"subnet_name"`
	SubnetUuid        basetypes.StringValue `tfsdk:"subnet_uuid"`
	Url               basetypes.StringValue `tfsdk:"url"`
	Uuid              basetypes.StringValue `tfsdk:"uuid"`
	state             attr.ValueState
}

func (v FloatingIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port_fixed_ips"] = basetypes.ListType{
		ElemType: PortFixedIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["port_mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.PortFixedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_fixed_ips"] = val

		val, err = v.PortMacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port_mac_address"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.SubnetDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_description"] = val

		val, err = v.SubnetName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_name"] = val

		val, err = v.SubnetUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FloatingIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FloatingIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FloatingIpsValue) String() string {
	return "FloatingIpsValue"
}

func (v FloatingIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	portFixedIps := types.ListValueMust(
		PortFixedIpsType{
			basetypes.ObjectType{
				AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.PortFixedIps.Elements(),
	)

	if v.PortFixedIps.IsNull() {
		portFixedIps = types.ListNull(
			PortFixedIpsType{
				basetypes.ObjectType{
					AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PortFixedIps.IsUnknown() {
		portFixedIps = types.ListUnknown(
			PortFixedIpsType{
				basetypes.ObjectType{
					AttrTypes: PortFixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"address": basetypes.StringType{},
		"port_fixed_ips": basetypes.ListType{
			ElemType: PortFixedIpsValue{}.Type(ctx),
		},
		"port_mac_address":   basetypes.StringType{},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
		"uuid":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":            v.Address,
			"port_fixed_ips":     portFixedIps,
			"port_mac_address":   v.PortMacAddress,
			"subnet":             v.Subnet,
			"subnet_cidr":        v.SubnetCidr,
			"subnet_description": v.SubnetDescription,
			"subnet_name":        v.SubnetName,
			"subnet_uuid":        v.SubnetUuid,
			"url":                v.Url,
			"uuid":               v.Uuid,
		})

	return objVal, diags
}

func (v FloatingIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(FloatingIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.PortFixedIps.Equal(other.PortFixedIps) {
		return false
	}

	if !v.PortMacAddress.Equal(other.PortMacAddress) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.SubnetDescription.Equal(other.SubnetDescription) {
		return false
	}

	if !v.SubnetName.Equal(other.SubnetName) {
		return false
	}

	if !v.SubnetUuid.Equal(other.SubnetUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v FloatingIpsValue) Type(ctx context.Context) attr.Type {
	return FloatingIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FloatingIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address": basetypes.StringType{},
		"port_fixed_ips": basetypes.ListType{
			ElemType: PortFixedIpsValue{}.Type(ctx),
		},
		"port_mac_address":   basetypes.StringType{},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
		"uuid":               basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortFixedIpsType{}

type PortFixedIpsType struct {
	basetypes.ObjectType
}

func (t PortFixedIpsType) Equal(o attr.Type) bool {
	other, ok := o.(PortFixedIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortFixedIpsType) String() string {
	return "PortFixedIpsType"
}

func (t PortFixedIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortFixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPortFixedIpsValueNull() PortFixedIpsValue {
	return PortFixedIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortFixedIpsValueUnknown() PortFixedIpsValue {
	return PortFixedIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortFixedIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortFixedIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortFixedIpsValue Attribute Value",
				"While creating a PortFixedIpsValue value, a missing attribute value was detected. "+
					"A PortFixedIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortFixedIpsValue Attribute Type",
				"While creating a PortFixedIpsValue value, an invalid attribute value was detected. "+
					"A PortFixedIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortFixedIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortFixedIpsValue Attribute Value",
				"While creating a PortFixedIpsValue value, an extra attribute value was detected. "+
					"A PortFixedIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortFixedIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortFixedIpsValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewPortFixedIpsValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewPortFixedIpsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewPortFixedIpsValueUnknown(), diags
	}

	return PortFixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewPortFixedIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortFixedIpsValue {
	object, diags := NewPortFixedIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortFixedIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortFixedIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortFixedIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortFixedIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortFixedIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortFixedIpsValueMust(PortFixedIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortFixedIpsType) ValueType(ctx context.Context) attr.Value {
	return PortFixedIpsValue{}
}

var _ basetypes.ObjectValuable = PortFixedIpsValue{}

type PortFixedIpsValue struct {
	IpAddress basetypes.StringValue `tfsdk:"ip_address"`
	SubnetId  basetypes.StringValue `tfsdk:"subnet_id"`
	state     attr.ValueState
}

func (v PortFixedIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortFixedIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortFixedIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortFixedIpsValue) String() string {
	return "PortFixedIpsValue"
}

func (v PortFixedIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address": v.IpAddress,
			"subnet_id":  v.SubnetId,
		})

	return objVal, diags
}

func (v PortFixedIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortFixedIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v PortFixedIpsValue) Type(ctx context.Context) attr.Type {
	return PortFixedIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortFixedIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PortsType{}

type PortsType struct {
	basetypes.ObjectType
}

func (t PortsType) Equal(o attr.Type) bool {
	other, ok := o.(PortsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortsType) String() string {
	return "PortsType"
}

func (t PortsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowedAddressPairsAttribute, ok := attributes["allowed_address_pairs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_address_pairs is missing from object`)

		return nil, diags
	}

	allowedAddressPairsVal, ok := allowedAddressPairsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_address_pairs expected to be basetypes.ListValue, was: %T`, allowedAddressPairsAttribute))
	}

	deviceIdAttribute, ok := attributes["device_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_id is missing from object`)

		return nil, diags
	}

	deviceIdVal, ok := deviceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_id expected to be basetypes.StringValue, was: %T`, deviceIdAttribute))
	}

	deviceOwnerAttribute, ok := attributes["device_owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_owner is missing from object`)

		return nil, diags
	}

	deviceOwnerVal, ok := deviceOwnerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_owner expected to be basetypes.StringValue, was: %T`, deviceOwnerAttribute))
	}

	fixedIpsAttribute, ok := attributes["fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ips is missing from object`)

		return nil, diags
	}

	fixedIpsVal, ok := fixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ips expected to be basetypes.ListValue, was: %T`, fixedIpsAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return nil, diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return nil, diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return nil, diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return nil, diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return nil, diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return nil, diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortsValue{
		AllowedAddressPairs: allowedAddressPairsVal,
		DeviceId:            deviceIdVal,
		DeviceOwner:         deviceOwnerVal,
		FixedIps:            fixedIpsVal,
		MacAddress:          macAddressVal,
		SecurityGroups:      securityGroupsVal,
		Subnet:              subnetVal,
		SubnetCidr:          subnetCidrVal,
		SubnetDescription:   subnetDescriptionVal,
		SubnetName:          subnetNameVal,
		SubnetUuid:          subnetUuidVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPortsValueNull() PortsValue {
	return PortsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortsValueUnknown() PortsValue {
	return PortsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortsValue Attribute Value",
				"While creating a PortsValue value, a missing attribute value was detected. "+
					"A PortsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortsValue Attribute Type",
				"While creating a PortsValue value, an invalid attribute value was detected. "+
					"A PortsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortsValue Attribute Value",
				"While creating a PortsValue value, an extra attribute value was detected. "+
					"A PortsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	allowedAddressPairsAttribute, ok := attributes["allowed_address_pairs"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_address_pairs is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	allowedAddressPairsVal, ok := allowedAddressPairsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_address_pairs expected to be basetypes.ListValue, was: %T`, allowedAddressPairsAttribute))
	}

	deviceIdAttribute, ok := attributes["device_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_id is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	deviceIdVal, ok := deviceIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_id expected to be basetypes.StringValue, was: %T`, deviceIdAttribute))
	}

	deviceOwnerAttribute, ok := attributes["device_owner"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`device_owner is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	deviceOwnerVal, ok := deviceOwnerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`device_owner expected to be basetypes.StringValue, was: %T`, deviceOwnerAttribute))
	}

	fixedIpsAttribute, ok := attributes["fixed_ips"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`fixed_ips is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	fixedIpsVal, ok := fixedIpsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`fixed_ips expected to be basetypes.ListValue, was: %T`, fixedIpsAttribute))
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	securityGroupsAttribute, ok := attributes["security_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`security_groups is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	securityGroupsVal, ok := securityGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`security_groups expected to be basetypes.ListValue, was: %T`, securityGroupsAttribute))
	}

	subnetAttribute, ok := attributes["subnet"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetVal, ok := subnetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet expected to be basetypes.StringValue, was: %T`, subnetAttribute))
	}

	subnetCidrAttribute, ok := attributes["subnet_cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_cidr is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetCidrVal, ok := subnetCidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_cidr expected to be basetypes.StringValue, was: %T`, subnetCidrAttribute))
	}

	subnetDescriptionAttribute, ok := attributes["subnet_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_description is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetDescriptionVal, ok := subnetDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_description expected to be basetypes.StringValue, was: %T`, subnetDescriptionAttribute))
	}

	subnetNameAttribute, ok := attributes["subnet_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_name is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetNameVal, ok := subnetNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_name expected to be basetypes.StringValue, was: %T`, subnetNameAttribute))
	}

	subnetUuidAttribute, ok := attributes["subnet_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_uuid is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	subnetUuidVal, ok := subnetUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_uuid expected to be basetypes.StringValue, was: %T`, subnetUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	return PortsValue{
		AllowedAddressPairs: allowedAddressPairsVal,
		DeviceId:            deviceIdVal,
		DeviceOwner:         deviceOwnerVal,
		FixedIps:            fixedIpsVal,
		MacAddress:          macAddressVal,
		SecurityGroups:      securityGroupsVal,
		Subnet:              subnetVal,
		SubnetCidr:          subnetCidrVal,
		SubnetDescription:   subnetDescriptionVal,
		SubnetName:          subnetNameVal,
		SubnetUuid:          subnetUuidVal,
		Url:                 urlVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPortsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortsValue {
	object, diags := NewPortsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortsValueMust(PortsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortsType) ValueType(ctx context.Context) attr.Value {
	return PortsValue{}
}

var _ basetypes.ObjectValuable = PortsValue{}

type PortsValue struct {
	AllowedAddressPairs basetypes.ListValue   `tfsdk:"allowed_address_pairs"`
	DeviceId            basetypes.StringValue `tfsdk:"device_id"`
	DeviceOwner         basetypes.StringValue `tfsdk:"device_owner"`
	FixedIps            basetypes.ListValue   `tfsdk:"fixed_ips"`
	MacAddress          basetypes.StringValue `tfsdk:"mac_address"`
	SecurityGroups      basetypes.ListValue   `tfsdk:"security_groups"`
	Subnet              basetypes.StringValue `tfsdk:"subnet"`
	SubnetCidr          basetypes.StringValue `tfsdk:"subnet_cidr"`
	SubnetDescription   basetypes.StringValue `tfsdk:"subnet_description"`
	SubnetName          basetypes.StringValue `tfsdk:"subnet_name"`
	SubnetUuid          basetypes.StringValue `tfsdk:"subnet_uuid"`
	Url                 basetypes.StringValue `tfsdk:"url"`
	state               attr.ValueState
}

func (v PortsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 12)

	var val tftypes.Value
	var err error

	attrTypes["allowed_address_pairs"] = basetypes.ListType{
		ElemType: AllowedAddressPairsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["device_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["device_owner"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["fixed_ips"] = basetypes.ListType{
		ElemType: FixedIpsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["security_groups"] = basetypes.ListType{
		ElemType: SecurityGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["subnet"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 12)

		val, err = v.AllowedAddressPairs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_address_pairs"] = val

		val, err = v.DeviceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_id"] = val

		val, err = v.DeviceOwner.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["device_owner"] = val

		val, err = v.FixedIps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["fixed_ips"] = val

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		val, err = v.SecurityGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["security_groups"] = val

		val, err = v.Subnet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet"] = val

		val, err = v.SubnetCidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_cidr"] = val

		val, err = v.SubnetDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_description"] = val

		val, err = v.SubnetName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_name"] = val

		val, err = v.SubnetUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortsValue) String() string {
	return "PortsValue"
}

func (v PortsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	allowedAddressPairs := types.ListValueMust(
		AllowedAddressPairsType{
			basetypes.ObjectType{
				AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
			},
		},
		v.AllowedAddressPairs.Elements(),
	)

	if v.AllowedAddressPairs.IsNull() {
		allowedAddressPairs = types.ListNull(
			AllowedAddressPairsType{
				basetypes.ObjectType{
					AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.AllowedAddressPairs.IsUnknown() {
		allowedAddressPairs = types.ListUnknown(
			AllowedAddressPairsType{
				basetypes.ObjectType{
					AttrTypes: AllowedAddressPairsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	fixedIps := types.ListValueMust(
		FixedIpsType{
			basetypes.ObjectType{
				AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
			},
		},
		v.FixedIps.Elements(),
	)

	if v.FixedIps.IsNull() {
		fixedIps = types.ListNull(
			FixedIpsType{
				basetypes.ObjectType{
					AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FixedIps.IsUnknown() {
		fixedIps = types.ListUnknown(
			FixedIpsType{
				basetypes.ObjectType{
					AttrTypes: FixedIpsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	securityGroups := types.ListValueMust(
		SecurityGroupsType{
			basetypes.ObjectType{
				AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.SecurityGroups.Elements(),
	)

	if v.SecurityGroups.IsNull() {
		securityGroups = types.ListNull(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SecurityGroups.IsUnknown() {
		securityGroups = types.ListUnknown(
			SecurityGroupsType{
				basetypes.ObjectType{
					AttrTypes: SecurityGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"allowed_address_pairs": basetypes.ListType{
			ElemType: AllowedAddressPairsValue{}.Type(ctx),
		},
		"device_id":    basetypes.StringType{},
		"device_owner": basetypes.StringType{},
		"fixed_ips": basetypes.ListType{
			ElemType: FixedIpsValue{}.Type(ctx),
		},
		"mac_address": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allowed_address_pairs": allowedAddressPairs,
			"device_id":             v.DeviceId,
			"device_owner":          v.DeviceOwner,
			"fixed_ips":             fixedIps,
			"mac_address":           v.MacAddress,
			"security_groups":       securityGroups,
			"subnet":                v.Subnet,
			"subnet_cidr":           v.SubnetCidr,
			"subnet_description":    v.SubnetDescription,
			"subnet_name":           v.SubnetName,
			"subnet_uuid":           v.SubnetUuid,
			"url":                   v.Url,
		})

	return objVal, diags
}

func (v PortsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowedAddressPairs.Equal(other.AllowedAddressPairs) {
		return false
	}

	if !v.DeviceId.Equal(other.DeviceId) {
		return false
	}

	if !v.DeviceOwner.Equal(other.DeviceOwner) {
		return false
	}

	if !v.FixedIps.Equal(other.FixedIps) {
		return false
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	if !v.SecurityGroups.Equal(other.SecurityGroups) {
		return false
	}

	if !v.Subnet.Equal(other.Subnet) {
		return false
	}

	if !v.SubnetCidr.Equal(other.SubnetCidr) {
		return false
	}

	if !v.SubnetDescription.Equal(other.SubnetDescription) {
		return false
	}

	if !v.SubnetName.Equal(other.SubnetName) {
		return false
	}

	if !v.SubnetUuid.Equal(other.SubnetUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v PortsValue) Type(ctx context.Context) attr.Type {
	return PortsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allowed_address_pairs": basetypes.ListType{
			ElemType: AllowedAddressPairsValue{}.Type(ctx),
		},
		"device_id":    basetypes.StringType{},
		"device_owner": basetypes.StringType{},
		"fixed_ips": basetypes.ListType{
			ElemType: FixedIpsValue{}.Type(ctx),
		},
		"mac_address": basetypes.StringType{},
		"security_groups": basetypes.ListType{
			ElemType: SecurityGroupsValue{}.Type(ctx),
		},
		"subnet":             basetypes.StringType{},
		"subnet_cidr":        basetypes.StringType{},
		"subnet_description": basetypes.StringType{},
		"subnet_name":        basetypes.StringType{},
		"subnet_uuid":        basetypes.StringType{},
		"url":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = AllowedAddressPairsType{}

type AllowedAddressPairsType struct {
	basetypes.ObjectType
}

func (t AllowedAddressPairsType) Equal(o attr.Type) bool {
	other, ok := o.(AllowedAddressPairsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AllowedAddressPairsType) String() string {
	return "AllowedAddressPairsType"
}

func (t AllowedAddressPairsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return nil, diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AllowedAddressPairsValue{
		MacAddress: macAddressVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAllowedAddressPairsValueNull() AllowedAddressPairsValue {
	return AllowedAddressPairsValue{
		state: attr.ValueStateNull,
	}
}

func NewAllowedAddressPairsValueUnknown() AllowedAddressPairsValue {
	return AllowedAddressPairsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAllowedAddressPairsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AllowedAddressPairsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AllowedAddressPairsValue Attribute Value",
				"While creating a AllowedAddressPairsValue value, a missing attribute value was detected. "+
					"A AllowedAddressPairsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AllowedAddressPairsValue Attribute Type",
				"While creating a AllowedAddressPairsValue value, an invalid attribute value was detected. "+
					"A AllowedAddressPairsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AllowedAddressPairsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AllowedAddressPairsValue Attribute Value",
				"While creating a AllowedAddressPairsValue value, an extra attribute value was detected. "+
					"A AllowedAddressPairsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AllowedAddressPairsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAllowedAddressPairsValueUnknown(), diags
	}

	macAddressAttribute, ok := attributes["mac_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_address is missing from object`)

		return NewAllowedAddressPairsValueUnknown(), diags
	}

	macAddressVal, ok := macAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_address expected to be basetypes.StringValue, was: %T`, macAddressAttribute))
	}

	if diags.HasError() {
		return NewAllowedAddressPairsValueUnknown(), diags
	}

	return AllowedAddressPairsValue{
		MacAddress: macAddressVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewAllowedAddressPairsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AllowedAddressPairsValue {
	object, diags := NewAllowedAddressPairsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAllowedAddressPairsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AllowedAddressPairsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAllowedAddressPairsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAllowedAddressPairsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAllowedAddressPairsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAllowedAddressPairsValueMust(AllowedAddressPairsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AllowedAddressPairsType) ValueType(ctx context.Context) attr.Value {
	return AllowedAddressPairsValue{}
}

var _ basetypes.ObjectValuable = AllowedAddressPairsValue{}

type AllowedAddressPairsValue struct {
	MacAddress basetypes.StringValue `tfsdk:"mac_address"`
	state      attr.ValueState
}

func (v AllowedAddressPairsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["mac_address"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.MacAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_address"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AllowedAddressPairsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AllowedAddressPairsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AllowedAddressPairsValue) String() string {
	return "AllowedAddressPairsValue"
}

func (v AllowedAddressPairsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"mac_address": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"mac_address": v.MacAddress,
		})

	return objVal, diags
}

func (v AllowedAddressPairsValue) Equal(o attr.Value) bool {
	other, ok := o.(AllowedAddressPairsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.MacAddress.Equal(other.MacAddress) {
		return false
	}

	return true
}

func (v AllowedAddressPairsValue) Type(ctx context.Context) attr.Type {
	return AllowedAddressPairsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AllowedAddressPairsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"mac_address": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FixedIpsType{}

type FixedIpsType struct {
	basetypes.ObjectType
}

func (t FixedIpsType) Equal(o attr.Type) bool {
	other, ok := o.(FixedIpsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FixedIpsType) String() string {
	return "FixedIpsType"
}

func (t FixedIpsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return nil, diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueNull() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateNull,
	}
}

func NewFixedIpsValueUnknown() FixedIpsValue {
	return FixedIpsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFixedIpsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FixedIpsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, a missing attribute value was detected. "+
					"A FixedIpsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FixedIpsValue Attribute Type",
				"While creating a FixedIpsValue value, an invalid attribute value was detected. "+
					"A FixedIpsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FixedIpsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FixedIpsValue Attribute Value",
				"While creating a FixedIpsValue value, an extra attribute value was detected. "+
					"A FixedIpsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FixedIpsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	subnetIdAttribute, ok := attributes["subnet_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`subnet_id is missing from object`)

		return NewFixedIpsValueUnknown(), diags
	}

	subnetIdVal, ok := subnetIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`subnet_id expected to be basetypes.StringValue, was: %T`, subnetIdAttribute))
	}

	if diags.HasError() {
		return NewFixedIpsValueUnknown(), diags
	}

	return FixedIpsValue{
		IpAddress: ipAddressVal,
		SubnetId:  subnetIdVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewFixedIpsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FixedIpsValue {
	object, diags := NewFixedIpsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFixedIpsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FixedIpsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFixedIpsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFixedIpsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFixedIpsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFixedIpsValueMust(FixedIpsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FixedIpsType) ValueType(ctx context.Context) attr.Value {
	return FixedIpsValue{}
}

var _ basetypes.ObjectValuable = FixedIpsValue{}

type FixedIpsValue struct {
	IpAddress basetypes.StringValue `tfsdk:"ip_address"`
	SubnetId  basetypes.StringValue `tfsdk:"subnet_id"`
	state     attr.ValueState
}

func (v FixedIpsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["subnet_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.SubnetId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["subnet_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FixedIpsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FixedIpsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FixedIpsValue) String() string {
	return "FixedIpsValue"
}

func (v FixedIpsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address": v.IpAddress,
			"subnet_id":  v.SubnetId,
		})

	return objVal, diags
}

func (v FixedIpsValue) Equal(o attr.Value) bool {
	other, ok := o.(FixedIpsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.SubnetId.Equal(other.SubnetId) {
		return false
	}

	return true
}

func (v FixedIpsValue) Type(ctx context.Context) attr.Type {
	return FixedIpsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FixedIpsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address": basetypes.StringType{},
		"subnet_id":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroupsType{}

type SecurityGroupsType struct {
	basetypes.ObjectType
}

func (t SecurityGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroupsType) String() string {
	return "SecurityGroupsType"
}

func (t SecurityGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return nil, diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return nil, diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return nil, diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerAbbreviationAttribute, ok := attributes["customer_abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_abbreviation is missing from object`)

		return nil, diags
	}

	customerAbbreviationVal, ok := customerAbbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_abbreviation expected to be basetypes.StringValue, was: %T`, customerAbbreviationAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return nil, diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerNativeNameAttribute, ok := attributes["customer_native_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_native_name is missing from object`)

		return nil, diags
	}

	customerNativeNameVal, ok := customerNativeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_native_name expected to be basetypes.StringValue, was: %T`, customerNativeNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return nil, diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	errorTracebackAttribute, ok := attributes["error_traceback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_traceback is missing from object`)

		return nil, diags
	}

	errorTracebackVal, ok := errorTracebackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_traceback expected to be basetypes.StringValue, was: %T`, errorTracebackAttribute))
	}

	isLimitBasedAttribute, ok := attributes["is_limit_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_limit_based is missing from object`)

		return nil, diags
	}

	isLimitBasedVal, ok := isLimitBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_limit_based expected to be basetypes.BoolValue, was: %T`, isLimitBasedAttribute))
	}

	isUsageBasedAttribute, ok := attributes["is_usage_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_usage_based is missing from object`)

		return nil, diags
	}

	isUsageBasedVal, ok := isUsageBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_usage_based expected to be basetypes.BoolValue, was: %T`, isUsageBasedAttribute))
	}

	marketplaceCategoryNameAttribute, ok := attributes["marketplace_category_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_name is missing from object`)

		return nil, diags
	}

	marketplaceCategoryNameVal, ok := marketplaceCategoryNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_name expected to be basetypes.StringValue, was: %T`, marketplaceCategoryNameAttribute))
	}

	marketplaceCategoryUuidAttribute, ok := attributes["marketplace_category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_uuid is missing from object`)

		return nil, diags
	}

	marketplaceCategoryUuidVal, ok := marketplaceCategoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_uuid expected to be basetypes.StringValue, was: %T`, marketplaceCategoryUuidAttribute))
	}

	marketplaceOfferingNameAttribute, ok := attributes["marketplace_offering_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_name is missing from object`)

		return nil, diags
	}

	marketplaceOfferingNameVal, ok := marketplaceOfferingNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_name expected to be basetypes.StringValue, was: %T`, marketplaceOfferingNameAttribute))
	}

	marketplaceOfferingUuidAttribute, ok := attributes["marketplace_offering_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_uuid is missing from object`)

		return nil, diags
	}

	marketplaceOfferingUuidVal, ok := marketplaceOfferingUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_uuid expected to be basetypes.StringValue, was: %T`, marketplaceOfferingUuidAttribute))
	}

	marketplacePlanUuidAttribute, ok := attributes["marketplace_plan_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_plan_uuid is missing from object`)

		return nil, diags
	}

	marketplacePlanUuidVal, ok := marketplacePlanUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_plan_uuid expected to be basetypes.StringValue, was: %T`, marketplacePlanUuidAttribute))
	}

	marketplaceResourceStateAttribute, ok := attributes["marketplace_resource_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_state is missing from object`)

		return nil, diags
	}

	marketplaceResourceStateVal, ok := marketplaceResourceStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_state expected to be basetypes.StringValue, was: %T`, marketplaceResourceStateAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return nil, diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	modifiedAttribute, ok := attributes["modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified is missing from object`)

		return nil, diags
	}

	modifiedVal, ok := modifiedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified expected to be basetypes.StringValue, was: %T`, modifiedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return nil, diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return nil, diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return nil, diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return nil, diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serviceNameAttribute, ok := attributes["service_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_name is missing from object`)

		return nil, diags
	}

	serviceNameVal, ok := serviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_name expected to be basetypes.StringValue, was: %T`, serviceNameAttribute))
	}

	serviceSettingsAttribute, ok := attributes["service_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings is missing from object`)

		return nil, diags
	}

	serviceSettingsVal, ok := serviceSettingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings expected to be basetypes.StringValue, was: %T`, serviceSettingsAttribute))
	}

	serviceSettingsErrorMessageAttribute, ok := attributes["service_settings_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_error_message is missing from object`)

		return nil, diags
	}

	serviceSettingsErrorMessageVal, ok := serviceSettingsErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_error_message expected to be basetypes.StringValue, was: %T`, serviceSettingsErrorMessageAttribute))
	}

	serviceSettingsStateAttribute, ok := attributes["service_settings_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_state is missing from object`)

		return nil, diags
	}

	serviceSettingsStateVal, ok := serviceSettingsStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_state expected to be basetypes.StringValue, was: %T`, serviceSettingsStateAttribute))
	}

	serviceSettingsUuidAttribute, ok := attributes["service_settings_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_uuid is missing from object`)

		return nil, diags
	}

	serviceSettingsUuidVal, ok := serviceSettingsUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_uuid expected to be basetypes.StringValue, was: %T`, serviceSettingsUuidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return nil, diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	tenantNameAttribute, ok := attributes["tenant_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_name is missing from object`)

		return nil, diags
	}

	tenantNameVal, ok := tenantNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_name expected to be basetypes.StringValue, was: %T`, tenantNameAttribute))
	}

	tenantUuidAttribute, ok := attributes["tenant_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_uuid is missing from object`)

		return nil, diags
	}

	tenantUuidVal, ok := tenantUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_uuid expected to be basetypes.StringValue, was: %T`, tenantUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroupsValue{
		AccessUrl:                   accessUrlVal,
		BackendId:                   backendIdVal,
		Created:                     createdVal,
		Customer:                    customerVal,
		CustomerAbbreviation:        customerAbbreviationVal,
		CustomerName:                customerNameVal,
		CustomerNativeName:          customerNativeNameVal,
		Description:                 descriptionVal,
		ErrorMessage:                errorMessageVal,
		ErrorTraceback:              errorTracebackVal,
		IsLimitBased:                isLimitBasedVal,
		IsUsageBased:                isUsageBasedVal,
		MarketplaceCategoryName:     marketplaceCategoryNameVal,
		MarketplaceCategoryUuid:     marketplaceCategoryUuidVal,
		MarketplaceOfferingName:     marketplaceOfferingNameVal,
		MarketplaceOfferingUuid:     marketplaceOfferingUuidVal,
		MarketplacePlanUuid:         marketplacePlanUuidVal,
		MarketplaceResourceState:    marketplaceResourceStateVal,
		MarketplaceResourceUuid:     marketplaceResourceUuidVal,
		Modified:                    modifiedVal,
		Name:                        nameVal,
		Project:                     projectVal,
		ProjectName:                 projectNameVal,
		ProjectUuid:                 projectUuidVal,
		ResourceType:                resourceTypeVal,
		Rules:                       rulesVal,
		ServiceName:                 serviceNameVal,
		ServiceSettings:             serviceSettingsVal,
		ServiceSettingsErrorMessage: serviceSettingsErrorMessageVal,
		ServiceSettingsState:        serviceSettingsStateVal,
		ServiceSettingsUuid:         serviceSettingsUuidVal,
		State:                       stateVal,
		Tenant:                      tenantVal,
		TenantName:                  tenantNameVal,
		TenantUuid:                  tenantUuidVal,
		Url:                         urlVal,
		Uuid:                        uuidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueNull() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroupsValueUnknown() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, a missing attribute value was detected. "+
					"A SecurityGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroupsValue Attribute Type",
				"While creating a SecurityGroupsValue value, an invalid attribute value was detected. "+
					"A SecurityGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, an extra attribute value was detected. "+
					"A SecurityGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerAbbreviationAttribute, ok := attributes["customer_abbreviation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_abbreviation is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerAbbreviationVal, ok := customerAbbreviationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_abbreviation expected to be basetypes.StringValue, was: %T`, customerAbbreviationAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerNativeNameAttribute, ok := attributes["customer_native_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_native_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	customerNativeNameVal, ok := customerNativeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_native_name expected to be basetypes.StringValue, was: %T`, customerNativeNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	errorMessageAttribute, ok := attributes["error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_message is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	errorMessageVal, ok := errorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_message expected to be basetypes.StringValue, was: %T`, errorMessageAttribute))
	}

	errorTracebackAttribute, ok := attributes["error_traceback"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`error_traceback is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	errorTracebackVal, ok := errorTracebackAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`error_traceback expected to be basetypes.StringValue, was: %T`, errorTracebackAttribute))
	}

	isLimitBasedAttribute, ok := attributes["is_limit_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_limit_based is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	isLimitBasedVal, ok := isLimitBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_limit_based expected to be basetypes.BoolValue, was: %T`, isLimitBasedAttribute))
	}

	isUsageBasedAttribute, ok := attributes["is_usage_based"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_usage_based is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	isUsageBasedVal, ok := isUsageBasedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_usage_based expected to be basetypes.BoolValue, was: %T`, isUsageBasedAttribute))
	}

	marketplaceCategoryNameAttribute, ok := attributes["marketplace_category_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceCategoryNameVal, ok := marketplaceCategoryNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_name expected to be basetypes.StringValue, was: %T`, marketplaceCategoryNameAttribute))
	}

	marketplaceCategoryUuidAttribute, ok := attributes["marketplace_category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_category_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceCategoryUuidVal, ok := marketplaceCategoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_category_uuid expected to be basetypes.StringValue, was: %T`, marketplaceCategoryUuidAttribute))
	}

	marketplaceOfferingNameAttribute, ok := attributes["marketplace_offering_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceOfferingNameVal, ok := marketplaceOfferingNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_name expected to be basetypes.StringValue, was: %T`, marketplaceOfferingNameAttribute))
	}

	marketplaceOfferingUuidAttribute, ok := attributes["marketplace_offering_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_offering_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceOfferingUuidVal, ok := marketplaceOfferingUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_offering_uuid expected to be basetypes.StringValue, was: %T`, marketplaceOfferingUuidAttribute))
	}

	marketplacePlanUuidAttribute, ok := attributes["marketplace_plan_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_plan_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplacePlanUuidVal, ok := marketplacePlanUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_plan_uuid expected to be basetypes.StringValue, was: %T`, marketplacePlanUuidAttribute))
	}

	marketplaceResourceStateAttribute, ok := attributes["marketplace_resource_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceResourceStateVal, ok := marketplaceResourceStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_state expected to be basetypes.StringValue, was: %T`, marketplaceResourceStateAttribute))
	}

	marketplaceResourceUuidAttribute, ok := attributes["marketplace_resource_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`marketplace_resource_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	marketplaceResourceUuidVal, ok := marketplaceResourceUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`marketplace_resource_uuid expected to be basetypes.StringValue, was: %T`, marketplaceResourceUuidAttribute))
	}

	modifiedAttribute, ok := attributes["modified"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`modified is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	modifiedVal, ok := modifiedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`modified expected to be basetypes.StringValue, was: %T`, modifiedAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	resourceTypeAttribute, ok := attributes["resource_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_type is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	resourceTypeVal, ok := resourceTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_type expected to be basetypes.StringValue, was: %T`, resourceTypeAttribute))
	}

	rulesAttribute, ok := attributes["rules"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rules is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	rulesVal, ok := rulesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rules expected to be basetypes.ListValue, was: %T`, rulesAttribute))
	}

	serviceNameAttribute, ok := attributes["service_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceNameVal, ok := serviceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_name expected to be basetypes.StringValue, was: %T`, serviceNameAttribute))
	}

	serviceSettingsAttribute, ok := attributes["service_settings"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsVal, ok := serviceSettingsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings expected to be basetypes.StringValue, was: %T`, serviceSettingsAttribute))
	}

	serviceSettingsErrorMessageAttribute, ok := attributes["service_settings_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_error_message is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsErrorMessageVal, ok := serviceSettingsErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_error_message expected to be basetypes.StringValue, was: %T`, serviceSettingsErrorMessageAttribute))
	}

	serviceSettingsStateAttribute, ok := attributes["service_settings_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsStateVal, ok := serviceSettingsStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_state expected to be basetypes.StringValue, was: %T`, serviceSettingsStateAttribute))
	}

	serviceSettingsUuidAttribute, ok := attributes["service_settings_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_settings_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	serviceSettingsUuidVal, ok := serviceSettingsUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_settings_uuid expected to be basetypes.StringValue, was: %T`, serviceSettingsUuidAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	tenantAttribute, ok := attributes["tenant"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantVal, ok := tenantAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant expected to be basetypes.StringValue, was: %T`, tenantAttribute))
	}

	tenantNameAttribute, ok := attributes["tenant_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_name is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantNameVal, ok := tenantNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_name expected to be basetypes.StringValue, was: %T`, tenantNameAttribute))
	}

	tenantUuidAttribute, ok := attributes["tenant_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tenant_uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	tenantUuidVal, ok := tenantUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tenant_uuid expected to be basetypes.StringValue, was: %T`, tenantUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	return SecurityGroupsValue{
		AccessUrl:                   accessUrlVal,
		BackendId:                   backendIdVal,
		Created:                     createdVal,
		Customer:                    customerVal,
		CustomerAbbreviation:        customerAbbreviationVal,
		CustomerName:                customerNameVal,
		CustomerNativeName:          customerNativeNameVal,
		Description:                 descriptionVal,
		ErrorMessage:                errorMessageVal,
		ErrorTraceback:              errorTracebackVal,
		IsLimitBased:                isLimitBasedVal,
		IsUsageBased:                isUsageBasedVal,
		MarketplaceCategoryName:     marketplaceCategoryNameVal,
		MarketplaceCategoryUuid:     marketplaceCategoryUuidVal,
		MarketplaceOfferingName:     marketplaceOfferingNameVal,
		MarketplaceOfferingUuid:     marketplaceOfferingUuidVal,
		MarketplacePlanUuid:         marketplacePlanUuidVal,
		MarketplaceResourceState:    marketplaceResourceStateVal,
		MarketplaceResourceUuid:     marketplaceResourceUuidVal,
		Modified:                    modifiedVal,
		Name:                        nameVal,
		Project:                     projectVal,
		ProjectName:                 projectNameVal,
		ProjectUuid:                 projectUuidVal,
		ResourceType:                resourceTypeVal,
		Rules:                       rulesVal,
		ServiceName:                 serviceNameVal,
		ServiceSettings:             serviceSettingsVal,
		ServiceSettingsErrorMessage: serviceSettingsErrorMessageVal,
		ServiceSettingsState:        serviceSettingsStateVal,
		ServiceSettingsUuid:         serviceSettingsUuidVal,
		State:                       stateVal,
		Tenant:                      tenantVal,
		TenantName:                  tenantNameVal,
		TenantUuid:                  tenantUuidVal,
		Url:                         urlVal,
		Uuid:                        uuidVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroupsValue {
	object, diags := NewSecurityGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroupsValueMust(SecurityGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroupsType) ValueType(ctx context.Context) attr.Value {
	return SecurityGroupsValue{}
}

var _ basetypes.ObjectValuable = SecurityGroupsValue{}

type SecurityGroupsValue struct {
	AccessUrl                   basetypes.StringValue `tfsdk:"access_url"`
	BackendId                   basetypes.StringValue `tfsdk:"backend_id"`
	Created                     basetypes.StringValue `tfsdk:"created"`
	Customer                    basetypes.StringValue `tfsdk:"customer"`
	CustomerAbbreviation        basetypes.StringValue `tfsdk:"customer_abbreviation"`
	CustomerName                basetypes.StringValue `tfsdk:"customer_name"`
	CustomerNativeName          basetypes.StringValue `tfsdk:"customer_native_name"`
	Description                 basetypes.StringValue `tfsdk:"description"`
	ErrorMessage                basetypes.StringValue `tfsdk:"error_message"`
	ErrorTraceback              basetypes.StringValue `tfsdk:"error_traceback"`
	IsLimitBased                basetypes.BoolValue   `tfsdk:"is_limit_based"`
	IsUsageBased                basetypes.BoolValue   `tfsdk:"is_usage_based"`
	MarketplaceCategoryName     basetypes.StringValue `tfsdk:"marketplace_category_name"`
	MarketplaceCategoryUuid     basetypes.StringValue `tfsdk:"marketplace_category_uuid"`
	MarketplaceOfferingName     basetypes.StringValue `tfsdk:"marketplace_offering_name"`
	MarketplaceOfferingUuid     basetypes.StringValue `tfsdk:"marketplace_offering_uuid"`
	MarketplacePlanUuid         basetypes.StringValue `tfsdk:"marketplace_plan_uuid"`
	MarketplaceResourceState    basetypes.StringValue `tfsdk:"marketplace_resource_state"`
	MarketplaceResourceUuid     basetypes.StringValue `tfsdk:"marketplace_resource_uuid"`
	Modified                    basetypes.StringValue `tfsdk:"modified"`
	Name                        basetypes.StringValue `tfsdk:"name"`
	Project                     basetypes.StringValue `tfsdk:"project"`
	ProjectName                 basetypes.StringValue `tfsdk:"project_name"`
	ProjectUuid                 basetypes.StringValue `tfsdk:"project_uuid"`
	ResourceType                basetypes.StringValue `tfsdk:"resource_type"`
	Rules                       basetypes.ListValue   `tfsdk:"rules"`
	ServiceName                 basetypes.StringValue `tfsdk:"service_name"`
	ServiceSettings             basetypes.StringValue `tfsdk:"service_settings"`
	ServiceSettingsErrorMessage basetypes.StringValue `tfsdk:"service_settings_error_message"`
	ServiceSettingsState        basetypes.StringValue `tfsdk:"service_settings_state"`
	ServiceSettingsUuid         basetypes.StringValue `tfsdk:"service_settings_uuid"`
	State                       basetypes.StringValue `tfsdk:"state"`
	Tenant                      basetypes.StringValue `tfsdk:"tenant"`
	TenantName                  basetypes.StringValue `tfsdk:"tenant_name"`
	TenantUuid                  basetypes.StringValue `tfsdk:"tenant_uuid"`
	Url                         basetypes.StringValue `tfsdk:"url"`
	Uuid                        basetypes.StringValue `tfsdk:"uuid"`
	state                       attr.ValueState
}

func (v SecurityGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 37)

	var val tftypes.Value
	var err error

	attrTypes["access_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backend_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_abbreviation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_native_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["error_traceback"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["is_limit_based"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_usage_based"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["marketplace_category_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_category_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_offering_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_offering_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_plan_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["marketplace_resource_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["modified"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resource_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["rules"] = basetypes.ListType{
		ElemType: RulesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["service_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_settings_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tenant_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 37)

		val, err = v.AccessUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_url"] = val

		val, err = v.BackendId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_id"] = val

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Customer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer"] = val

		val, err = v.CustomerAbbreviation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_abbreviation"] = val

		val, err = v.CustomerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_name"] = val

		val, err = v.CustomerNativeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_native_name"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.ErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_message"] = val

		val, err = v.ErrorTraceback.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["error_traceback"] = val

		val, err = v.IsLimitBased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_limit_based"] = val

		val, err = v.IsUsageBased.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_usage_based"] = val

		val, err = v.MarketplaceCategoryName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_category_name"] = val

		val, err = v.MarketplaceCategoryUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_category_uuid"] = val

		val, err = v.MarketplaceOfferingName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_offering_name"] = val

		val, err = v.MarketplaceOfferingUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_offering_uuid"] = val

		val, err = v.MarketplacePlanUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_plan_uuid"] = val

		val, err = v.MarketplaceResourceState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_state"] = val

		val, err = v.MarketplaceResourceUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["marketplace_resource_uuid"] = val

		val, err = v.Modified.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["modified"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		val, err = v.ProjectName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_name"] = val

		val, err = v.ProjectUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_uuid"] = val

		val, err = v.ResourceType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_type"] = val

		val, err = v.Rules.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rules"] = val

		val, err = v.ServiceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_name"] = val

		val, err = v.ServiceSettings.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings"] = val

		val, err = v.ServiceSettingsErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_error_message"] = val

		val, err = v.ServiceSettingsState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_state"] = val

		val, err = v.ServiceSettingsUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_settings_uuid"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Tenant.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant"] = val

		val, err = v.TenantName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_name"] = val

		val, err = v.TenantUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tenant_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroupsValue) String() string {
	return "SecurityGroupsValue"
}

func (v SecurityGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	rules := types.ListValueMust(
		RulesType{
			basetypes.ObjectType{
				AttrTypes: RulesValue{}.AttributeTypes(ctx),
			},
		},
		v.Rules.Elements(),
	)

	if v.Rules.IsNull() {
		rules = types.ListNull(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Rules.IsUnknown() {
		rules = types.ListUnknown(
			RulesType{
				basetypes.ObjectType{
					AttrTypes: RulesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"access_url":                 basetypes.StringType{},
		"backend_id":                 basetypes.StringType{},
		"created":                    basetypes.StringType{},
		"customer":                   basetypes.StringType{},
		"customer_abbreviation":      basetypes.StringType{},
		"customer_name":              basetypes.StringType{},
		"customer_native_name":       basetypes.StringType{},
		"description":                basetypes.StringType{},
		"error_message":              basetypes.StringType{},
		"error_traceback":            basetypes.StringType{},
		"is_limit_based":             basetypes.BoolType{},
		"is_usage_based":             basetypes.BoolType{},
		"marketplace_category_name":  basetypes.StringType{},
		"marketplace_category_uuid":  basetypes.StringType{},
		"marketplace_offering_name":  basetypes.StringType{},
		"marketplace_offering_uuid":  basetypes.StringType{},
		"marketplace_plan_uuid":      basetypes.StringType{},
		"marketplace_resource_state": basetypes.StringType{},
		"marketplace_resource_uuid":  basetypes.StringType{},
		"modified":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"project":                    basetypes.StringType{},
		"project_name":               basetypes.StringType{},
		"project_uuid":               basetypes.StringType{},
		"resource_type":              basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"service_name":                   basetypes.StringType{},
		"service_settings":               basetypes.StringType{},
		"service_settings_error_message": basetypes.StringType{},
		"service_settings_state":         basetypes.StringType{},
		"service_settings_uuid":          basetypes.StringType{},
		"state":                          basetypes.StringType{},
		"tenant":                         basetypes.StringType{},
		"tenant_name":                    basetypes.StringType{},
		"tenant_uuid":                    basetypes.StringType{},
		"url":                            basetypes.StringType{},
		"uuid":                           basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_url":                     v.AccessUrl,
			"backend_id":                     v.BackendId,
			"created":                        v.Created,
			"customer":                       v.Customer,
			"customer_abbreviation":          v.CustomerAbbreviation,
			"customer_name":                  v.CustomerName,
			"customer_native_name":           v.CustomerNativeName,
			"description":                    v.Description,
			"error_message":                  v.ErrorMessage,
			"error_traceback":                v.ErrorTraceback,
			"is_limit_based":                 v.IsLimitBased,
			"is_usage_based":                 v.IsUsageBased,
			"marketplace_category_name":      v.MarketplaceCategoryName,
			"marketplace_category_uuid":      v.MarketplaceCategoryUuid,
			"marketplace_offering_name":      v.MarketplaceOfferingName,
			"marketplace_offering_uuid":      v.MarketplaceOfferingUuid,
			"marketplace_plan_uuid":          v.MarketplacePlanUuid,
			"marketplace_resource_state":     v.MarketplaceResourceState,
			"marketplace_resource_uuid":      v.MarketplaceResourceUuid,
			"modified":                       v.Modified,
			"name":                           v.Name,
			"project":                        v.Project,
			"project_name":                   v.ProjectName,
			"project_uuid":                   v.ProjectUuid,
			"resource_type":                  v.ResourceType,
			"rules":                          rules,
			"service_name":                   v.ServiceName,
			"service_settings":               v.ServiceSettings,
			"service_settings_error_message": v.ServiceSettingsErrorMessage,
			"service_settings_state":         v.ServiceSettingsState,
			"service_settings_uuid":          v.ServiceSettingsUuid,
			"state":                          v.State,
			"tenant":                         v.Tenant,
			"tenant_name":                    v.TenantName,
			"tenant_uuid":                    v.TenantUuid,
			"url":                            v.Url,
			"uuid":                           v.Uuid,
		})

	return objVal, diags
}

func (v SecurityGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessUrl.Equal(other.AccessUrl) {
		return false
	}

	if !v.BackendId.Equal(other.BackendId) {
		return false
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Customer.Equal(other.Customer) {
		return false
	}

	if !v.CustomerAbbreviation.Equal(other.CustomerAbbreviation) {
		return false
	}

	if !v.CustomerName.Equal(other.CustomerName) {
		return false
	}

	if !v.CustomerNativeName.Equal(other.CustomerNativeName) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.ErrorMessage.Equal(other.ErrorMessage) {
		return false
	}

	if !v.ErrorTraceback.Equal(other.ErrorTraceback) {
		return false
	}

	if !v.IsLimitBased.Equal(other.IsLimitBased) {
		return false
	}

	if !v.IsUsageBased.Equal(other.IsUsageBased) {
		return false
	}

	if !v.MarketplaceCategoryName.Equal(other.MarketplaceCategoryName) {
		return false
	}

	if !v.MarketplaceCategoryUuid.Equal(other.MarketplaceCategoryUuid) {
		return false
	}

	if !v.MarketplaceOfferingName.Equal(other.MarketplaceOfferingName) {
		return false
	}

	if !v.MarketplaceOfferingUuid.Equal(other.MarketplaceOfferingUuid) {
		return false
	}

	if !v.MarketplacePlanUuid.Equal(other.MarketplacePlanUuid) {
		return false
	}

	if !v.MarketplaceResourceState.Equal(other.MarketplaceResourceState) {
		return false
	}

	if !v.MarketplaceResourceUuid.Equal(other.MarketplaceResourceUuid) {
		return false
	}

	if !v.Modified.Equal(other.Modified) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	if !v.ProjectName.Equal(other.ProjectName) {
		return false
	}

	if !v.ProjectUuid.Equal(other.ProjectUuid) {
		return false
	}

	if !v.ResourceType.Equal(other.ResourceType) {
		return false
	}

	if !v.Rules.Equal(other.Rules) {
		return false
	}

	if !v.ServiceName.Equal(other.ServiceName) {
		return false
	}

	if !v.ServiceSettings.Equal(other.ServiceSettings) {
		return false
	}

	if !v.ServiceSettingsErrorMessage.Equal(other.ServiceSettingsErrorMessage) {
		return false
	}

	if !v.ServiceSettingsState.Equal(other.ServiceSettingsState) {
		return false
	}

	if !v.ServiceSettingsUuid.Equal(other.ServiceSettingsUuid) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Tenant.Equal(other.Tenant) {
		return false
	}

	if !v.TenantName.Equal(other.TenantName) {
		return false
	}

	if !v.TenantUuid.Equal(other.TenantUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v SecurityGroupsValue) Type(ctx context.Context) attr.Type {
	return SecurityGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_url":                 basetypes.StringType{},
		"backend_id":                 basetypes.StringType{},
		"created":                    basetypes.StringType{},
		"customer":                   basetypes.StringType{},
		"customer_abbreviation":      basetypes.StringType{},
		"customer_name":              basetypes.StringType{},
		"customer_native_name":       basetypes.StringType{},
		"description":                basetypes.StringType{},
		"error_message":              basetypes.StringType{},
		"error_traceback":            basetypes.StringType{},
		"is_limit_based":             basetypes.BoolType{},
		"is_usage_based":             basetypes.BoolType{},
		"marketplace_category_name":  basetypes.StringType{},
		"marketplace_category_uuid":  basetypes.StringType{},
		"marketplace_offering_name":  basetypes.StringType{},
		"marketplace_offering_uuid":  basetypes.StringType{},
		"marketplace_plan_uuid":      basetypes.StringType{},
		"marketplace_resource_state": basetypes.StringType{},
		"marketplace_resource_uuid":  basetypes.StringType{},
		"modified":                   basetypes.StringType{},
		"name":                       basetypes.StringType{},
		"project":                    basetypes.StringType{},
		"project_name":               basetypes.StringType{},
		"project_uuid":               basetypes.StringType{},
		"resource_type":              basetypes.StringType{},
		"rules": basetypes.ListType{
			ElemType: RulesValue{}.Type(ctx),
		},
		"service_name":                   basetypes.StringType{},
		"service_settings":               basetypes.StringType{},
		"service_settings_error_message": basetypes.StringType{},
		"service_settings_state":         basetypes.StringType{},
		"service_settings_uuid":          basetypes.StringType{},
		"state":                          basetypes.StringType{},
		"tenant":                         basetypes.StringType{},
		"tenant_name":                    basetypes.StringType{},
		"tenant_uuid":                    basetypes.StringType{},
		"url":                            basetypes.StringType{},
		"uuid":                           basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RulesType{}

type RulesType struct {
	basetypes.ObjectType
}

func (t RulesType) Equal(o attr.Type) bool {
	other, ok := o.(RulesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RulesType) String() string {
	return "RulesType"
}

func (t RulesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return nil, diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return nil, diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return nil, diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	fromPortAttribute, ok := attributes["from_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_port is missing from object`)

		return nil, diags
	}

	fromPortVal, ok := fromPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_port expected to be basetypes.Int64Value, was: %T`, fromPortAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	remoteGroupAttribute, ok := attributes["remote_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group is missing from object`)

		return nil, diags
	}

	remoteGroupVal, ok := remoteGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group expected to be basetypes.StringValue, was: %T`, remoteGroupAttribute))
	}

	remoteGroupNameAttribute, ok := attributes["remote_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_name is missing from object`)

		return nil, diags
	}

	remoteGroupNameVal, ok := remoteGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_name expected to be basetypes.StringValue, was: %T`, remoteGroupNameAttribute))
	}

	remoteGroupUuidAttribute, ok := attributes["remote_group_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_uuid is missing from object`)

		return nil, diags
	}

	remoteGroupUuidVal, ok := remoteGroupUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_uuid expected to be basetypes.StringValue, was: %T`, remoteGroupUuidAttribute))
	}

	toPortAttribute, ok := attributes["to_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_port is missing from object`)

		return nil, diags
	}

	toPortVal, ok := toPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_port expected to be basetypes.Int64Value, was: %T`, toPortAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RulesValue{
		Cidr:            cidrVal,
		Description:     descriptionVal,
		Direction:       directionVal,
		Ethertype:       ethertypeVal,
		FromPort:        fromPortVal,
		Id:              idVal,
		RemoteGroup:     remoteGroupVal,
		RemoteGroupName: remoteGroupNameVal,
		RemoteGroupUuid: remoteGroupUuidVal,
		ToPort:          toPortVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRulesValueNull() RulesValue {
	return RulesValue{
		state: attr.ValueStateNull,
	}
}

func NewRulesValueUnknown() RulesValue {
	return RulesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRulesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RulesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RulesValue Attribute Value",
				"While creating a RulesValue value, a missing attribute value was detected. "+
					"A RulesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RulesValue Attribute Type",
				"While creating a RulesValue value, an invalid attribute value was detected. "+
					"A RulesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RulesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RulesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RulesValue Attribute Value",
				"While creating a RulesValue value, an extra attribute value was detected. "+
					"A RulesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RulesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	cidrAttribute, ok := attributes["cidr"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cidr is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	cidrVal, ok := cidrAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cidr expected to be basetypes.StringValue, was: %T`, cidrAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	directionAttribute, ok := attributes["direction"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`direction is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	directionVal, ok := directionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`direction expected to be basetypes.StringValue, was: %T`, directionAttribute))
	}

	ethertypeAttribute, ok := attributes["ethertype"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ethertype is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	ethertypeVal, ok := ethertypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ethertype expected to be basetypes.StringValue, was: %T`, ethertypeAttribute))
	}

	fromPortAttribute, ok := attributes["from_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`from_port is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	fromPortVal, ok := fromPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`from_port expected to be basetypes.Int64Value, was: %T`, fromPortAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	remoteGroupAttribute, ok := attributes["remote_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupVal, ok := remoteGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group expected to be basetypes.StringValue, was: %T`, remoteGroupAttribute))
	}

	remoteGroupNameAttribute, ok := attributes["remote_group_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_name is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupNameVal, ok := remoteGroupNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_name expected to be basetypes.StringValue, was: %T`, remoteGroupNameAttribute))
	}

	remoteGroupUuidAttribute, ok := attributes["remote_group_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_group_uuid is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	remoteGroupUuidVal, ok := remoteGroupUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_group_uuid expected to be basetypes.StringValue, was: %T`, remoteGroupUuidAttribute))
	}

	toPortAttribute, ok := attributes["to_port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`to_port is missing from object`)

		return NewRulesValueUnknown(), diags
	}

	toPortVal, ok := toPortAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`to_port expected to be basetypes.Int64Value, was: %T`, toPortAttribute))
	}

	if diags.HasError() {
		return NewRulesValueUnknown(), diags
	}

	return RulesValue{
		Cidr:            cidrVal,
		Description:     descriptionVal,
		Direction:       directionVal,
		Ethertype:       ethertypeVal,
		FromPort:        fromPortVal,
		Id:              idVal,
		RemoteGroup:     remoteGroupVal,
		RemoteGroupName: remoteGroupNameVal,
		RemoteGroupUuid: remoteGroupUuidVal,
		ToPort:          toPortVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewRulesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RulesValue {
	object, diags := NewRulesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRulesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RulesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRulesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRulesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRulesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRulesValueMust(RulesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RulesType) ValueType(ctx context.Context) attr.Value {
	return RulesValue{}
}

var _ basetypes.ObjectValuable = RulesValue{}

type RulesValue struct {
	Cidr            basetypes.StringValue `tfsdk:"cidr"`
	Description     basetypes.StringValue `tfsdk:"description"`
	Direction       basetypes.StringValue `tfsdk:"direction"`
	Ethertype       basetypes.StringValue `tfsdk:"ethertype"`
	FromPort        basetypes.Int64Value  `tfsdk:"from_port"`
	Id              basetypes.Int64Value  `tfsdk:"id"`
	RemoteGroup     basetypes.StringValue `tfsdk:"remote_group"`
	RemoteGroupName basetypes.StringValue `tfsdk:"remote_group_name"`
	RemoteGroupUuid basetypes.StringValue `tfsdk:"remote_group_uuid"`
	ToPort          basetypes.Int64Value  `tfsdk:"to_port"`
	state           attr.ValueState
}

func (v RulesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["cidr"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["direction"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ethertype"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["from_port"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_group_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["remote_group_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["to_port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Cidr.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cidr"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Direction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["direction"] = val

		val, err = v.Ethertype.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ethertype"] = val

		val, err = v.FromPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["from_port"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.RemoteGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group"] = val

		val, err = v.RemoteGroupName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group_name"] = val

		val, err = v.RemoteGroupUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_group_uuid"] = val

		val, err = v.ToPort.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["to_port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RulesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RulesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RulesValue) String() string {
	return "RulesValue"
}

func (v RulesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"cidr":              basetypes.StringType{},
		"description":       basetypes.StringType{},
		"direction":         basetypes.StringType{},
		"ethertype":         basetypes.StringType{},
		"from_port":         basetypes.Int64Type{},
		"id":                basetypes.Int64Type{},
		"remote_group":      basetypes.StringType{},
		"remote_group_name": basetypes.StringType{},
		"remote_group_uuid": basetypes.StringType{},
		"to_port":           basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"cidr":              v.Cidr,
			"description":       v.Description,
			"direction":         v.Direction,
			"ethertype":         v.Ethertype,
			"from_port":         v.FromPort,
			"id":                v.Id,
			"remote_group":      v.RemoteGroup,
			"remote_group_name": v.RemoteGroupName,
			"remote_group_uuid": v.RemoteGroupUuid,
			"to_port":           v.ToPort,
		})

	return objVal, diags
}

func (v RulesValue) Equal(o attr.Value) bool {
	other, ok := o.(RulesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Cidr.Equal(other.Cidr) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Direction.Equal(other.Direction) {
		return false
	}

	if !v.Ethertype.Equal(other.Ethertype) {
		return false
	}

	if !v.FromPort.Equal(other.FromPort) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.RemoteGroup.Equal(other.RemoteGroup) {
		return false
	}

	if !v.RemoteGroupName.Equal(other.RemoteGroupName) {
		return false
	}

	if !v.RemoteGroupUuid.Equal(other.RemoteGroupUuid) {
		return false
	}

	if !v.ToPort.Equal(other.ToPort) {
		return false
	}

	return true
}

func (v RulesValue) Type(ctx context.Context) attr.Type {
	return RulesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RulesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"cidr":              basetypes.StringType{},
		"description":       basetypes.StringType{},
		"direction":         basetypes.StringType{},
		"ethertype":         basetypes.StringType{},
		"from_port":         basetypes.Int64Type{},
		"id":                basetypes.Int64Type{},
		"remote_group":      basetypes.StringType{},
		"remote_group_name": basetypes.StringType{},
		"remote_group_uuid": basetypes.StringType{},
		"to_port":           basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SecurityGroupsType{}

type SecurityGroupsType struct {
	basetypes.ObjectType
}

func (t SecurityGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(SecurityGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SecurityGroupsType) String() string {
	return "SecurityGroupsType"
}

func (t SecurityGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SecurityGroupsValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueNull() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewSecurityGroupsValueUnknown() SecurityGroupsValue {
	return SecurityGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSecurityGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SecurityGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, a missing attribute value was detected. "+
					"A SecurityGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SecurityGroupsValue Attribute Type",
				"While creating a SecurityGroupsValue value, an invalid attribute value was detected. "+
					"A SecurityGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SecurityGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SecurityGroupsValue Attribute Value",
				"While creating a SecurityGroupsValue value, an extra attribute value was detected. "+
					"A SecurityGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SecurityGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewSecurityGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	if diags.HasError() {
		return NewSecurityGroupsValueUnknown(), diags
	}

	return SecurityGroupsValue{
		Url:   urlVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewSecurityGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SecurityGroupsValue {
	object, diags := NewSecurityGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSecurityGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SecurityGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSecurityGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSecurityGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSecurityGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSecurityGroupsValueMust(SecurityGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SecurityGroupsType) ValueType(ctx context.Context) attr.Value {
	return SecurityGroupsValue{}
}

var _ basetypes.ObjectValuable = SecurityGroupsValue{}

type SecurityGroupsValue struct {
	Url   basetypes.StringValue `tfsdk:"url"`
	state attr.ValueState
}

func (v SecurityGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SecurityGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SecurityGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SecurityGroupsValue) String() string {
	return "SecurityGroupsValue"
}

func (v SecurityGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"url": v.Url,
		})

	return objVal, diags
}

func (v SecurityGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(SecurityGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	return true
}

func (v SecurityGroupsValue) Type(ctx context.Context) attr.Type {
	return SecurityGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SecurityGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"url": basetypes.StringType{},
	}
}
