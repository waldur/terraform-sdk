// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_public_offerings

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func PublicOfferingsDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"accessible_via_calls": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Accessible via calls",
				MarkdownDescription: "Accessible via calls",
			},
			"allowed_customer_uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Allowed customer UUID",
				MarkdownDescription: "Allowed customer UUID",
			},
			"billable": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"category_group_uuid": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"category_uuid": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"created": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Created after",
				MarkdownDescription: "Created after",
			},
			"customer": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"customer_uuid": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"description": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"field": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"has_active_terms_of_service": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Has Active Terms of Service",
				MarkdownDescription: "Has Active Terms of Service",
			},
			"has_terms_of_service": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Has Terms of Service",
				MarkdownDescription: "Has Terms of Service",
			},
			"keyword": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Keyword",
				MarkdownDescription: "Keyword",
			},
			"modified": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Modified after",
				MarkdownDescription: "Modified after",
			},
			"name": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"name_exact": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"o": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Ordering\n\n",
				MarkdownDescription: "Ordering\n\n",
			},
			"organization_group_uuid": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"page": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "A page number within the paginated result set.",
				MarkdownDescription: "A page number within the paginated result set.",
			},
			"page_size": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Number of results to return per page.",
				MarkdownDescription: "Number of results to return per page.",
			},
			"parent_uuid": schema.StringAttribute{
				Optional: true,
				Computed: true,
			},
			"project_uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Project UUID",
				MarkdownDescription: "Project UUID",
			},
			"public_offerings": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"access_url": schema.StringAttribute{
							Computed:            true,
							Description:         "Publicly accessible offering access URL",
							MarkdownDescription: "Publicly accessible offering access URL",
						},
						"backend_id": schema.StringAttribute{
							Computed: true,
						},
						"billable": schema.BoolAttribute{
							Computed:            true,
							Description:         "Purchase and usage is invoiced.",
							MarkdownDescription: "Purchase and usage is invoiced.",
						},
						"category": schema.StringAttribute{
							Computed: true,
						},
						"category_title": schema.StringAttribute{
							Computed: true,
						},
						"category_uuid": schema.StringAttribute{
							Computed: true,
						},
						"citation_count": schema.Int64Attribute{
							Computed:            true,
							Description:         "Number of citations of a DOI",
							MarkdownDescription: "Number of citations of a DOI",
						},
						"compliance_checklist": schema.StringAttribute{
							Computed: true,
						},
						"components": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"article_code": schema.StringAttribute{
										Computed: true,
									},
									"billing_type": schema.StringAttribute{
										Computed: true,
									},
									"default_limit": schema.Int64Attribute{
										Computed: true,
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"factor": schema.Int64Attribute{
										Computed: true,
									},
									"is_boolean": schema.BoolAttribute{
										Computed: true,
									},
									"is_builtin": schema.BoolAttribute{
										Computed: true,
									},
									"is_prepaid": schema.BoolAttribute{
										Computed: true,
									},
									"limit_amount": schema.Int64Attribute{
										Computed: true,
									},
									"max_available_limit": schema.Int64Attribute{
										Computed: true,
									},
									"max_prepaid_duration": schema.Int64Attribute{
										Computed: true,
									},
									"max_value": schema.Int64Attribute{
										Computed: true,
									},
									"measured_unit": schema.StringAttribute{
										Computed:            true,
										Description:         "Unit of measurement, for example, GB.",
										MarkdownDescription: "Unit of measurement, for example, GB.",
									},
									"min_prepaid_duration": schema.Int64Attribute{
										Computed: true,
									},
									"min_value": schema.Int64Attribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed:            true,
										Description:         "Display name for the measured unit, for example, Floating IP.",
										MarkdownDescription: "Display name for the measured unit, for example, Floating IP.",
									},
									"overage_component": schema.StringAttribute{
										Computed: true,
									},
									"type": schema.StringAttribute{
										Computed:            true,
										Description:         "Unique internal name of the measured unit, for example floating_ip.",
										MarkdownDescription: "Unique internal name of the measured unit, for example floating_ip.",
									},
									"unit_factor": schema.Int64Attribute{
										Computed:            true,
										Description:         "The conversion factor from backend units to measured_unit",
										MarkdownDescription: "The conversion factor from backend units to measured_unit",
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ComponentsType{
									ObjectType: types.ObjectType{
										AttrTypes: ComponentsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"created": schema.StringAttribute{
							Computed: true,
						},
						"customer": schema.StringAttribute{
							Computed: true,
						},
						"customer_name": schema.StringAttribute{
							Computed: true,
						},
						"customer_uuid": schema.StringAttribute{
							Computed: true,
						},
						"datacite_doi": schema.StringAttribute{
							Computed: true,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"endpoints": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: EndpointsType{
									ObjectType: types.ObjectType{
										AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"files": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"created": schema.StringAttribute{
										Computed: true,
									},
									"file": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: FilesType{
									ObjectType: types.ObjectType{
										AttrTypes: FilesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"full_description": schema.StringAttribute{
							Computed: true,
						},
						"getting_started": schema.StringAttribute{
							Computed: true,
						},
						"google_calendar_is_public": schema.BoolAttribute{
							Computed: true,
						},
						"google_calendar_link": schema.StringAttribute{
							Computed:            true,
							Description:         "Get the Google Calendar link for an offering.",
							MarkdownDescription: "Get the Google Calendar link for an offering.",
						},
						"has_compliance_requirements": schema.BoolAttribute{
							Computed: true,
						},
						"image": schema.StringAttribute{
							Computed: true,
						},
						"integration_guide": schema.StringAttribute{
							Computed: true,
						},
						"latitude": schema.Float64Attribute{
							Computed: true,
						},
						"longitude": schema.Float64Attribute{
							Computed: true,
						},
						"name": schema.StringAttribute{
							Computed: true,
						},
						"options": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"options": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"choices": schema.ListAttribute{
												ElementType: types.StringType,
												Computed:    true,
											},
											"default": schema.StringAttribute{
												Computed: true,
											},
											"help_text": schema.StringAttribute{
												Computed: true,
											},
											"label": schema.StringAttribute{
												Computed: true,
											},
											"max": schema.Int64Attribute{
												Computed: true,
											},
											"min": schema.Int64Attribute{
												Computed: true,
											},
											"required": schema.BoolAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: OptionsType{
											ObjectType: types.ObjectType{
												AttrTypes: OptionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
								},
								"order": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
							},
							CustomType: OptionsType{
								ObjectType: types.ObjectType{
									AttrTypes: OptionsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"order_count": schema.Int64Attribute{
							Computed: true,
						},
						"organization_groups": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"customers_count": schema.Int64Attribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"parent": schema.StringAttribute{
										Computed: true,
									},
									"parent_name": schema.StringAttribute{
										Computed: true,
									},
									"parent_uuid": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: OrganizationGroupsType{
									ObjectType: types.ObjectType{
										AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"parent_description": schema.StringAttribute{
							Computed: true,
						},
						"parent_name": schema.StringAttribute{
							Computed: true,
						},
						"parent_uuid": schema.StringAttribute{
							Computed: true,
						},
						"paused_reason": schema.StringAttribute{
							Computed: true,
						},
						"plans": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"archived": schema.BoolAttribute{
										Computed:            true,
										Description:         "Forbids creation of new resources.",
										MarkdownDescription: "Forbids creation of new resources.",
									},
									"article_code": schema.StringAttribute{
										Computed: true,
									},
									"backend_id": schema.StringAttribute{
										Computed: true,
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"future_prices": schema.MapAttribute{
										ElementType: types.Float64Type,
										Computed:    true,
									},
									"init_price": schema.Float64Attribute{
										Computed: true,
									},
									"is_active": schema.BoolAttribute{
										Computed: true,
									},
									"max_amount": schema.Int64Attribute{
										Computed:            true,
										Description:         "Maximum number of plans that could be active. Plan is disabled when maximum amount is reached.",
										MarkdownDescription: "Maximum number of plans that could be active. Plan is disabled when maximum amount is reached.",
									},
									"minimal_price": schema.Float64Attribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"organization_groups": schema.ListNestedAttribute{
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"customers_count": schema.Int64Attribute{
													Computed: true,
												},
												"name": schema.StringAttribute{
													Computed: true,
												},
												"parent": schema.StringAttribute{
													Computed: true,
												},
												"parent_name": schema.StringAttribute{
													Computed: true,
												},
												"parent_uuid": schema.StringAttribute{
													Computed: true,
												},
												"url": schema.StringAttribute{
													Computed: true,
												},
												"uuid": schema.StringAttribute{
													Computed: true,
												},
											},
											CustomType: OrganizationGroupsType{
												ObjectType: types.ObjectType{
													AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
												},
											},
										},
										Computed: true,
									},
									"plan_type": schema.StringAttribute{
										Computed: true,
									},
									"prices": schema.MapAttribute{
										ElementType: types.Float64Type,
										Computed:    true,
									},
									"quotas": schema.MapAttribute{
										ElementType: types.Float64Type,
										Computed:    true,
									},
									"resources_count": schema.Int64Attribute{
										Computed: true,
									},
									"switch_price": schema.Float64Attribute{
										Computed: true,
									},
									"unit": schema.StringAttribute{
										Computed: true,
									},
									"unit_price": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: PlansType{
									ObjectType: types.ObjectType{
										AttrTypes: PlansValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"plugin_options": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"auto_approve_in_service_provider_projects": schema.BoolAttribute{
									Computed:            true,
									Description:         "Skip approval of public offering belonging to the same organization under which the request is done",
									MarkdownDescription: "Skip approval of public offering belonging to the same organization under which the request is done",
								},
								"auto_approve_remote_orders": schema.BoolAttribute{
									Computed:            true,
									Description:         "If set to True, an order can be processed without approval",
									MarkdownDescription: "If set to True, an order can be processed without approval",
								},
								"backend_id_display_label": schema.StringAttribute{
									Computed:            true,
									Description:         "Label used by UI for showing value of the backend_id",
									MarkdownDescription: "Label used by UI for showing value of the backend_id",
								},
								"conceal_billing_data": schema.BoolAttribute{
									Computed:            true,
									Description:         "If set to True, pricing and components tab would be concealed.",
									MarkdownDescription: "If set to True, pricing and components tab would be concealed.",
								},
								"default_internal_network_mtu": schema.Int64Attribute{
									Computed:            true,
									Description:         "If set, it will be used as a default MTU for the first network in a tenant",
									MarkdownDescription: "If set, it will be used as a default MTU for the first network in a tenant",
								},
								"default_resource_termination_offset_in_days": schema.Int64Attribute{
									Computed:            true,
									Description:         "If set, it will be used as a default resource termination offset in days",
									MarkdownDescription: "If set, it will be used as a default resource termination offset in days",
								},
								"deployment_mode": schema.StringAttribute{
									Computed:            true,
									Description:         "Rancher deployment mode",
									MarkdownDescription: "Rancher deployment mode",
								},
								"enable_issues_for_membership_changes": schema.BoolAttribute{
									Computed:            true,
									Description:         "Enable issues for membership changes",
									MarkdownDescription: "Enable issues for membership changes",
								},
								"flavors_regex": schema.StringAttribute{
									Computed:            true,
									Description:         "Regular expression to limit flavors list",
									MarkdownDescription: "Regular expression to limit flavors list",
								},
								"heappe_cluster_id": schema.StringAttribute{
									Computed:            true,
									Description:         "HEAppE cluster id",
									MarkdownDescription: "HEAppE cluster id",
								},
								"heappe_local_base_path": schema.StringAttribute{
									Computed:            true,
									Description:         "HEAppE local base path",
									MarkdownDescription: "HEAppE local base path",
								},
								"heappe_url": schema.StringAttribute{
									Computed:            true,
									Description:         "HEAppE url",
									MarkdownDescription: "HEAppE url",
								},
								"heappe_username": schema.StringAttribute{
									Computed:            true,
									Description:         "HEAppE username",
									MarkdownDescription: "HEAppE username",
								},
								"highlight_backend_id_display": schema.BoolAttribute{
									Computed:            true,
									Description:         "Defines if backend_id should be shown more prominently by the UI",
									MarkdownDescription: "Defines if backend_id should be shown more prominently by the UI",
								},
								"homedir_prefix": schema.StringAttribute{
									Computed:            true,
									Description:         "GLAuth homedir prefix",
									MarkdownDescription: "GLAuth homedir prefix",
								},
								"initial_primarygroup_number": schema.Int64Attribute{
									Computed:            true,
									Description:         "GLAuth initial primary group number",
									MarkdownDescription: "GLAuth initial primary group number",
								},
								"initial_uidnumber": schema.Int64Attribute{
									Computed:            true,
									Description:         "GLAuth initial uidnumber",
									MarkdownDescription: "GLAuth initial uidnumber",
								},
								"initial_usergroup_number": schema.Int64Attribute{
									Computed:            true,
									Description:         "GLAuth initial usergroup number",
									MarkdownDescription: "GLAuth initial usergroup number",
								},
								"is_resource_termination_date_required": schema.BoolAttribute{
									Computed:            true,
									Description:         "If set to True, resource termination date is required",
									MarkdownDescription: "If set to True, resource termination date is required",
								},
								"latest_date_for_resource_termination": schema.StringAttribute{
									Computed:            true,
									Description:         "If set, it will be used as a latest date for resource termination",
									MarkdownDescription: "If set, it will be used as a latest date for resource termination",
								},
								"managed_rancher_load_balancer_data_volume_size_gb": schema.Int64Attribute{
									Computed: true,
								},
								"managed_rancher_load_balancer_data_volume_type_name": schema.StringAttribute{
									Computed: true,
								},
								"managed_rancher_load_balancer_flavor_name": schema.StringAttribute{
									Computed: true,
								},
								"managed_rancher_load_balancer_system_volume_size_gb": schema.Int64Attribute{
									Computed: true,
								},
								"managed_rancher_load_balancer_system_volume_type_name": schema.StringAttribute{
									Computed: true,
								},
								"managed_rancher_server_data_volume_size_gb": schema.Int64Attribute{
									Computed: true,
								},
								"managed_rancher_server_data_volume_type_name": schema.StringAttribute{
									Computed: true,
								},
								"managed_rancher_server_flavor_name": schema.StringAttribute{
									Computed: true,
								},
								"managed_rancher_server_system_volume_size_gb": schema.Int64Attribute{
									Computed: true,
								},
								"managed_rancher_server_system_volume_type_name": schema.StringAttribute{
									Computed: true,
								},
								"managed_rancher_tenant_max_cpu": schema.Int64Attribute{
									Computed:            true,
									Description:         "Max number of vCPUs for tenants",
									MarkdownDescription: "Max number of vCPUs for tenants",
								},
								"managed_rancher_tenant_max_disk": schema.Int64Attribute{
									Computed:            true,
									Description:         "Max size of disk space for tenants (GB)",
									MarkdownDescription: "Max size of disk space for tenants (GB)",
								},
								"managed_rancher_tenant_max_ram": schema.Int64Attribute{
									Computed:            true,
									Description:         "Max number of RAM for tenants (GB)",
									MarkdownDescription: "Max number of RAM for tenants (GB)",
								},
								"managed_rancher_worker_system_volume_size_gb": schema.Int64Attribute{
									Computed: true,
								},
								"managed_rancher_worker_system_volume_type_name": schema.StringAttribute{
									Computed: true,
								},
								"max_instances": schema.Int64Attribute{
									Computed:            true,
									Description:         "Default limit for number of instances in OpenStack tenant",
									MarkdownDescription: "Default limit for number of instances in OpenStack tenant",
								},
								"max_resource_termination_offset_in_days": schema.Int64Attribute{
									Computed:            true,
									Description:         "Maximum resource termination offset in days",
									MarkdownDescription: "Maximum resource termination offset in days",
								},
								"max_volumes": schema.Int64Attribute{
									Computed:            true,
									Description:         "Default limit for number of volumes in OpenStack tenant",
									MarkdownDescription: "Default limit for number of volumes in OpenStack tenant",
								},
								"maximal_resource_count_per_project": schema.Int64Attribute{
									Computed:            true,
									Description:         "Maximal number of offering resources allowed per project",
									MarkdownDescription: "Maximal number of offering resources allowed per project",
								},
								"minimal_team_count_for_provisioning": schema.Int64Attribute{
									Computed:            true,
									Description:         "Minimal team count required for provisioning of resources",
									MarkdownDescription: "Minimal team count required for provisioning of resources",
								},
								"openstack_offering_uuid_list": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of UUID of OpenStack offerings where tenant can be created",
									MarkdownDescription: "List of UUID of OpenStack offerings where tenant can be created",
								},
								"order_supports_comments_and_metadata": schema.BoolAttribute{
									Computed:            true,
									Description:         "If set to True, orders will support comments and metadata",
									MarkdownDescription: "If set to True, orders will support comments and metadata",
								},
								"project_permanent_directory": schema.StringAttribute{
									Computed:            true,
									Description:         "HEAppE project permanent directory",
									MarkdownDescription: "HEAppE project permanent directory",
								},
								"required_team_role_for_provisioning": schema.StringAttribute{
									Computed:            true,
									Description:         "Required user role in a project for provisioning of resources",
									MarkdownDescription: "Required user role in a project for provisioning of resources",
								},
								"scratch_project_directory": schema.StringAttribute{
									Computed:            true,
									Description:         "HEAppE scratch project directory",
									MarkdownDescription: "HEAppE scratch project directory",
								},
								"service_provider_can_create_offering_user": schema.BoolAttribute{
									Computed:            true,
									Description:         "Service provider can create offering user",
									MarkdownDescription: "Service provider can create offering user",
								},
								"snapshot_size_limit_gb": schema.Int64Attribute{
									Computed:            true,
									Description:         "Default limit for snapshot size in GB",
									MarkdownDescription: "Default limit for snapshot size in GB",
								},
								"storage_mode": schema.StringAttribute{
									Computed:            true,
									Description:         "Storage mode for OpenStack offering",
									MarkdownDescription: "Storage mode for OpenStack offering",
								},
								"supports_downscaling": schema.BoolAttribute{
									Computed:            true,
									Description:         "If set to True, it will be possible to downscale resources",
									MarkdownDescription: "If set to True, it will be possible to downscale resources",
								},
								"supports_pausing": schema.BoolAttribute{
									Computed:            true,
									Description:         "If set to True, it will be possible to pause resources",
									MarkdownDescription: "If set to True, it will be possible to pause resources",
								},
								"username_anonymized_prefix": schema.StringAttribute{
									Computed:            true,
									Description:         "GLAuth prefix for anonymized usernames",
									MarkdownDescription: "GLAuth prefix for anonymized usernames",
								},
								"username_generation_policy": schema.StringAttribute{
									Computed:            true,
									Description:         "GLAuth username generation policy",
									MarkdownDescription: "GLAuth username generation policy",
								},
							},
							CustomType: PluginOptionsType{
								ObjectType: types.ObjectType{
									AttrTypes: PluginOptionsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"privacy_policy_link": schema.StringAttribute{
							Computed: true,
						},
						"project": schema.StringAttribute{
							Computed: true,
						},
						"project_name": schema.StringAttribute{
							Computed: true,
						},
						"project_uuid": schema.StringAttribute{
							Computed: true,
						},
						"promotion_campaigns": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"description": schema.StringAttribute{
										Computed: true,
									},
									"discount": schema.Int64Attribute{
										Computed: true,
									},
									"discount_type": schema.StringAttribute{
										Computed: true,
									},
									"end_date": schema.StringAttribute{
										Computed:            true,
										Description:         "The last day the campaign is active.",
										MarkdownDescription: "The last day the campaign is active.",
									},
									"months": schema.Int64Attribute{
										Computed:            true,
										Description:         "How many months in a row should the related service (when activated) get special deal (0 for indefinitely until active)",
										MarkdownDescription: "How many months in a row should the related service (when activated) get special deal (0 for indefinitely until active)",
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"service_provider": schema.StringAttribute{
										Computed: true,
									},
									"start_date": schema.StringAttribute{
										Computed:            true,
										Description:         "Starting from this date, the campaign is active.",
										MarkdownDescription: "Starting from this date, the campaign is active.",
									},
									"stock": schema.Int64Attribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: PromotionCampaignsType{
									ObjectType: types.ObjectType{
										AttrTypes: PromotionCampaignsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"quotas": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"limit": schema.Int64Attribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"usage": schema.Int64Attribute{
										Computed: true,
									},
								},
								CustomType: QuotasType{
									ObjectType: types.ObjectType{
										AttrTypes: QuotasValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"resource_options": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"options": schema.MapNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"choices": schema.ListAttribute{
												ElementType: types.StringType,
												Computed:    true,
											},
											"default": schema.StringAttribute{
												Computed: true,
											},
											"help_text": schema.StringAttribute{
												Computed: true,
											},
											"label": schema.StringAttribute{
												Computed: true,
											},
											"max": schema.Int64Attribute{
												Computed: true,
											},
											"min": schema.Int64Attribute{
												Computed: true,
											},
											"required": schema.BoolAttribute{
												Computed: true,
											},
											"type": schema.StringAttribute{
												Computed: true,
											},
										},
										CustomType: OptionsType{
											ObjectType: types.ObjectType{
												AttrTypes: OptionsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed: true,
								},
								"order": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
							},
							CustomType: ResourceOptionsType{
								ObjectType: types.ObjectType{
									AttrTypes: ResourceOptionsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"roles": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Computed: true,
									},
									"url": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: RolesType{
									ObjectType: types.ObjectType{
										AttrTypes: RolesValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"scope": schema.StringAttribute{
							Computed: true,
						},
						"scope_error_message": schema.StringAttribute{
							Computed: true,
						},
						"scope_name": schema.StringAttribute{
							Computed: true,
						},
						"scope_state": schema.StringAttribute{
							Computed: true,
						},
						"scope_uuid": schema.StringAttribute{
							Computed: true,
						},
						"screenshots": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"created": schema.StringAttribute{
										Computed: true,
									},
									"description": schema.StringAttribute{
										Computed: true,
									},
									"image": schema.StringAttribute{
										Computed: true,
									},
									"name": schema.StringAttribute{
										Computed: true,
									},
									"thumbnail": schema.StringAttribute{
										Computed: true,
									},
									"uuid": schema.StringAttribute{
										Computed: true,
									},
								},
								CustomType: ScreenshotsType{
									ObjectType: types.ObjectType{
										AttrTypes: ScreenshotsValue{}.AttributeTypes(ctx),
									},
								},
							},
							Computed: true,
						},
						"shared": schema.BoolAttribute{
							Computed:            true,
							Description:         "Accessible to all customers.",
							MarkdownDescription: "Accessible to all customers.",
						},
						"slug": schema.StringAttribute{
							Computed: true,
						},
						"state": schema.StringAttribute{
							Computed: true,
						},
						"thumbnail": schema.StringAttribute{
							Computed: true,
						},
						"total_cost": schema.Int64Attribute{
							Computed: true,
						},
						"total_cost_estimated": schema.Int64Attribute{
							Computed: true,
						},
						"total_customers": schema.Int64Attribute{
							Computed: true,
						},
						"type": schema.StringAttribute{
							Computed: true,
						},
						"url": schema.StringAttribute{
							Computed: true,
						},
						"user_has_consent": schema.BoolAttribute{
							Computed: true,
						},
						"uuid": schema.StringAttribute{
							Computed: true,
						},
						"vendor_details": schema.StringAttribute{
							Computed: true,
						},
					},
					CustomType: PublicOfferingsType{
						ObjectType: types.ObjectType{
							AttrTypes: PublicOfferingsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"resource_customer_uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Resource customer UUID",
				MarkdownDescription: "Resource customer UUID",
			},
			"resource_project_uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Resource project UUID",
				MarkdownDescription: "Resource project UUID",
			},
			"scope_uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Scope UUID",
				MarkdownDescription: "Scope UUID",
			},
			"service_manager_uuid": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Service manager UUID",
				MarkdownDescription: "Service manager UUID",
			},
			"shared": schema.BoolAttribute{
				Optional: true,
				Computed: true,
			},
			"state": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"type": schema.ListAttribute{
				ElementType: types.StringType,
				Optional:    true,
				Computed:    true,
			},
			"user_has_consent": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "User Has Consent",
				MarkdownDescription: "User Has Consent",
			},
			"user_has_offering_user": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "User Has Offering User",
				MarkdownDescription: "User Has Offering User",
			},
			"uuid_list": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Comma-separated offering UUIDs",
				MarkdownDescription: "Comma-separated offering UUIDs",
			},
		},
	}
}

type PublicOfferingsModel struct {
	AccessibleViaCalls      types.Bool   `tfsdk:"accessible_via_calls"`
	AllowedCustomerUuid     types.String `tfsdk:"allowed_customer_uuid"`
	Billable                types.Bool   `tfsdk:"billable"`
	CategoryGroupUuid       types.String `tfsdk:"category_group_uuid"`
	CategoryUuid            types.String `tfsdk:"category_uuid"`
	Created                 types.String `tfsdk:"created"`
	Customer                types.String `tfsdk:"customer"`
	CustomerUuid            types.String `tfsdk:"customer_uuid"`
	Description             types.String `tfsdk:"description"`
	Field                   types.List   `tfsdk:"field"`
	HasActiveTermsOfService types.Bool   `tfsdk:"has_active_terms_of_service"`
	HasTermsOfService       types.Bool   `tfsdk:"has_terms_of_service"`
	Keyword                 types.String `tfsdk:"keyword"`
	Modified                types.String `tfsdk:"modified"`
	Name                    types.String `tfsdk:"name"`
	NameExact               types.String `tfsdk:"name_exact"`
	O                       types.List   `tfsdk:"o"`
	OrganizationGroupUuid   types.List   `tfsdk:"organization_group_uuid"`
	Page                    types.Int64  `tfsdk:"page"`
	PageSize                types.Int64  `tfsdk:"page_size"`
	ParentUuid              types.String `tfsdk:"parent_uuid"`
	ProjectUuid             types.String `tfsdk:"project_uuid"`
	PublicOfferings         types.Set    `tfsdk:"public_offerings"`
	ResourceCustomerUuid    types.String `tfsdk:"resource_customer_uuid"`
	ResourceProjectUuid     types.String `tfsdk:"resource_project_uuid"`
	ScopeUuid               types.String `tfsdk:"scope_uuid"`
	ServiceManagerUuid      types.String `tfsdk:"service_manager_uuid"`
	Shared                  types.Bool   `tfsdk:"shared"`
	State                   types.List   `tfsdk:"state"`
	Type                    types.List   `tfsdk:"type"`
	UserHasConsent          types.Bool   `tfsdk:"user_has_consent"`
	UserHasOfferingUser     types.Bool   `tfsdk:"user_has_offering_user"`
	UuidList                types.String `tfsdk:"uuid_list"`
}

var _ basetypes.ObjectTypable = PublicOfferingsType{}

type PublicOfferingsType struct {
	basetypes.ObjectType
}

func (t PublicOfferingsType) Equal(o attr.Type) bool {
	other, ok := o.(PublicOfferingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PublicOfferingsType) String() string {
	return "PublicOfferingsType"
}

func (t PublicOfferingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return nil, diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return nil, diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	billableAttribute, ok := attributes["billable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable is missing from object`)

		return nil, diags
	}

	billableVal, ok := billableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable expected to be basetypes.BoolValue, was: %T`, billableAttribute))
	}

	categoryAttribute, ok := attributes["category"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category is missing from object`)

		return nil, diags
	}

	categoryVal, ok := categoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category expected to be basetypes.StringValue, was: %T`, categoryAttribute))
	}

	categoryTitleAttribute, ok := attributes["category_title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category_title is missing from object`)

		return nil, diags
	}

	categoryTitleVal, ok := categoryTitleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category_title expected to be basetypes.StringValue, was: %T`, categoryTitleAttribute))
	}

	categoryUuidAttribute, ok := attributes["category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category_uuid is missing from object`)

		return nil, diags
	}

	categoryUuidVal, ok := categoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category_uuid expected to be basetypes.StringValue, was: %T`, categoryUuidAttribute))
	}

	citationCountAttribute, ok := attributes["citation_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`citation_count is missing from object`)

		return nil, diags
	}

	citationCountVal, ok := citationCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`citation_count expected to be basetypes.Int64Value, was: %T`, citationCountAttribute))
	}

	complianceChecklistAttribute, ok := attributes["compliance_checklist"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`compliance_checklist is missing from object`)

		return nil, diags
	}

	complianceChecklistVal, ok := complianceChecklistAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`compliance_checklist expected to be basetypes.StringValue, was: %T`, complianceChecklistAttribute))
	}

	componentsAttribute, ok := attributes["components"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`components is missing from object`)

		return nil, diags
	}

	componentsVal, ok := componentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`components expected to be basetypes.ListValue, was: %T`, componentsAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return nil, diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return nil, diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerUuidAttribute, ok := attributes["customer_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_uuid is missing from object`)

		return nil, diags
	}

	customerUuidVal, ok := customerUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_uuid expected to be basetypes.StringValue, was: %T`, customerUuidAttribute))
	}

	dataciteDoiAttribute, ok := attributes["datacite_doi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datacite_doi is missing from object`)

		return nil, diags
	}

	dataciteDoiVal, ok := dataciteDoiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datacite_doi expected to be basetypes.StringValue, was: %T`, dataciteDoiAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	endpointsAttribute, ok := attributes["endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoints is missing from object`)

		return nil, diags
	}

	endpointsVal, ok := endpointsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoints expected to be basetypes.ListValue, was: %T`, endpointsAttribute))
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return nil, diags
	}

	filesVal, ok := filesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.ListValue, was: %T`, filesAttribute))
	}

	fullDescriptionAttribute, ok := attributes["full_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_description is missing from object`)

		return nil, diags
	}

	fullDescriptionVal, ok := fullDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_description expected to be basetypes.StringValue, was: %T`, fullDescriptionAttribute))
	}

	gettingStartedAttribute, ok := attributes["getting_started"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`getting_started is missing from object`)

		return nil, diags
	}

	gettingStartedVal, ok := gettingStartedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`getting_started expected to be basetypes.StringValue, was: %T`, gettingStartedAttribute))
	}

	googleCalendarIsPublicAttribute, ok := attributes["google_calendar_is_public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_calendar_is_public is missing from object`)

		return nil, diags
	}

	googleCalendarIsPublicVal, ok := googleCalendarIsPublicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_calendar_is_public expected to be basetypes.BoolValue, was: %T`, googleCalendarIsPublicAttribute))
	}

	googleCalendarLinkAttribute, ok := attributes["google_calendar_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_calendar_link is missing from object`)

		return nil, diags
	}

	googleCalendarLinkVal, ok := googleCalendarLinkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_calendar_link expected to be basetypes.StringValue, was: %T`, googleCalendarLinkAttribute))
	}

	hasComplianceRequirementsAttribute, ok := attributes["has_compliance_requirements"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_compliance_requirements is missing from object`)

		return nil, diags
	}

	hasComplianceRequirementsVal, ok := hasComplianceRequirementsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_compliance_requirements expected to be basetypes.BoolValue, was: %T`, hasComplianceRequirementsAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	integrationGuideAttribute, ok := attributes["integration_guide"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`integration_guide is missing from object`)

		return nil, diags
	}

	integrationGuideVal, ok := integrationGuideAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`integration_guide expected to be basetypes.StringValue, was: %T`, integrationGuideAttribute))
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return nil, diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.Float64Value, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return nil, diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.Float64Value, was: %T`, longitudeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.ObjectValue, was: %T`, optionsAttribute))
	}

	orderCountAttribute, ok := attributes["order_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order_count is missing from object`)

		return nil, diags
	}

	orderCountVal, ok := orderCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order_count expected to be basetypes.Int64Value, was: %T`, orderCountAttribute))
	}

	organizationGroupsAttribute, ok := attributes["organization_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_groups is missing from object`)

		return nil, diags
	}

	organizationGroupsVal, ok := organizationGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_groups expected to be basetypes.ListValue, was: %T`, organizationGroupsAttribute))
	}

	parentDescriptionAttribute, ok := attributes["parent_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_description is missing from object`)

		return nil, diags
	}

	parentDescriptionVal, ok := parentDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_description expected to be basetypes.StringValue, was: %T`, parentDescriptionAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return nil, diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return nil, diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	pausedReasonAttribute, ok := attributes["paused_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paused_reason is missing from object`)

		return nil, diags
	}

	pausedReasonVal, ok := pausedReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paused_reason expected to be basetypes.StringValue, was: %T`, pausedReasonAttribute))
	}

	plansAttribute, ok := attributes["plans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plans is missing from object`)

		return nil, diags
	}

	plansVal, ok := plansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plans expected to be basetypes.ListValue, was: %T`, plansAttribute))
	}

	pluginOptionsAttribute, ok := attributes["plugin_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plugin_options is missing from object`)

		return nil, diags
	}

	pluginOptionsVal, ok := pluginOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plugin_options expected to be basetypes.ObjectValue, was: %T`, pluginOptionsAttribute))
	}

	privacyPolicyLinkAttribute, ok := attributes["privacy_policy_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privacy_policy_link is missing from object`)

		return nil, diags
	}

	privacyPolicyLinkVal, ok := privacyPolicyLinkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privacy_policy_link expected to be basetypes.StringValue, was: %T`, privacyPolicyLinkAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return nil, diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return nil, diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return nil, diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	promotionCampaignsAttribute, ok := attributes["promotion_campaigns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`promotion_campaigns is missing from object`)

		return nil, diags
	}

	promotionCampaignsVal, ok := promotionCampaignsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`promotion_campaigns expected to be basetypes.ListValue, was: %T`, promotionCampaignsAttribute))
	}

	quotasAttribute, ok := attributes["quotas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quotas is missing from object`)

		return nil, diags
	}

	quotasVal, ok := quotasAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quotas expected to be basetypes.ListValue, was: %T`, quotasAttribute))
	}

	resourceOptionsAttribute, ok := attributes["resource_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_options is missing from object`)

		return nil, diags
	}

	resourceOptionsVal, ok := resourceOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_options expected to be basetypes.ObjectValue, was: %T`, resourceOptionsAttribute))
	}

	rolesAttribute, ok := attributes["roles"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`roles is missing from object`)

		return nil, diags
	}

	rolesVal, ok := rolesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`roles expected to be basetypes.ListValue, was: %T`, rolesAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return nil, diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	scopeErrorMessageAttribute, ok := attributes["scope_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope_error_message is missing from object`)

		return nil, diags
	}

	scopeErrorMessageVal, ok := scopeErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope_error_message expected to be basetypes.StringValue, was: %T`, scopeErrorMessageAttribute))
	}

	scopeNameAttribute, ok := attributes["scope_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope_name is missing from object`)

		return nil, diags
	}

	scopeNameVal, ok := scopeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope_name expected to be basetypes.StringValue, was: %T`, scopeNameAttribute))
	}

	scopeStateAttribute, ok := attributes["scope_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope_state is missing from object`)

		return nil, diags
	}

	scopeStateVal, ok := scopeStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope_state expected to be basetypes.StringValue, was: %T`, scopeStateAttribute))
	}

	scopeUuidAttribute, ok := attributes["scope_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope_uuid is missing from object`)

		return nil, diags
	}

	scopeUuidVal, ok := scopeUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope_uuid expected to be basetypes.StringValue, was: %T`, scopeUuidAttribute))
	}

	screenshotsAttribute, ok := attributes["screenshots"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`screenshots is missing from object`)

		return nil, diags
	}

	screenshotsVal, ok := screenshotsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`screenshots expected to be basetypes.ListValue, was: %T`, screenshotsAttribute))
	}

	sharedAttribute, ok := attributes["shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shared is missing from object`)

		return nil, diags
	}

	sharedVal, ok := sharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shared expected to be basetypes.BoolValue, was: %T`, sharedAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return nil, diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return nil, diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	thumbnailAttribute, ok := attributes["thumbnail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thumbnail is missing from object`)

		return nil, diags
	}

	thumbnailVal, ok := thumbnailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thumbnail expected to be basetypes.StringValue, was: %T`, thumbnailAttribute))
	}

	totalCostAttribute, ok := attributes["total_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_cost is missing from object`)

		return nil, diags
	}

	totalCostVal, ok := totalCostAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_cost expected to be basetypes.Int64Value, was: %T`, totalCostAttribute))
	}

	totalCostEstimatedAttribute, ok := attributes["total_cost_estimated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_cost_estimated is missing from object`)

		return nil, diags
	}

	totalCostEstimatedVal, ok := totalCostEstimatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_cost_estimated expected to be basetypes.Int64Value, was: %T`, totalCostEstimatedAttribute))
	}

	totalCustomersAttribute, ok := attributes["total_customers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_customers is missing from object`)

		return nil, diags
	}

	totalCustomersVal, ok := totalCustomersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_customers expected to be basetypes.Int64Value, was: %T`, totalCustomersAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	userHasConsentAttribute, ok := attributes["user_has_consent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_has_consent is missing from object`)

		return nil, diags
	}

	userHasConsentVal, ok := userHasConsentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_has_consent expected to be basetypes.BoolValue, was: %T`, userHasConsentAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	vendorDetailsAttribute, ok := attributes["vendor_details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_details is missing from object`)

		return nil, diags
	}

	vendorDetailsVal, ok := vendorDetailsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_details expected to be basetypes.StringValue, was: %T`, vendorDetailsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PublicOfferingsValue{
		AccessUrl:                 accessUrlVal,
		BackendId:                 backendIdVal,
		Billable:                  billableVal,
		Category:                  categoryVal,
		CategoryTitle:             categoryTitleVal,
		CategoryUuid:              categoryUuidVal,
		CitationCount:             citationCountVal,
		ComplianceChecklist:       complianceChecklistVal,
		Components:                componentsVal,
		Created:                   createdVal,
		Customer:                  customerVal,
		CustomerName:              customerNameVal,
		CustomerUuid:              customerUuidVal,
		DataciteDoi:               dataciteDoiVal,
		Description:               descriptionVal,
		Endpoints:                 endpointsVal,
		Files:                     filesVal,
		FullDescription:           fullDescriptionVal,
		GettingStarted:            gettingStartedVal,
		GoogleCalendarIsPublic:    googleCalendarIsPublicVal,
		GoogleCalendarLink:        googleCalendarLinkVal,
		HasComplianceRequirements: hasComplianceRequirementsVal,
		Image:                     imageVal,
		IntegrationGuide:          integrationGuideVal,
		Latitude:                  latitudeVal,
		Longitude:                 longitudeVal,
		Name:                      nameVal,
		Options:                   optionsVal,
		OrderCount:                orderCountVal,
		OrganizationGroups:        organizationGroupsVal,
		ParentDescription:         parentDescriptionVal,
		ParentName:                parentNameVal,
		ParentUuid:                parentUuidVal,
		PausedReason:              pausedReasonVal,
		Plans:                     plansVal,
		PluginOptions:             pluginOptionsVal,
		PrivacyPolicyLink:         privacyPolicyLinkVal,
		Project:                   projectVal,
		ProjectName:               projectNameVal,
		ProjectUuid:               projectUuidVal,
		PromotionCampaigns:        promotionCampaignsVal,
		Quotas:                    quotasVal,
		ResourceOptions:           resourceOptionsVal,
		Roles:                     rolesVal,
		Scope:                     scopeVal,
		ScopeErrorMessage:         scopeErrorMessageVal,
		ScopeName:                 scopeNameVal,
		ScopeState:                scopeStateVal,
		ScopeUuid:                 scopeUuidVal,
		Screenshots:               screenshotsVal,
		Shared:                    sharedVal,
		Slug:                      slugVal,
		State:                     stateVal,
		Thumbnail:                 thumbnailVal,
		TotalCost:                 totalCostVal,
		TotalCostEstimated:        totalCostEstimatedVal,
		TotalCustomers:            totalCustomersVal,
		PublicOfferingsType:       typeVal,
		Url:                       urlVal,
		UserHasConsent:            userHasConsentVal,
		Uuid:                      uuidVal,
		VendorDetails:             vendorDetailsVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewPublicOfferingsValueNull() PublicOfferingsValue {
	return PublicOfferingsValue{
		state: attr.ValueStateNull,
	}
}

func NewPublicOfferingsValueUnknown() PublicOfferingsValue {
	return PublicOfferingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPublicOfferingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PublicOfferingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PublicOfferingsValue Attribute Value",
				"While creating a PublicOfferingsValue value, a missing attribute value was detected. "+
					"A PublicOfferingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PublicOfferingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PublicOfferingsValue Attribute Type",
				"While creating a PublicOfferingsValue value, an invalid attribute value was detected. "+
					"A PublicOfferingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PublicOfferingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PublicOfferingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PublicOfferingsValue Attribute Value",
				"While creating a PublicOfferingsValue value, an extra attribute value was detected. "+
					"A PublicOfferingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PublicOfferingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPublicOfferingsValueUnknown(), diags
	}

	accessUrlAttribute, ok := attributes["access_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`access_url is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	accessUrlVal, ok := accessUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`access_url expected to be basetypes.StringValue, was: %T`, accessUrlAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	billableAttribute, ok := attributes["billable"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billable is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	billableVal, ok := billableAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billable expected to be basetypes.BoolValue, was: %T`, billableAttribute))
	}

	categoryAttribute, ok := attributes["category"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	categoryVal, ok := categoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category expected to be basetypes.StringValue, was: %T`, categoryAttribute))
	}

	categoryTitleAttribute, ok := attributes["category_title"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category_title is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	categoryTitleVal, ok := categoryTitleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category_title expected to be basetypes.StringValue, was: %T`, categoryTitleAttribute))
	}

	categoryUuidAttribute, ok := attributes["category_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`category_uuid is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	categoryUuidVal, ok := categoryUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`category_uuid expected to be basetypes.StringValue, was: %T`, categoryUuidAttribute))
	}

	citationCountAttribute, ok := attributes["citation_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`citation_count is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	citationCountVal, ok := citationCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`citation_count expected to be basetypes.Int64Value, was: %T`, citationCountAttribute))
	}

	complianceChecklistAttribute, ok := attributes["compliance_checklist"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`compliance_checklist is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	complianceChecklistVal, ok := complianceChecklistAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`compliance_checklist expected to be basetypes.StringValue, was: %T`, complianceChecklistAttribute))
	}

	componentsAttribute, ok := attributes["components"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`components is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	componentsVal, ok := componentsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`components expected to be basetypes.ListValue, was: %T`, componentsAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	customerAttribute, ok := attributes["customer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	customerVal, ok := customerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer expected to be basetypes.StringValue, was: %T`, customerAttribute))
	}

	customerNameAttribute, ok := attributes["customer_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_name is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	customerNameVal, ok := customerNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_name expected to be basetypes.StringValue, was: %T`, customerNameAttribute))
	}

	customerUuidAttribute, ok := attributes["customer_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customer_uuid is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	customerUuidVal, ok := customerUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customer_uuid expected to be basetypes.StringValue, was: %T`, customerUuidAttribute))
	}

	dataciteDoiAttribute, ok := attributes["datacite_doi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datacite_doi is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	dataciteDoiVal, ok := dataciteDoiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datacite_doi expected to be basetypes.StringValue, was: %T`, dataciteDoiAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	endpointsAttribute, ok := attributes["endpoints"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`endpoints is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	endpointsVal, ok := endpointsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`endpoints expected to be basetypes.ListValue, was: %T`, endpointsAttribute))
	}

	filesAttribute, ok := attributes["files"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`files is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	filesVal, ok := filesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`files expected to be basetypes.ListValue, was: %T`, filesAttribute))
	}

	fullDescriptionAttribute, ok := attributes["full_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_description is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	fullDescriptionVal, ok := fullDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_description expected to be basetypes.StringValue, was: %T`, fullDescriptionAttribute))
	}

	gettingStartedAttribute, ok := attributes["getting_started"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`getting_started is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	gettingStartedVal, ok := gettingStartedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`getting_started expected to be basetypes.StringValue, was: %T`, gettingStartedAttribute))
	}

	googleCalendarIsPublicAttribute, ok := attributes["google_calendar_is_public"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_calendar_is_public is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	googleCalendarIsPublicVal, ok := googleCalendarIsPublicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_calendar_is_public expected to be basetypes.BoolValue, was: %T`, googleCalendarIsPublicAttribute))
	}

	googleCalendarLinkAttribute, ok := attributes["google_calendar_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`google_calendar_link is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	googleCalendarLinkVal, ok := googleCalendarLinkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`google_calendar_link expected to be basetypes.StringValue, was: %T`, googleCalendarLinkAttribute))
	}

	hasComplianceRequirementsAttribute, ok := attributes["has_compliance_requirements"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`has_compliance_requirements is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	hasComplianceRequirementsVal, ok := hasComplianceRequirementsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`has_compliance_requirements expected to be basetypes.BoolValue, was: %T`, hasComplianceRequirementsAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	integrationGuideAttribute, ok := attributes["integration_guide"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`integration_guide is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	integrationGuideVal, ok := integrationGuideAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`integration_guide expected to be basetypes.StringValue, was: %T`, integrationGuideAttribute))
	}

	latitudeAttribute, ok := attributes["latitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latitude is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	latitudeVal, ok := latitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latitude expected to be basetypes.Float64Value, was: %T`, latitudeAttribute))
	}

	longitudeAttribute, ok := attributes["longitude"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`longitude is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	longitudeVal, ok := longitudeAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`longitude expected to be basetypes.Float64Value, was: %T`, longitudeAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.ObjectValue, was: %T`, optionsAttribute))
	}

	orderCountAttribute, ok := attributes["order_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order_count is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	orderCountVal, ok := orderCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order_count expected to be basetypes.Int64Value, was: %T`, orderCountAttribute))
	}

	organizationGroupsAttribute, ok := attributes["organization_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_groups is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	organizationGroupsVal, ok := organizationGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_groups expected to be basetypes.ListValue, was: %T`, organizationGroupsAttribute))
	}

	parentDescriptionAttribute, ok := attributes["parent_description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_description is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	parentDescriptionVal, ok := parentDescriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_description expected to be basetypes.StringValue, was: %T`, parentDescriptionAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	pausedReasonAttribute, ok := attributes["paused_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`paused_reason is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	pausedReasonVal, ok := pausedReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`paused_reason expected to be basetypes.StringValue, was: %T`, pausedReasonAttribute))
	}

	plansAttribute, ok := attributes["plans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plans is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	plansVal, ok := plansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plans expected to be basetypes.ListValue, was: %T`, plansAttribute))
	}

	pluginOptionsAttribute, ok := attributes["plugin_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plugin_options is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	pluginOptionsVal, ok := pluginOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plugin_options expected to be basetypes.ObjectValue, was: %T`, pluginOptionsAttribute))
	}

	privacyPolicyLinkAttribute, ok := attributes["privacy_policy_link"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`privacy_policy_link is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	privacyPolicyLinkVal, ok := privacyPolicyLinkAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`privacy_policy_link expected to be basetypes.StringValue, was: %T`, privacyPolicyLinkAttribute))
	}

	projectAttribute, ok := attributes["project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	projectVal, ok := projectAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project expected to be basetypes.StringValue, was: %T`, projectAttribute))
	}

	projectNameAttribute, ok := attributes["project_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_name is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	projectNameVal, ok := projectNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_name expected to be basetypes.StringValue, was: %T`, projectNameAttribute))
	}

	projectUuidAttribute, ok := attributes["project_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_uuid is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	projectUuidVal, ok := projectUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_uuid expected to be basetypes.StringValue, was: %T`, projectUuidAttribute))
	}

	promotionCampaignsAttribute, ok := attributes["promotion_campaigns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`promotion_campaigns is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	promotionCampaignsVal, ok := promotionCampaignsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`promotion_campaigns expected to be basetypes.ListValue, was: %T`, promotionCampaignsAttribute))
	}

	quotasAttribute, ok := attributes["quotas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quotas is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	quotasVal, ok := quotasAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quotas expected to be basetypes.ListValue, was: %T`, quotasAttribute))
	}

	resourceOptionsAttribute, ok := attributes["resource_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resource_options is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	resourceOptionsVal, ok := resourceOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resource_options expected to be basetypes.ObjectValue, was: %T`, resourceOptionsAttribute))
	}

	rolesAttribute, ok := attributes["roles"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`roles is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	rolesVal, ok := rolesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`roles expected to be basetypes.ListValue, was: %T`, rolesAttribute))
	}

	scopeAttribute, ok := attributes["scope"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	scopeVal, ok := scopeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope expected to be basetypes.StringValue, was: %T`, scopeAttribute))
	}

	scopeErrorMessageAttribute, ok := attributes["scope_error_message"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope_error_message is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	scopeErrorMessageVal, ok := scopeErrorMessageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope_error_message expected to be basetypes.StringValue, was: %T`, scopeErrorMessageAttribute))
	}

	scopeNameAttribute, ok := attributes["scope_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope_name is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	scopeNameVal, ok := scopeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope_name expected to be basetypes.StringValue, was: %T`, scopeNameAttribute))
	}

	scopeStateAttribute, ok := attributes["scope_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope_state is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	scopeStateVal, ok := scopeStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope_state expected to be basetypes.StringValue, was: %T`, scopeStateAttribute))
	}

	scopeUuidAttribute, ok := attributes["scope_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scope_uuid is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	scopeUuidVal, ok := scopeUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scope_uuid expected to be basetypes.StringValue, was: %T`, scopeUuidAttribute))
	}

	screenshotsAttribute, ok := attributes["screenshots"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`screenshots is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	screenshotsVal, ok := screenshotsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`screenshots expected to be basetypes.ListValue, was: %T`, screenshotsAttribute))
	}

	sharedAttribute, ok := attributes["shared"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`shared is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	sharedVal, ok := sharedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`shared expected to be basetypes.BoolValue, was: %T`, sharedAttribute))
	}

	slugAttribute, ok := attributes["slug"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`slug is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	slugVal, ok := slugAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`slug expected to be basetypes.StringValue, was: %T`, slugAttribute))
	}

	stateAttribute, ok := attributes["state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`state is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	stateVal, ok := stateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`state expected to be basetypes.StringValue, was: %T`, stateAttribute))
	}

	thumbnailAttribute, ok := attributes["thumbnail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thumbnail is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	thumbnailVal, ok := thumbnailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thumbnail expected to be basetypes.StringValue, was: %T`, thumbnailAttribute))
	}

	totalCostAttribute, ok := attributes["total_cost"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_cost is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	totalCostVal, ok := totalCostAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_cost expected to be basetypes.Int64Value, was: %T`, totalCostAttribute))
	}

	totalCostEstimatedAttribute, ok := attributes["total_cost_estimated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_cost_estimated is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	totalCostEstimatedVal, ok := totalCostEstimatedAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_cost_estimated expected to be basetypes.Int64Value, was: %T`, totalCostEstimatedAttribute))
	}

	totalCustomersAttribute, ok := attributes["total_customers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`total_customers is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	totalCustomersVal, ok := totalCustomersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`total_customers expected to be basetypes.Int64Value, was: %T`, totalCustomersAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	userHasConsentAttribute, ok := attributes["user_has_consent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`user_has_consent is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	userHasConsentVal, ok := userHasConsentAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`user_has_consent expected to be basetypes.BoolValue, was: %T`, userHasConsentAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	vendorDetailsAttribute, ok := attributes["vendor_details"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vendor_details is missing from object`)

		return NewPublicOfferingsValueUnknown(), diags
	}

	vendorDetailsVal, ok := vendorDetailsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vendor_details expected to be basetypes.StringValue, was: %T`, vendorDetailsAttribute))
	}

	if diags.HasError() {
		return NewPublicOfferingsValueUnknown(), diags
	}

	return PublicOfferingsValue{
		AccessUrl:                 accessUrlVal,
		BackendId:                 backendIdVal,
		Billable:                  billableVal,
		Category:                  categoryVal,
		CategoryTitle:             categoryTitleVal,
		CategoryUuid:              categoryUuidVal,
		CitationCount:             citationCountVal,
		ComplianceChecklist:       complianceChecklistVal,
		Components:                componentsVal,
		Created:                   createdVal,
		Customer:                  customerVal,
		CustomerName:              customerNameVal,
		CustomerUuid:              customerUuidVal,
		DataciteDoi:               dataciteDoiVal,
		Description:               descriptionVal,
		Endpoints:                 endpointsVal,
		Files:                     filesVal,
		FullDescription:           fullDescriptionVal,
		GettingStarted:            gettingStartedVal,
		GoogleCalendarIsPublic:    googleCalendarIsPublicVal,
		GoogleCalendarLink:        googleCalendarLinkVal,
		HasComplianceRequirements: hasComplianceRequirementsVal,
		Image:                     imageVal,
		IntegrationGuide:          integrationGuideVal,
		Latitude:                  latitudeVal,
		Longitude:                 longitudeVal,
		Name:                      nameVal,
		Options:                   optionsVal,
		OrderCount:                orderCountVal,
		OrganizationGroups:        organizationGroupsVal,
		ParentDescription:         parentDescriptionVal,
		ParentName:                parentNameVal,
		ParentUuid:                parentUuidVal,
		PausedReason:              pausedReasonVal,
		Plans:                     plansVal,
		PluginOptions:             pluginOptionsVal,
		PrivacyPolicyLink:         privacyPolicyLinkVal,
		Project:                   projectVal,
		ProjectName:               projectNameVal,
		ProjectUuid:               projectUuidVal,
		PromotionCampaigns:        promotionCampaignsVal,
		Quotas:                    quotasVal,
		ResourceOptions:           resourceOptionsVal,
		Roles:                     rolesVal,
		Scope:                     scopeVal,
		ScopeErrorMessage:         scopeErrorMessageVal,
		ScopeName:                 scopeNameVal,
		ScopeState:                scopeStateVal,
		ScopeUuid:                 scopeUuidVal,
		Screenshots:               screenshotsVal,
		Shared:                    sharedVal,
		Slug:                      slugVal,
		State:                     stateVal,
		Thumbnail:                 thumbnailVal,
		TotalCost:                 totalCostVal,
		TotalCostEstimated:        totalCostEstimatedVal,
		TotalCustomers:            totalCustomersVal,
		PublicOfferingsType:       typeVal,
		Url:                       urlVal,
		UserHasConsent:            userHasConsentVal,
		Uuid:                      uuidVal,
		VendorDetails:             vendorDetailsVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewPublicOfferingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PublicOfferingsValue {
	object, diags := NewPublicOfferingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPublicOfferingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PublicOfferingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPublicOfferingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPublicOfferingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPublicOfferingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPublicOfferingsValueMust(PublicOfferingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PublicOfferingsType) ValueType(ctx context.Context) attr.Value {
	return PublicOfferingsValue{}
}

var _ basetypes.ObjectValuable = PublicOfferingsValue{}

type PublicOfferingsValue struct {
	AccessUrl                 basetypes.StringValue  `tfsdk:"access_url"`
	BackendId                 basetypes.StringValue  `tfsdk:"backend_id"`
	Billable                  basetypes.BoolValue    `tfsdk:"billable"`
	Category                  basetypes.StringValue  `tfsdk:"category"`
	CategoryTitle             basetypes.StringValue  `tfsdk:"category_title"`
	CategoryUuid              basetypes.StringValue  `tfsdk:"category_uuid"`
	CitationCount             basetypes.Int64Value   `tfsdk:"citation_count"`
	ComplianceChecklist       basetypes.StringValue  `tfsdk:"compliance_checklist"`
	Components                basetypes.ListValue    `tfsdk:"components"`
	Created                   basetypes.StringValue  `tfsdk:"created"`
	Customer                  basetypes.StringValue  `tfsdk:"customer"`
	CustomerName              basetypes.StringValue  `tfsdk:"customer_name"`
	CustomerUuid              basetypes.StringValue  `tfsdk:"customer_uuid"`
	DataciteDoi               basetypes.StringValue  `tfsdk:"datacite_doi"`
	Description               basetypes.StringValue  `tfsdk:"description"`
	Endpoints                 basetypes.ListValue    `tfsdk:"endpoints"`
	Files                     basetypes.ListValue    `tfsdk:"files"`
	FullDescription           basetypes.StringValue  `tfsdk:"full_description"`
	GettingStarted            basetypes.StringValue  `tfsdk:"getting_started"`
	GoogleCalendarIsPublic    basetypes.BoolValue    `tfsdk:"google_calendar_is_public"`
	GoogleCalendarLink        basetypes.StringValue  `tfsdk:"google_calendar_link"`
	HasComplianceRequirements basetypes.BoolValue    `tfsdk:"has_compliance_requirements"`
	Image                     basetypes.StringValue  `tfsdk:"image"`
	IntegrationGuide          basetypes.StringValue  `tfsdk:"integration_guide"`
	Latitude                  basetypes.Float64Value `tfsdk:"latitude"`
	Longitude                 basetypes.Float64Value `tfsdk:"longitude"`
	Name                      basetypes.StringValue  `tfsdk:"name"`
	Options                   basetypes.ObjectValue  `tfsdk:"options"`
	OrderCount                basetypes.Int64Value   `tfsdk:"order_count"`
	OrganizationGroups        basetypes.ListValue    `tfsdk:"organization_groups"`
	ParentDescription         basetypes.StringValue  `tfsdk:"parent_description"`
	ParentName                basetypes.StringValue  `tfsdk:"parent_name"`
	ParentUuid                basetypes.StringValue  `tfsdk:"parent_uuid"`
	PausedReason              basetypes.StringValue  `tfsdk:"paused_reason"`
	Plans                     basetypes.ListValue    `tfsdk:"plans"`
	PluginOptions             basetypes.ObjectValue  `tfsdk:"plugin_options"`
	PrivacyPolicyLink         basetypes.StringValue  `tfsdk:"privacy_policy_link"`
	Project                   basetypes.StringValue  `tfsdk:"project"`
	ProjectName               basetypes.StringValue  `tfsdk:"project_name"`
	ProjectUuid               basetypes.StringValue  `tfsdk:"project_uuid"`
	PromotionCampaigns        basetypes.ListValue    `tfsdk:"promotion_campaigns"`
	Quotas                    basetypes.ListValue    `tfsdk:"quotas"`
	ResourceOptions           basetypes.ObjectValue  `tfsdk:"resource_options"`
	Roles                     basetypes.ListValue    `tfsdk:"roles"`
	Scope                     basetypes.StringValue  `tfsdk:"scope"`
	ScopeErrorMessage         basetypes.StringValue  `tfsdk:"scope_error_message"`
	ScopeName                 basetypes.StringValue  `tfsdk:"scope_name"`
	ScopeState                basetypes.StringValue  `tfsdk:"scope_state"`
	ScopeUuid                 basetypes.StringValue  `tfsdk:"scope_uuid"`
	Screenshots               basetypes.ListValue    `tfsdk:"screenshots"`
	Shared                    basetypes.BoolValue    `tfsdk:"shared"`
	Slug                      basetypes.StringValue  `tfsdk:"slug"`
	State                     basetypes.StringValue  `tfsdk:"state"`
	Thumbnail                 basetypes.StringValue  `tfsdk:"thumbnail"`
	TotalCost                 basetypes.Int64Value   `tfsdk:"total_cost"`
	TotalCostEstimated        basetypes.Int64Value   `tfsdk:"total_cost_estimated"`
	TotalCustomers            basetypes.Int64Value   `tfsdk:"total_customers"`
	PublicOfferingsType       basetypes.StringValue  `tfsdk:"type"`
	Url                       basetypes.StringValue  `tfsdk:"url"`
	UserHasConsent            basetypes.BoolValue    `tfsdk:"user_has_consent"`
	Uuid                      basetypes.StringValue  `tfsdk:"uuid"`
	VendorDetails             basetypes.StringValue  `tfsdk:"vendor_details"`
	state                     attr.ValueState
}

func (v PublicOfferingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 62)

	var val tftypes.Value
	var err error

	attrTypes["access_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backend_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["billable"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["category"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["category_title"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["category_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["citation_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["compliance_checklist"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["components"] = basetypes.ListType{
		ElemType: ComponentsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["customer_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["datacite_doi"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["endpoints"] = basetypes.ListType{
		ElemType: EndpointsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["files"] = basetypes.ListType{
		ElemType: FilesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["full_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["getting_started"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["google_calendar_is_public"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["google_calendar_link"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["has_compliance_requirements"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["integration_guide"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["latitude"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["longitude"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["options"] = basetypes.ObjectType{
		AttrTypes: OptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["order_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["organization_groups"] = basetypes.ListType{
		ElemType: OrganizationGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["parent_description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["paused_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["plans"] = basetypes.ListType{
		ElemType: PlansValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["plugin_options"] = basetypes.ObjectType{
		AttrTypes: PluginOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["privacy_policy_link"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["project_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["promotion_campaigns"] = basetypes.ListType{
		ElemType: PromotionCampaignsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["quotas"] = basetypes.ListType{
		ElemType: QuotasValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["resource_options"] = basetypes.ObjectType{
		AttrTypes: ResourceOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["roles"] = basetypes.ListType{
		ElemType: RolesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["scope"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope_error_message"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scope_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["screenshots"] = basetypes.ListType{
		ElemType: ScreenshotsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["shared"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["slug"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["thumbnail"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["total_cost"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_cost_estimated"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["total_customers"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["user_has_consent"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vendor_details"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 62)

		val, err = v.AccessUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["access_url"] = val

		val, err = v.BackendId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_id"] = val

		val, err = v.Billable.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billable"] = val

		val, err = v.Category.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["category"] = val

		val, err = v.CategoryTitle.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["category_title"] = val

		val, err = v.CategoryUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["category_uuid"] = val

		val, err = v.CitationCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["citation_count"] = val

		val, err = v.ComplianceChecklist.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["compliance_checklist"] = val

		val, err = v.Components.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["components"] = val

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Customer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer"] = val

		val, err = v.CustomerName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_name"] = val

		val, err = v.CustomerUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customer_uuid"] = val

		val, err = v.DataciteDoi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datacite_doi"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Endpoints.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["endpoints"] = val

		val, err = v.Files.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["files"] = val

		val, err = v.FullDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_description"] = val

		val, err = v.GettingStarted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["getting_started"] = val

		val, err = v.GoogleCalendarIsPublic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_calendar_is_public"] = val

		val, err = v.GoogleCalendarLink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["google_calendar_link"] = val

		val, err = v.HasComplianceRequirements.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["has_compliance_requirements"] = val

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.IntegrationGuide.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["integration_guide"] = val

		val, err = v.Latitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latitude"] = val

		val, err = v.Longitude.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["longitude"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.OrderCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["order_count"] = val

		val, err = v.OrganizationGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["organization_groups"] = val

		val, err = v.ParentDescription.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_description"] = val

		val, err = v.ParentName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_name"] = val

		val, err = v.ParentUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_uuid"] = val

		val, err = v.PausedReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["paused_reason"] = val

		val, err = v.Plans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plans"] = val

		val, err = v.PluginOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plugin_options"] = val

		val, err = v.PrivacyPolicyLink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["privacy_policy_link"] = val

		val, err = v.Project.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project"] = val

		val, err = v.ProjectName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_name"] = val

		val, err = v.ProjectUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_uuid"] = val

		val, err = v.PromotionCampaigns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["promotion_campaigns"] = val

		val, err = v.Quotas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quotas"] = val

		val, err = v.ResourceOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resource_options"] = val

		val, err = v.Roles.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["roles"] = val

		val, err = v.Scope.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope"] = val

		val, err = v.ScopeErrorMessage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope_error_message"] = val

		val, err = v.ScopeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope_name"] = val

		val, err = v.ScopeState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope_state"] = val

		val, err = v.ScopeUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scope_uuid"] = val

		val, err = v.Screenshots.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["screenshots"] = val

		val, err = v.Shared.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["shared"] = val

		val, err = v.Slug.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["slug"] = val

		val, err = v.State.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["state"] = val

		val, err = v.Thumbnail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["thumbnail"] = val

		val, err = v.TotalCost.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_cost"] = val

		val, err = v.TotalCostEstimated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_cost_estimated"] = val

		val, err = v.TotalCustomers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["total_customers"] = val

		val, err = v.PublicOfferingsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.UserHasConsent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["user_has_consent"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		val, err = v.VendorDetails.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vendor_details"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PublicOfferingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PublicOfferingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PublicOfferingsValue) String() string {
	return "PublicOfferingsValue"
}

func (v PublicOfferingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	components := types.ListValueMust(
		ComponentsType{
			basetypes.ObjectType{
				AttrTypes: ComponentsValue{}.AttributeTypes(ctx),
			},
		},
		v.Components.Elements(),
	)

	if v.Components.IsNull() {
		components = types.ListNull(
			ComponentsType{
				basetypes.ObjectType{
					AttrTypes: ComponentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Components.IsUnknown() {
		components = types.ListUnknown(
			ComponentsType{
				basetypes.ObjectType{
					AttrTypes: ComponentsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	endpoints := types.ListValueMust(
		EndpointsType{
			basetypes.ObjectType{
				AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
			},
		},
		v.Endpoints.Elements(),
	)

	if v.Endpoints.IsNull() {
		endpoints = types.ListNull(
			EndpointsType{
				basetypes.ObjectType{
					AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Endpoints.IsUnknown() {
		endpoints = types.ListUnknown(
			EndpointsType{
				basetypes.ObjectType{
					AttrTypes: EndpointsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	files := types.ListValueMust(
		FilesType{
			basetypes.ObjectType{
				AttrTypes: FilesValue{}.AttributeTypes(ctx),
			},
		},
		v.Files.Elements(),
	)

	if v.Files.IsNull() {
		files = types.ListNull(
			FilesType{
				basetypes.ObjectType{
					AttrTypes: FilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Files.IsUnknown() {
		files = types.ListUnknown(
			FilesType{
				basetypes.ObjectType{
					AttrTypes: FilesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var options basetypes.ObjectValue

	if v.Options.IsNull() {
		options = types.ObjectNull(
			OptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Options.IsUnknown() {
		options = types.ObjectUnknown(
			OptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Options.IsNull() && !v.Options.IsUnknown() {
		options = types.ObjectValueMust(
			OptionsValue{}.AttributeTypes(ctx),
			v.Options.Attributes(),
		)
	}

	organizationGroups := types.ListValueMust(
		OrganizationGroupsType{
			basetypes.ObjectType{
				AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.OrganizationGroups.Elements(),
	)

	if v.OrganizationGroups.IsNull() {
		organizationGroups = types.ListNull(
			OrganizationGroupsType{
				basetypes.ObjectType{
					AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OrganizationGroups.IsUnknown() {
		organizationGroups = types.ListUnknown(
			OrganizationGroupsType{
				basetypes.ObjectType{
					AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	plans := types.ListValueMust(
		PlansType{
			basetypes.ObjectType{
				AttrTypes: PlansValue{}.AttributeTypes(ctx),
			},
		},
		v.Plans.Elements(),
	)

	if v.Plans.IsNull() {
		plans = types.ListNull(
			PlansType{
				basetypes.ObjectType{
					AttrTypes: PlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Plans.IsUnknown() {
		plans = types.ListUnknown(
			PlansType{
				basetypes.ObjectType{
					AttrTypes: PlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var pluginOptions basetypes.ObjectValue

	if v.PluginOptions.IsNull() {
		pluginOptions = types.ObjectNull(
			PluginOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.PluginOptions.IsUnknown() {
		pluginOptions = types.ObjectUnknown(
			PluginOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PluginOptions.IsNull() && !v.PluginOptions.IsUnknown() {
		pluginOptions = types.ObjectValueMust(
			PluginOptionsValue{}.AttributeTypes(ctx),
			v.PluginOptions.Attributes(),
		)
	}

	promotionCampaigns := types.ListValueMust(
		PromotionCampaignsType{
			basetypes.ObjectType{
				AttrTypes: PromotionCampaignsValue{}.AttributeTypes(ctx),
			},
		},
		v.PromotionCampaigns.Elements(),
	)

	if v.PromotionCampaigns.IsNull() {
		promotionCampaigns = types.ListNull(
			PromotionCampaignsType{
				basetypes.ObjectType{
					AttrTypes: PromotionCampaignsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PromotionCampaigns.IsUnknown() {
		promotionCampaigns = types.ListUnknown(
			PromotionCampaignsType{
				basetypes.ObjectType{
					AttrTypes: PromotionCampaignsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	quotas := types.ListValueMust(
		QuotasType{
			basetypes.ObjectType{
				AttrTypes: QuotasValue{}.AttributeTypes(ctx),
			},
		},
		v.Quotas.Elements(),
	)

	if v.Quotas.IsNull() {
		quotas = types.ListNull(
			QuotasType{
				basetypes.ObjectType{
					AttrTypes: QuotasValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Quotas.IsUnknown() {
		quotas = types.ListUnknown(
			QuotasType{
				basetypes.ObjectType{
					AttrTypes: QuotasValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var resourceOptions basetypes.ObjectValue

	if v.ResourceOptions.IsNull() {
		resourceOptions = types.ObjectNull(
			ResourceOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.ResourceOptions.IsUnknown() {
		resourceOptions = types.ObjectUnknown(
			ResourceOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.ResourceOptions.IsNull() && !v.ResourceOptions.IsUnknown() {
		resourceOptions = types.ObjectValueMust(
			ResourceOptionsValue{}.AttributeTypes(ctx),
			v.ResourceOptions.Attributes(),
		)
	}

	roles := types.ListValueMust(
		RolesType{
			basetypes.ObjectType{
				AttrTypes: RolesValue{}.AttributeTypes(ctx),
			},
		},
		v.Roles.Elements(),
	)

	if v.Roles.IsNull() {
		roles = types.ListNull(
			RolesType{
				basetypes.ObjectType{
					AttrTypes: RolesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Roles.IsUnknown() {
		roles = types.ListUnknown(
			RolesType{
				basetypes.ObjectType{
					AttrTypes: RolesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	screenshots := types.ListValueMust(
		ScreenshotsType{
			basetypes.ObjectType{
				AttrTypes: ScreenshotsValue{}.AttributeTypes(ctx),
			},
		},
		v.Screenshots.Elements(),
	)

	if v.Screenshots.IsNull() {
		screenshots = types.ListNull(
			ScreenshotsType{
				basetypes.ObjectType{
					AttrTypes: ScreenshotsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Screenshots.IsUnknown() {
		screenshots = types.ListUnknown(
			ScreenshotsType{
				basetypes.ObjectType{
					AttrTypes: ScreenshotsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"access_url":           basetypes.StringType{},
		"backend_id":           basetypes.StringType{},
		"billable":             basetypes.BoolType{},
		"category":             basetypes.StringType{},
		"category_title":       basetypes.StringType{},
		"category_uuid":        basetypes.StringType{},
		"citation_count":       basetypes.Int64Type{},
		"compliance_checklist": basetypes.StringType{},
		"components": basetypes.ListType{
			ElemType: ComponentsValue{}.Type(ctx),
		},
		"created":       basetypes.StringType{},
		"customer":      basetypes.StringType{},
		"customer_name": basetypes.StringType{},
		"customer_uuid": basetypes.StringType{},
		"datacite_doi":  basetypes.StringType{},
		"description":   basetypes.StringType{},
		"endpoints": basetypes.ListType{
			ElemType: EndpointsValue{}.Type(ctx),
		},
		"files": basetypes.ListType{
			ElemType: FilesValue{}.Type(ctx),
		},
		"full_description":            basetypes.StringType{},
		"getting_started":             basetypes.StringType{},
		"google_calendar_is_public":   basetypes.BoolType{},
		"google_calendar_link":        basetypes.StringType{},
		"has_compliance_requirements": basetypes.BoolType{},
		"image":                       basetypes.StringType{},
		"integration_guide":           basetypes.StringType{},
		"latitude":                    basetypes.Float64Type{},
		"longitude":                   basetypes.Float64Type{},
		"name":                        basetypes.StringType{},
		"options": basetypes.ObjectType{
			AttrTypes: OptionsValue{}.AttributeTypes(ctx),
		},
		"order_count": basetypes.Int64Type{},
		"organization_groups": basetypes.ListType{
			ElemType: OrganizationGroupsValue{}.Type(ctx),
		},
		"parent_description": basetypes.StringType{},
		"parent_name":        basetypes.StringType{},
		"parent_uuid":        basetypes.StringType{},
		"paused_reason":      basetypes.StringType{},
		"plans": basetypes.ListType{
			ElemType: PlansValue{}.Type(ctx),
		},
		"plugin_options": basetypes.ObjectType{
			AttrTypes: PluginOptionsValue{}.AttributeTypes(ctx),
		},
		"privacy_policy_link": basetypes.StringType{},
		"project":             basetypes.StringType{},
		"project_name":        basetypes.StringType{},
		"project_uuid":        basetypes.StringType{},
		"promotion_campaigns": basetypes.ListType{
			ElemType: PromotionCampaignsValue{}.Type(ctx),
		},
		"quotas": basetypes.ListType{
			ElemType: QuotasValue{}.Type(ctx),
		},
		"resource_options": basetypes.ObjectType{
			AttrTypes: ResourceOptionsValue{}.AttributeTypes(ctx),
		},
		"roles": basetypes.ListType{
			ElemType: RolesValue{}.Type(ctx),
		},
		"scope":               basetypes.StringType{},
		"scope_error_message": basetypes.StringType{},
		"scope_name":          basetypes.StringType{},
		"scope_state":         basetypes.StringType{},
		"scope_uuid":          basetypes.StringType{},
		"screenshots": basetypes.ListType{
			ElemType: ScreenshotsValue{}.Type(ctx),
		},
		"shared":               basetypes.BoolType{},
		"slug":                 basetypes.StringType{},
		"state":                basetypes.StringType{},
		"thumbnail":            basetypes.StringType{},
		"total_cost":           basetypes.Int64Type{},
		"total_cost_estimated": basetypes.Int64Type{},
		"total_customers":      basetypes.Int64Type{},
		"type":                 basetypes.StringType{},
		"url":                  basetypes.StringType{},
		"user_has_consent":     basetypes.BoolType{},
		"uuid":                 basetypes.StringType{},
		"vendor_details":       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"access_url":                  v.AccessUrl,
			"backend_id":                  v.BackendId,
			"billable":                    v.Billable,
			"category":                    v.Category,
			"category_title":              v.CategoryTitle,
			"category_uuid":               v.CategoryUuid,
			"citation_count":              v.CitationCount,
			"compliance_checklist":        v.ComplianceChecklist,
			"components":                  components,
			"created":                     v.Created,
			"customer":                    v.Customer,
			"customer_name":               v.CustomerName,
			"customer_uuid":               v.CustomerUuid,
			"datacite_doi":                v.DataciteDoi,
			"description":                 v.Description,
			"endpoints":                   endpoints,
			"files":                       files,
			"full_description":            v.FullDescription,
			"getting_started":             v.GettingStarted,
			"google_calendar_is_public":   v.GoogleCalendarIsPublic,
			"google_calendar_link":        v.GoogleCalendarLink,
			"has_compliance_requirements": v.HasComplianceRequirements,
			"image":                       v.Image,
			"integration_guide":           v.IntegrationGuide,
			"latitude":                    v.Latitude,
			"longitude":                   v.Longitude,
			"name":                        v.Name,
			"options":                     options,
			"order_count":                 v.OrderCount,
			"organization_groups":         organizationGroups,
			"parent_description":          v.ParentDescription,
			"parent_name":                 v.ParentName,
			"parent_uuid":                 v.ParentUuid,
			"paused_reason":               v.PausedReason,
			"plans":                       plans,
			"plugin_options":              pluginOptions,
			"privacy_policy_link":         v.PrivacyPolicyLink,
			"project":                     v.Project,
			"project_name":                v.ProjectName,
			"project_uuid":                v.ProjectUuid,
			"promotion_campaigns":         promotionCampaigns,
			"quotas":                      quotas,
			"resource_options":            resourceOptions,
			"roles":                       roles,
			"scope":                       v.Scope,
			"scope_error_message":         v.ScopeErrorMessage,
			"scope_name":                  v.ScopeName,
			"scope_state":                 v.ScopeState,
			"scope_uuid":                  v.ScopeUuid,
			"screenshots":                 screenshots,
			"shared":                      v.Shared,
			"slug":                        v.Slug,
			"state":                       v.State,
			"thumbnail":                   v.Thumbnail,
			"total_cost":                  v.TotalCost,
			"total_cost_estimated":        v.TotalCostEstimated,
			"total_customers":             v.TotalCustomers,
			"type":                        v.PublicOfferingsType,
			"url":                         v.Url,
			"user_has_consent":            v.UserHasConsent,
			"uuid":                        v.Uuid,
			"vendor_details":              v.VendorDetails,
		})

	return objVal, diags
}

func (v PublicOfferingsValue) Equal(o attr.Value) bool {
	other, ok := o.(PublicOfferingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccessUrl.Equal(other.AccessUrl) {
		return false
	}

	if !v.BackendId.Equal(other.BackendId) {
		return false
	}

	if !v.Billable.Equal(other.Billable) {
		return false
	}

	if !v.Category.Equal(other.Category) {
		return false
	}

	if !v.CategoryTitle.Equal(other.CategoryTitle) {
		return false
	}

	if !v.CategoryUuid.Equal(other.CategoryUuid) {
		return false
	}

	if !v.CitationCount.Equal(other.CitationCount) {
		return false
	}

	if !v.ComplianceChecklist.Equal(other.ComplianceChecklist) {
		return false
	}

	if !v.Components.Equal(other.Components) {
		return false
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Customer.Equal(other.Customer) {
		return false
	}

	if !v.CustomerName.Equal(other.CustomerName) {
		return false
	}

	if !v.CustomerUuid.Equal(other.CustomerUuid) {
		return false
	}

	if !v.DataciteDoi.Equal(other.DataciteDoi) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Endpoints.Equal(other.Endpoints) {
		return false
	}

	if !v.Files.Equal(other.Files) {
		return false
	}

	if !v.FullDescription.Equal(other.FullDescription) {
		return false
	}

	if !v.GettingStarted.Equal(other.GettingStarted) {
		return false
	}

	if !v.GoogleCalendarIsPublic.Equal(other.GoogleCalendarIsPublic) {
		return false
	}

	if !v.GoogleCalendarLink.Equal(other.GoogleCalendarLink) {
		return false
	}

	if !v.HasComplianceRequirements.Equal(other.HasComplianceRequirements) {
		return false
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.IntegrationGuide.Equal(other.IntegrationGuide) {
		return false
	}

	if !v.Latitude.Equal(other.Latitude) {
		return false
	}

	if !v.Longitude.Equal(other.Longitude) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.OrderCount.Equal(other.OrderCount) {
		return false
	}

	if !v.OrganizationGroups.Equal(other.OrganizationGroups) {
		return false
	}

	if !v.ParentDescription.Equal(other.ParentDescription) {
		return false
	}

	if !v.ParentName.Equal(other.ParentName) {
		return false
	}

	if !v.ParentUuid.Equal(other.ParentUuid) {
		return false
	}

	if !v.PausedReason.Equal(other.PausedReason) {
		return false
	}

	if !v.Plans.Equal(other.Plans) {
		return false
	}

	if !v.PluginOptions.Equal(other.PluginOptions) {
		return false
	}

	if !v.PrivacyPolicyLink.Equal(other.PrivacyPolicyLink) {
		return false
	}

	if !v.Project.Equal(other.Project) {
		return false
	}

	if !v.ProjectName.Equal(other.ProjectName) {
		return false
	}

	if !v.ProjectUuid.Equal(other.ProjectUuid) {
		return false
	}

	if !v.PromotionCampaigns.Equal(other.PromotionCampaigns) {
		return false
	}

	if !v.Quotas.Equal(other.Quotas) {
		return false
	}

	if !v.ResourceOptions.Equal(other.ResourceOptions) {
		return false
	}

	if !v.Roles.Equal(other.Roles) {
		return false
	}

	if !v.Scope.Equal(other.Scope) {
		return false
	}

	if !v.ScopeErrorMessage.Equal(other.ScopeErrorMessage) {
		return false
	}

	if !v.ScopeName.Equal(other.ScopeName) {
		return false
	}

	if !v.ScopeState.Equal(other.ScopeState) {
		return false
	}

	if !v.ScopeUuid.Equal(other.ScopeUuid) {
		return false
	}

	if !v.Screenshots.Equal(other.Screenshots) {
		return false
	}

	if !v.Shared.Equal(other.Shared) {
		return false
	}

	if !v.Slug.Equal(other.Slug) {
		return false
	}

	if !v.State.Equal(other.State) {
		return false
	}

	if !v.Thumbnail.Equal(other.Thumbnail) {
		return false
	}

	if !v.TotalCost.Equal(other.TotalCost) {
		return false
	}

	if !v.TotalCostEstimated.Equal(other.TotalCostEstimated) {
		return false
	}

	if !v.TotalCustomers.Equal(other.TotalCustomers) {
		return false
	}

	if !v.PublicOfferingsType.Equal(other.PublicOfferingsType) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.UserHasConsent.Equal(other.UserHasConsent) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	if !v.VendorDetails.Equal(other.VendorDetails) {
		return false
	}

	return true
}

func (v PublicOfferingsValue) Type(ctx context.Context) attr.Type {
	return PublicOfferingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PublicOfferingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"access_url":           basetypes.StringType{},
		"backend_id":           basetypes.StringType{},
		"billable":             basetypes.BoolType{},
		"category":             basetypes.StringType{},
		"category_title":       basetypes.StringType{},
		"category_uuid":        basetypes.StringType{},
		"citation_count":       basetypes.Int64Type{},
		"compliance_checklist": basetypes.StringType{},
		"components": basetypes.ListType{
			ElemType: ComponentsValue{}.Type(ctx),
		},
		"created":       basetypes.StringType{},
		"customer":      basetypes.StringType{},
		"customer_name": basetypes.StringType{},
		"customer_uuid": basetypes.StringType{},
		"datacite_doi":  basetypes.StringType{},
		"description":   basetypes.StringType{},
		"endpoints": basetypes.ListType{
			ElemType: EndpointsValue{}.Type(ctx),
		},
		"files": basetypes.ListType{
			ElemType: FilesValue{}.Type(ctx),
		},
		"full_description":            basetypes.StringType{},
		"getting_started":             basetypes.StringType{},
		"google_calendar_is_public":   basetypes.BoolType{},
		"google_calendar_link":        basetypes.StringType{},
		"has_compliance_requirements": basetypes.BoolType{},
		"image":                       basetypes.StringType{},
		"integration_guide":           basetypes.StringType{},
		"latitude":                    basetypes.Float64Type{},
		"longitude":                   basetypes.Float64Type{},
		"name":                        basetypes.StringType{},
		"options": basetypes.ObjectType{
			AttrTypes: OptionsValue{}.AttributeTypes(ctx),
		},
		"order_count": basetypes.Int64Type{},
		"organization_groups": basetypes.ListType{
			ElemType: OrganizationGroupsValue{}.Type(ctx),
		},
		"parent_description": basetypes.StringType{},
		"parent_name":        basetypes.StringType{},
		"parent_uuid":        basetypes.StringType{},
		"paused_reason":      basetypes.StringType{},
		"plans": basetypes.ListType{
			ElemType: PlansValue{}.Type(ctx),
		},
		"plugin_options": basetypes.ObjectType{
			AttrTypes: PluginOptionsValue{}.AttributeTypes(ctx),
		},
		"privacy_policy_link": basetypes.StringType{},
		"project":             basetypes.StringType{},
		"project_name":        basetypes.StringType{},
		"project_uuid":        basetypes.StringType{},
		"promotion_campaigns": basetypes.ListType{
			ElemType: PromotionCampaignsValue{}.Type(ctx),
		},
		"quotas": basetypes.ListType{
			ElemType: QuotasValue{}.Type(ctx),
		},
		"resource_options": basetypes.ObjectType{
			AttrTypes: ResourceOptionsValue{}.AttributeTypes(ctx),
		},
		"roles": basetypes.ListType{
			ElemType: RolesValue{}.Type(ctx),
		},
		"scope":               basetypes.StringType{},
		"scope_error_message": basetypes.StringType{},
		"scope_name":          basetypes.StringType{},
		"scope_state":         basetypes.StringType{},
		"scope_uuid":          basetypes.StringType{},
		"screenshots": basetypes.ListType{
			ElemType: ScreenshotsValue{}.Type(ctx),
		},
		"shared":               basetypes.BoolType{},
		"slug":                 basetypes.StringType{},
		"state":                basetypes.StringType{},
		"thumbnail":            basetypes.StringType{},
		"total_cost":           basetypes.Int64Type{},
		"total_cost_estimated": basetypes.Int64Type{},
		"total_customers":      basetypes.Int64Type{},
		"type":                 basetypes.StringType{},
		"url":                  basetypes.StringType{},
		"user_has_consent":     basetypes.BoolType{},
		"uuid":                 basetypes.StringType{},
		"vendor_details":       basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ComponentsType{}

type ComponentsType struct {
	basetypes.ObjectType
}

func (t ComponentsType) Equal(o attr.Type) bool {
	other, ok := o.(ComponentsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ComponentsType) String() string {
	return "ComponentsType"
}

func (t ComponentsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	articleCodeAttribute, ok := attributes["article_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`article_code is missing from object`)

		return nil, diags
	}

	articleCodeVal, ok := articleCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`article_code expected to be basetypes.StringValue, was: %T`, articleCodeAttribute))
	}

	billingTypeAttribute, ok := attributes["billing_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_type is missing from object`)

		return nil, diags
	}

	billingTypeVal, ok := billingTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_type expected to be basetypes.StringValue, was: %T`, billingTypeAttribute))
	}

	defaultLimitAttribute, ok := attributes["default_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_limit is missing from object`)

		return nil, diags
	}

	defaultLimitVal, ok := defaultLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_limit expected to be basetypes.Int64Value, was: %T`, defaultLimitAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	factorAttribute, ok := attributes["factor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`factor is missing from object`)

		return nil, diags
	}

	factorVal, ok := factorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`factor expected to be basetypes.Int64Value, was: %T`, factorAttribute))
	}

	isBooleanAttribute, ok := attributes["is_boolean"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_boolean is missing from object`)

		return nil, diags
	}

	isBooleanVal, ok := isBooleanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_boolean expected to be basetypes.BoolValue, was: %T`, isBooleanAttribute))
	}

	isBuiltinAttribute, ok := attributes["is_builtin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_builtin is missing from object`)

		return nil, diags
	}

	isBuiltinVal, ok := isBuiltinAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_builtin expected to be basetypes.BoolValue, was: %T`, isBuiltinAttribute))
	}

	isPrepaidAttribute, ok := attributes["is_prepaid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_prepaid is missing from object`)

		return nil, diags
	}

	isPrepaidVal, ok := isPrepaidAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_prepaid expected to be basetypes.BoolValue, was: %T`, isPrepaidAttribute))
	}

	limitAmountAttribute, ok := attributes["limit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_amount is missing from object`)

		return nil, diags
	}

	limitAmountVal, ok := limitAmountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_amount expected to be basetypes.Int64Value, was: %T`, limitAmountAttribute))
	}

	maxAvailableLimitAttribute, ok := attributes["max_available_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_available_limit is missing from object`)

		return nil, diags
	}

	maxAvailableLimitVal, ok := maxAvailableLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_available_limit expected to be basetypes.Int64Value, was: %T`, maxAvailableLimitAttribute))
	}

	maxPrepaidDurationAttribute, ok := attributes["max_prepaid_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_prepaid_duration is missing from object`)

		return nil, diags
	}

	maxPrepaidDurationVal, ok := maxPrepaidDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_prepaid_duration expected to be basetypes.Int64Value, was: %T`, maxPrepaidDurationAttribute))
	}

	maxValueAttribute, ok := attributes["max_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_value is missing from object`)

		return nil, diags
	}

	maxValueVal, ok := maxValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_value expected to be basetypes.Int64Value, was: %T`, maxValueAttribute))
	}

	measuredUnitAttribute, ok := attributes["measured_unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`measured_unit is missing from object`)

		return nil, diags
	}

	measuredUnitVal, ok := measuredUnitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`measured_unit expected to be basetypes.StringValue, was: %T`, measuredUnitAttribute))
	}

	minPrepaidDurationAttribute, ok := attributes["min_prepaid_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_prepaid_duration is missing from object`)

		return nil, diags
	}

	minPrepaidDurationVal, ok := minPrepaidDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_prepaid_duration expected to be basetypes.Int64Value, was: %T`, minPrepaidDurationAttribute))
	}

	minValueAttribute, ok := attributes["min_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_value is missing from object`)

		return nil, diags
	}

	minValueVal, ok := minValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_value expected to be basetypes.Int64Value, was: %T`, minValueAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	overageComponentAttribute, ok := attributes["overage_component"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overage_component is missing from object`)

		return nil, diags
	}

	overageComponentVal, ok := overageComponentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overage_component expected to be basetypes.StringValue, was: %T`, overageComponentAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	unitFactorAttribute, ok := attributes["unit_factor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_factor is missing from object`)

		return nil, diags
	}

	unitFactorVal, ok := unitFactorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_factor expected to be basetypes.Int64Value, was: %T`, unitFactorAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ComponentsValue{
		ArticleCode:        articleCodeVal,
		BillingType:        billingTypeVal,
		DefaultLimit:       defaultLimitVal,
		Description:        descriptionVal,
		Factor:             factorVal,
		IsBoolean:          isBooleanVal,
		IsBuiltin:          isBuiltinVal,
		IsPrepaid:          isPrepaidVal,
		LimitAmount:        limitAmountVal,
		MaxAvailableLimit:  maxAvailableLimitVal,
		MaxPrepaidDuration: maxPrepaidDurationVal,
		MaxValue:           maxValueVal,
		MeasuredUnit:       measuredUnitVal,
		MinPrepaidDuration: minPrepaidDurationVal,
		MinValue:           minValueVal,
		Name:               nameVal,
		OverageComponent:   overageComponentVal,
		ComponentsType:     typeVal,
		UnitFactor:         unitFactorVal,
		Uuid:               uuidVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewComponentsValueNull() ComponentsValue {
	return ComponentsValue{
		state: attr.ValueStateNull,
	}
}

func NewComponentsValueUnknown() ComponentsValue {
	return ComponentsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewComponentsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ComponentsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ComponentsValue Attribute Value",
				"While creating a ComponentsValue value, a missing attribute value was detected. "+
					"A ComponentsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ComponentsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ComponentsValue Attribute Type",
				"While creating a ComponentsValue value, an invalid attribute value was detected. "+
					"A ComponentsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ComponentsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ComponentsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ComponentsValue Attribute Value",
				"While creating a ComponentsValue value, an extra attribute value was detected. "+
					"A ComponentsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ComponentsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewComponentsValueUnknown(), diags
	}

	articleCodeAttribute, ok := attributes["article_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`article_code is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	articleCodeVal, ok := articleCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`article_code expected to be basetypes.StringValue, was: %T`, articleCodeAttribute))
	}

	billingTypeAttribute, ok := attributes["billing_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`billing_type is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	billingTypeVal, ok := billingTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`billing_type expected to be basetypes.StringValue, was: %T`, billingTypeAttribute))
	}

	defaultLimitAttribute, ok := attributes["default_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_limit is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	defaultLimitVal, ok := defaultLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_limit expected to be basetypes.Int64Value, was: %T`, defaultLimitAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	factorAttribute, ok := attributes["factor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`factor is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	factorVal, ok := factorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`factor expected to be basetypes.Int64Value, was: %T`, factorAttribute))
	}

	isBooleanAttribute, ok := attributes["is_boolean"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_boolean is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	isBooleanVal, ok := isBooleanAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_boolean expected to be basetypes.BoolValue, was: %T`, isBooleanAttribute))
	}

	isBuiltinAttribute, ok := attributes["is_builtin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_builtin is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	isBuiltinVal, ok := isBuiltinAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_builtin expected to be basetypes.BoolValue, was: %T`, isBuiltinAttribute))
	}

	isPrepaidAttribute, ok := attributes["is_prepaid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_prepaid is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	isPrepaidVal, ok := isPrepaidAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_prepaid expected to be basetypes.BoolValue, was: %T`, isPrepaidAttribute))
	}

	limitAmountAttribute, ok := attributes["limit_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit_amount is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	limitAmountVal, ok := limitAmountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit_amount expected to be basetypes.Int64Value, was: %T`, limitAmountAttribute))
	}

	maxAvailableLimitAttribute, ok := attributes["max_available_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_available_limit is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	maxAvailableLimitVal, ok := maxAvailableLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_available_limit expected to be basetypes.Int64Value, was: %T`, maxAvailableLimitAttribute))
	}

	maxPrepaidDurationAttribute, ok := attributes["max_prepaid_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_prepaid_duration is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	maxPrepaidDurationVal, ok := maxPrepaidDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_prepaid_duration expected to be basetypes.Int64Value, was: %T`, maxPrepaidDurationAttribute))
	}

	maxValueAttribute, ok := attributes["max_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_value is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	maxValueVal, ok := maxValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_value expected to be basetypes.Int64Value, was: %T`, maxValueAttribute))
	}

	measuredUnitAttribute, ok := attributes["measured_unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`measured_unit is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	measuredUnitVal, ok := measuredUnitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`measured_unit expected to be basetypes.StringValue, was: %T`, measuredUnitAttribute))
	}

	minPrepaidDurationAttribute, ok := attributes["min_prepaid_duration"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_prepaid_duration is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	minPrepaidDurationVal, ok := minPrepaidDurationAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_prepaid_duration expected to be basetypes.Int64Value, was: %T`, minPrepaidDurationAttribute))
	}

	minValueAttribute, ok := attributes["min_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_value is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	minValueVal, ok := minValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_value expected to be basetypes.Int64Value, was: %T`, minValueAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	overageComponentAttribute, ok := attributes["overage_component"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overage_component is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	overageComponentVal, ok := overageComponentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overage_component expected to be basetypes.StringValue, was: %T`, overageComponentAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	unitFactorAttribute, ok := attributes["unit_factor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_factor is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	unitFactorVal, ok := unitFactorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_factor expected to be basetypes.Int64Value, was: %T`, unitFactorAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewComponentsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewComponentsValueUnknown(), diags
	}

	return ComponentsValue{
		ArticleCode:        articleCodeVal,
		BillingType:        billingTypeVal,
		DefaultLimit:       defaultLimitVal,
		Description:        descriptionVal,
		Factor:             factorVal,
		IsBoolean:          isBooleanVal,
		IsBuiltin:          isBuiltinVal,
		IsPrepaid:          isPrepaidVal,
		LimitAmount:        limitAmountVal,
		MaxAvailableLimit:  maxAvailableLimitVal,
		MaxPrepaidDuration: maxPrepaidDurationVal,
		MaxValue:           maxValueVal,
		MeasuredUnit:       measuredUnitVal,
		MinPrepaidDuration: minPrepaidDurationVal,
		MinValue:           minValueVal,
		Name:               nameVal,
		OverageComponent:   overageComponentVal,
		ComponentsType:     typeVal,
		UnitFactor:         unitFactorVal,
		Uuid:               uuidVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewComponentsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ComponentsValue {
	object, diags := NewComponentsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewComponentsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ComponentsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewComponentsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewComponentsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewComponentsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewComponentsValueMust(ComponentsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ComponentsType) ValueType(ctx context.Context) attr.Value {
	return ComponentsValue{}
}

var _ basetypes.ObjectValuable = ComponentsValue{}

type ComponentsValue struct {
	ArticleCode        basetypes.StringValue `tfsdk:"article_code"`
	BillingType        basetypes.StringValue `tfsdk:"billing_type"`
	DefaultLimit       basetypes.Int64Value  `tfsdk:"default_limit"`
	Description        basetypes.StringValue `tfsdk:"description"`
	Factor             basetypes.Int64Value  `tfsdk:"factor"`
	IsBoolean          basetypes.BoolValue   `tfsdk:"is_boolean"`
	IsBuiltin          basetypes.BoolValue   `tfsdk:"is_builtin"`
	IsPrepaid          basetypes.BoolValue   `tfsdk:"is_prepaid"`
	LimitAmount        basetypes.Int64Value  `tfsdk:"limit_amount"`
	MaxAvailableLimit  basetypes.Int64Value  `tfsdk:"max_available_limit"`
	MaxPrepaidDuration basetypes.Int64Value  `tfsdk:"max_prepaid_duration"`
	MaxValue           basetypes.Int64Value  `tfsdk:"max_value"`
	MeasuredUnit       basetypes.StringValue `tfsdk:"measured_unit"`
	MinPrepaidDuration basetypes.Int64Value  `tfsdk:"min_prepaid_duration"`
	MinValue           basetypes.Int64Value  `tfsdk:"min_value"`
	Name               basetypes.StringValue `tfsdk:"name"`
	OverageComponent   basetypes.StringValue `tfsdk:"overage_component"`
	ComponentsType     basetypes.StringValue `tfsdk:"type"`
	UnitFactor         basetypes.Int64Value  `tfsdk:"unit_factor"`
	Uuid               basetypes.StringValue `tfsdk:"uuid"`
	state              attr.ValueState
}

func (v ComponentsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 20)

	var val tftypes.Value
	var err error

	attrTypes["article_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["billing_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["default_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["factor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_boolean"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_builtin"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["is_prepaid"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["limit_amount"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_available_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_prepaid_duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["measured_unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["min_prepaid_duration"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["overage_component"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unit_factor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 20)

		val, err = v.ArticleCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["article_code"] = val

		val, err = v.BillingType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["billing_type"] = val

		val, err = v.DefaultLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_limit"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Factor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["factor"] = val

		val, err = v.IsBoolean.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_boolean"] = val

		val, err = v.IsBuiltin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_builtin"] = val

		val, err = v.IsPrepaid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_prepaid"] = val

		val, err = v.LimitAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit_amount"] = val

		val, err = v.MaxAvailableLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_available_limit"] = val

		val, err = v.MaxPrepaidDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_prepaid_duration"] = val

		val, err = v.MaxValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_value"] = val

		val, err = v.MeasuredUnit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["measured_unit"] = val

		val, err = v.MinPrepaidDuration.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_prepaid_duration"] = val

		val, err = v.MinValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_value"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OverageComponent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overage_component"] = val

		val, err = v.ComponentsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.UnitFactor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit_factor"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ComponentsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ComponentsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ComponentsValue) String() string {
	return "ComponentsValue"
}

func (v ComponentsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"article_code":         basetypes.StringType{},
		"billing_type":         basetypes.StringType{},
		"default_limit":        basetypes.Int64Type{},
		"description":          basetypes.StringType{},
		"factor":               basetypes.Int64Type{},
		"is_boolean":           basetypes.BoolType{},
		"is_builtin":           basetypes.BoolType{},
		"is_prepaid":           basetypes.BoolType{},
		"limit_amount":         basetypes.Int64Type{},
		"max_available_limit":  basetypes.Int64Type{},
		"max_prepaid_duration": basetypes.Int64Type{},
		"max_value":            basetypes.Int64Type{},
		"measured_unit":        basetypes.StringType{},
		"min_prepaid_duration": basetypes.Int64Type{},
		"min_value":            basetypes.Int64Type{},
		"name":                 basetypes.StringType{},
		"overage_component":    basetypes.StringType{},
		"type":                 basetypes.StringType{},
		"unit_factor":          basetypes.Int64Type{},
		"uuid":                 basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"article_code":         v.ArticleCode,
			"billing_type":         v.BillingType,
			"default_limit":        v.DefaultLimit,
			"description":          v.Description,
			"factor":               v.Factor,
			"is_boolean":           v.IsBoolean,
			"is_builtin":           v.IsBuiltin,
			"is_prepaid":           v.IsPrepaid,
			"limit_amount":         v.LimitAmount,
			"max_available_limit":  v.MaxAvailableLimit,
			"max_prepaid_duration": v.MaxPrepaidDuration,
			"max_value":            v.MaxValue,
			"measured_unit":        v.MeasuredUnit,
			"min_prepaid_duration": v.MinPrepaidDuration,
			"min_value":            v.MinValue,
			"name":                 v.Name,
			"overage_component":    v.OverageComponent,
			"type":                 v.ComponentsType,
			"unit_factor":          v.UnitFactor,
			"uuid":                 v.Uuid,
		})

	return objVal, diags
}

func (v ComponentsValue) Equal(o attr.Value) bool {
	other, ok := o.(ComponentsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArticleCode.Equal(other.ArticleCode) {
		return false
	}

	if !v.BillingType.Equal(other.BillingType) {
		return false
	}

	if !v.DefaultLimit.Equal(other.DefaultLimit) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Factor.Equal(other.Factor) {
		return false
	}

	if !v.IsBoolean.Equal(other.IsBoolean) {
		return false
	}

	if !v.IsBuiltin.Equal(other.IsBuiltin) {
		return false
	}

	if !v.IsPrepaid.Equal(other.IsPrepaid) {
		return false
	}

	if !v.LimitAmount.Equal(other.LimitAmount) {
		return false
	}

	if !v.MaxAvailableLimit.Equal(other.MaxAvailableLimit) {
		return false
	}

	if !v.MaxPrepaidDuration.Equal(other.MaxPrepaidDuration) {
		return false
	}

	if !v.MaxValue.Equal(other.MaxValue) {
		return false
	}

	if !v.MeasuredUnit.Equal(other.MeasuredUnit) {
		return false
	}

	if !v.MinPrepaidDuration.Equal(other.MinPrepaidDuration) {
		return false
	}

	if !v.MinValue.Equal(other.MinValue) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OverageComponent.Equal(other.OverageComponent) {
		return false
	}

	if !v.ComponentsType.Equal(other.ComponentsType) {
		return false
	}

	if !v.UnitFactor.Equal(other.UnitFactor) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v ComponentsValue) Type(ctx context.Context) attr.Type {
	return ComponentsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ComponentsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"article_code":         basetypes.StringType{},
		"billing_type":         basetypes.StringType{},
		"default_limit":        basetypes.Int64Type{},
		"description":          basetypes.StringType{},
		"factor":               basetypes.Int64Type{},
		"is_boolean":           basetypes.BoolType{},
		"is_builtin":           basetypes.BoolType{},
		"is_prepaid":           basetypes.BoolType{},
		"limit_amount":         basetypes.Int64Type{},
		"max_available_limit":  basetypes.Int64Type{},
		"max_prepaid_duration": basetypes.Int64Type{},
		"max_value":            basetypes.Int64Type{},
		"measured_unit":        basetypes.StringType{},
		"min_prepaid_duration": basetypes.Int64Type{},
		"min_value":            basetypes.Int64Type{},
		"name":                 basetypes.StringType{},
		"overage_component":    basetypes.StringType{},
		"type":                 basetypes.StringType{},
		"unit_factor":          basetypes.Int64Type{},
		"uuid":                 basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EndpointsType{}

type EndpointsType struct {
	basetypes.ObjectType
}

func (t EndpointsType) Equal(o attr.Type) bool {
	other, ok := o.(EndpointsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EndpointsType) String() string {
	return "EndpointsType"
}

func (t EndpointsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EndpointsValue{
		Name:  nameVal,
		Url:   urlVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewEndpointsValueNull() EndpointsValue {
	return EndpointsValue{
		state: attr.ValueStateNull,
	}
}

func NewEndpointsValueUnknown() EndpointsValue {
	return EndpointsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEndpointsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EndpointsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EndpointsValue Attribute Value",
				"While creating a EndpointsValue value, a missing attribute value was detected. "+
					"A EndpointsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EndpointsValue Attribute Type",
				"While creating a EndpointsValue value, an invalid attribute value was detected. "+
					"A EndpointsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EndpointsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EndpointsValue Attribute Value",
				"While creating a EndpointsValue value, an extra attribute value was detected. "+
					"A EndpointsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EndpointsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEndpointsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewEndpointsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewEndpointsValueUnknown(), diags
	}

	return EndpointsValue{
		Name:  nameVal,
		Url:   urlVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewEndpointsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EndpointsValue {
	object, diags := NewEndpointsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEndpointsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EndpointsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEndpointsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEndpointsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEndpointsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEndpointsValueMust(EndpointsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EndpointsType) ValueType(ctx context.Context) attr.Value {
	return EndpointsValue{}
}

var _ basetypes.ObjectValuable = EndpointsValue{}

type EndpointsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Url   basetypes.StringValue `tfsdk:"url"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v EndpointsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EndpointsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EndpointsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EndpointsValue) String() string {
	return "EndpointsValue"
}

func (v EndpointsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"url":  basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"url":  v.Url,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v EndpointsValue) Equal(o attr.Value) bool {
	other, ok := o.(EndpointsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v EndpointsValue) Type(ctx context.Context) attr.Type {
	return EndpointsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EndpointsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"url":  basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = FilesType{}

type FilesType struct {
	basetypes.ObjectType
}

func (t FilesType) Equal(o attr.Type) bool {
	other, ok := o.(FilesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FilesType) String() string {
	return "FilesType"
}

func (t FilesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return nil, diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FilesValue{
		Created: createdVal,
		File:    fileVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFilesValueNull() FilesValue {
	return FilesValue{
		state: attr.ValueStateNull,
	}
}

func NewFilesValueUnknown() FilesValue {
	return FilesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFilesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FilesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FilesValue Attribute Value",
				"While creating a FilesValue value, a missing attribute value was detected. "+
					"A FilesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FilesValue Attribute Type",
				"While creating a FilesValue value, an invalid attribute value was detected. "+
					"A FilesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FilesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FilesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FilesValue Attribute Value",
				"While creating a FilesValue value, an extra attribute value was detected. "+
					"A FilesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FilesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	fileAttribute, ok := attributes["file"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`file is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	fileVal, ok := fileAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`file expected to be basetypes.StringValue, was: %T`, fileAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFilesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewFilesValueUnknown(), diags
	}

	return FilesValue{
		Created: createdVal,
		File:    fileVal,
		Name:    nameVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewFilesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FilesValue {
	object, diags := NewFilesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFilesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FilesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFilesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFilesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFilesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFilesValueMust(FilesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FilesType) ValueType(ctx context.Context) attr.Value {
	return FilesValue{}
}

var _ basetypes.ObjectValuable = FilesValue{}

type FilesValue struct {
	Created basetypes.StringValue `tfsdk:"created"`
	File    basetypes.StringValue `tfsdk:"file"`
	Name    basetypes.StringValue `tfsdk:"name"`
	state   attr.ValueState
}

func (v FilesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["file"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.File.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["file"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FilesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FilesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FilesValue) String() string {
	return "FilesValue"
}

func (v FilesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created": basetypes.StringType{},
		"file":    basetypes.StringType{},
		"name":    basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created": v.Created,
			"file":    v.File,
			"name":    v.Name,
		})

	return objVal, diags
}

func (v FilesValue) Equal(o attr.Value) bool {
	other, ok := o.(FilesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.File.Equal(other.File) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v FilesValue) Type(ctx context.Context) attr.Type {
	return FilesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FilesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created": basetypes.StringType{},
		"file":    basetypes.StringType{},
		"name":    basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	orderAttribute, ok := attributes["order"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order is missing from object`)

		return nil, diags
	}

	orderVal, ok := orderAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order expected to be basetypes.ListValue, was: %T`, orderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		Options: optionsVal,
		Order:   orderVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	orderAttribute, ok := attributes["order"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	orderVal, ok := orderAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order expected to be basetypes.ListValue, was: %T`, orderAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		Options: optionsVal,
		Order:   orderVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	Options basetypes.MapValue  `tfsdk:"options"`
	Order   basetypes.ListValue `tfsdk:"order"`
	state   attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["options"] = basetypes.MapType{
		ElemType: OptionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["order"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.Order.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["order"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	options := types.MapValueMust(
		OptionsType{
			basetypes.ObjectType{
				AttrTypes: OptionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Options.Elements(),
	)

	if v.Options.IsNull() {
		options = types.MapNull(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Options.IsUnknown() {
		options = types.MapUnknown(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var orderVal basetypes.ListValue
	switch {
	case v.Order.IsUnknown():
		orderVal = types.ListUnknown(types.StringType)
	case v.Order.IsNull():
		orderVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		orderVal, d = types.ListValue(types.StringType, v.Order.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"order": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"order": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"options": options,
			"order":   orderVal,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.Order.Equal(other.Order) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"order": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	choicesAttribute, ok := attributes["choices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`choices is missing from object`)

		return nil, diags
	}

	choicesVal, ok := choicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`choices expected to be basetypes.ListValue, was: %T`, choicesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return nil, diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	helpTextAttribute, ok := attributes["help_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`help_text is missing from object`)

		return nil, diags
	}

	helpTextVal, ok := helpTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`help_text expected to be basetypes.StringValue, was: %T`, helpTextAttribute))
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return nil, diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return nil, diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return nil, diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return nil, diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		Choices:     choicesVal,
		Default:     defaultVal,
		HelpText:    helpTextVal,
		Label:       labelVal,
		Max:         maxVal,
		Min:         minVal,
		Required:    requiredVal,
		OptionsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	choicesAttribute, ok := attributes["choices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`choices is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	choicesVal, ok := choicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`choices expected to be basetypes.ListValue, was: %T`, choicesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	helpTextAttribute, ok := attributes["help_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`help_text is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	helpTextVal, ok := helpTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`help_text expected to be basetypes.StringValue, was: %T`, helpTextAttribute))
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		Choices:     choicesVal,
		Default:     defaultVal,
		HelpText:    helpTextVal,
		Label:       labelVal,
		Max:         maxVal,
		Min:         minVal,
		Required:    requiredVal,
		OptionsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	Choices     basetypes.ListValue   `tfsdk:"choices"`
	Default     basetypes.StringValue `tfsdk:"default"`
	HelpText    basetypes.StringValue `tfsdk:"help_text"`
	Label       basetypes.StringValue `tfsdk:"label"`
	Max         basetypes.Int64Value  `tfsdk:"max"`
	Min         basetypes.Int64Value  `tfsdk:"min"`
	Required    basetypes.BoolValue   `tfsdk:"required"`
	OptionsType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["choices"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["help_text"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Choices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["choices"] = val

		val, err = v.Default.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default"] = val

		val, err = v.HelpText.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["help_text"] = val

		val, err = v.Label.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label"] = val

		val, err = v.Max.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max"] = val

		val, err = v.Min.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min"] = val

		val, err = v.Required.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required"] = val

		val, err = v.OptionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var choicesVal basetypes.ListValue
	switch {
	case v.Choices.IsUnknown():
		choicesVal = types.ListUnknown(types.StringType)
	case v.Choices.IsNull():
		choicesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		choicesVal, d = types.ListValue(types.StringType, v.Choices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"choices": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default":   basetypes.StringType{},
			"help_text": basetypes.StringType{},
			"label":     basetypes.StringType{},
			"max":       basetypes.Int64Type{},
			"min":       basetypes.Int64Type{},
			"required":  basetypes.BoolType{},
			"type":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"choices": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default":   basetypes.StringType{},
		"help_text": basetypes.StringType{},
		"label":     basetypes.StringType{},
		"max":       basetypes.Int64Type{},
		"min":       basetypes.Int64Type{},
		"required":  basetypes.BoolType{},
		"type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"choices":   choicesVal,
			"default":   v.Default,
			"help_text": v.HelpText,
			"label":     v.Label,
			"max":       v.Max,
			"min":       v.Min,
			"required":  v.Required,
			"type":      v.OptionsType,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Choices.Equal(other.Choices) {
		return false
	}

	if !v.Default.Equal(other.Default) {
		return false
	}

	if !v.HelpText.Equal(other.HelpText) {
		return false
	}

	if !v.Label.Equal(other.Label) {
		return false
	}

	if !v.Max.Equal(other.Max) {
		return false
	}

	if !v.Min.Equal(other.Min) {
		return false
	}

	if !v.Required.Equal(other.Required) {
		return false
	}

	if !v.OptionsType.Equal(other.OptionsType) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"choices": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default":   basetypes.StringType{},
		"help_text": basetypes.StringType{},
		"label":     basetypes.StringType{},
		"max":       basetypes.Int64Type{},
		"min":       basetypes.Int64Type{},
		"required":  basetypes.BoolType{},
		"type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OrganizationGroupsType{}

type OrganizationGroupsType struct {
	basetypes.ObjectType
}

func (t OrganizationGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(OrganizationGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrganizationGroupsType) String() string {
	return "OrganizationGroupsType"
}

func (t OrganizationGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customersCountAttribute, ok := attributes["customers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customers_count is missing from object`)

		return nil, diags
	}

	customersCountVal, ok := customersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customers_count expected to be basetypes.Int64Value, was: %T`, customersCountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	parentAttribute, ok := attributes["parent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent is missing from object`)

		return nil, diags
	}

	parentVal, ok := parentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent expected to be basetypes.StringValue, was: %T`, parentAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return nil, diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return nil, diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrganizationGroupsValue{
		CustomersCount: customersCountVal,
		Name:           nameVal,
		Parent:         parentVal,
		ParentName:     parentNameVal,
		ParentUuid:     parentUuidVal,
		Url:            urlVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrganizationGroupsValueNull() OrganizationGroupsValue {
	return OrganizationGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewOrganizationGroupsValueUnknown() OrganizationGroupsValue {
	return OrganizationGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrganizationGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrganizationGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrganizationGroupsValue Attribute Value",
				"While creating a OrganizationGroupsValue value, a missing attribute value was detected. "+
					"A OrganizationGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrganizationGroupsValue Attribute Type",
				"While creating a OrganizationGroupsValue value, an invalid attribute value was detected. "+
					"A OrganizationGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrganizationGroupsValue Attribute Value",
				"While creating a OrganizationGroupsValue value, an extra attribute value was detected. "+
					"A OrganizationGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrganizationGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrganizationGroupsValueUnknown(), diags
	}

	customersCountAttribute, ok := attributes["customers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customers_count is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	customersCountVal, ok := customersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customers_count expected to be basetypes.Int64Value, was: %T`, customersCountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	parentAttribute, ok := attributes["parent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentVal, ok := parentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent expected to be basetypes.StringValue, was: %T`, parentAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewOrganizationGroupsValueUnknown(), diags
	}

	return OrganizationGroupsValue{
		CustomersCount: customersCountVal,
		Name:           nameVal,
		Parent:         parentVal,
		ParentName:     parentNameVal,
		ParentUuid:     parentUuidVal,
		Url:            urlVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrganizationGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrganizationGroupsValue {
	object, diags := NewOrganizationGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrganizationGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrganizationGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrganizationGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrganizationGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrganizationGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrganizationGroupsValueMust(OrganizationGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrganizationGroupsType) ValueType(ctx context.Context) attr.Value {
	return OrganizationGroupsValue{}
}

var _ basetypes.ObjectValuable = OrganizationGroupsValue{}

type OrganizationGroupsValue struct {
	CustomersCount basetypes.Int64Value  `tfsdk:"customers_count"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Parent         basetypes.StringValue `tfsdk:"parent"`
	ParentName     basetypes.StringValue `tfsdk:"parent_name"`
	ParentUuid     basetypes.StringValue `tfsdk:"parent_uuid"`
	Url            basetypes.StringValue `tfsdk:"url"`
	Uuid           basetypes.StringValue `tfsdk:"uuid"`
	state          attr.ValueState
}

func (v OrganizationGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["customers_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CustomersCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customers_count"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Parent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent"] = val

		val, err = v.ParentName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_name"] = val

		val, err = v.ParentUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrganizationGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrganizationGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrganizationGroupsValue) String() string {
	return "OrganizationGroupsValue"
}

func (v OrganizationGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"customers_count": basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"parent":          basetypes.StringType{},
		"parent_name":     basetypes.StringType{},
		"parent_uuid":     basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"customers_count": v.CustomersCount,
			"name":            v.Name,
			"parent":          v.Parent,
			"parent_name":     v.ParentName,
			"parent_uuid":     v.ParentUuid,
			"url":             v.Url,
			"uuid":            v.Uuid,
		})

	return objVal, diags
}

func (v OrganizationGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(OrganizationGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomersCount.Equal(other.CustomersCount) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Parent.Equal(other.Parent) {
		return false
	}

	if !v.ParentName.Equal(other.ParentName) {
		return false
	}

	if !v.ParentUuid.Equal(other.ParentUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v OrganizationGroupsValue) Type(ctx context.Context) attr.Type {
	return OrganizationGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrganizationGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"customers_count": basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"parent":          basetypes.StringType{},
		"parent_name":     basetypes.StringType{},
		"parent_uuid":     basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PlansType{}

type PlansType struct {
	basetypes.ObjectType
}

func (t PlansType) Equal(o attr.Type) bool {
	other, ok := o.(PlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PlansType) String() string {
	return "PlansType"
}

func (t PlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	archivedAttribute, ok := attributes["archived"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archived is missing from object`)

		return nil, diags
	}

	archivedVal, ok := archivedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archived expected to be basetypes.BoolValue, was: %T`, archivedAttribute))
	}

	articleCodeAttribute, ok := attributes["article_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`article_code is missing from object`)

		return nil, diags
	}

	articleCodeVal, ok := articleCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`article_code expected to be basetypes.StringValue, was: %T`, articleCodeAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return nil, diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	futurePricesAttribute, ok := attributes["future_prices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`future_prices is missing from object`)

		return nil, diags
	}

	futurePricesVal, ok := futurePricesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`future_prices expected to be basetypes.MapValue, was: %T`, futurePricesAttribute))
	}

	initPriceAttribute, ok := attributes["init_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`init_price is missing from object`)

		return nil, diags
	}

	initPriceVal, ok := initPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`init_price expected to be basetypes.Float64Value, was: %T`, initPriceAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return nil, diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	maxAmountAttribute, ok := attributes["max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_amount is missing from object`)

		return nil, diags
	}

	maxAmountVal, ok := maxAmountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_amount expected to be basetypes.Int64Value, was: %T`, maxAmountAttribute))
	}

	minimalPriceAttribute, ok := attributes["minimal_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimal_price is missing from object`)

		return nil, diags
	}

	minimalPriceVal, ok := minimalPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimal_price expected to be basetypes.Float64Value, was: %T`, minimalPriceAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	organizationGroupsAttribute, ok := attributes["organization_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_groups is missing from object`)

		return nil, diags
	}

	organizationGroupsVal, ok := organizationGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_groups expected to be basetypes.ListValue, was: %T`, organizationGroupsAttribute))
	}

	planTypeAttribute, ok := attributes["plan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_type is missing from object`)

		return nil, diags
	}

	planTypeVal, ok := planTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_type expected to be basetypes.StringValue, was: %T`, planTypeAttribute))
	}

	pricesAttribute, ok := attributes["prices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prices is missing from object`)

		return nil, diags
	}

	pricesVal, ok := pricesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prices expected to be basetypes.MapValue, was: %T`, pricesAttribute))
	}

	quotasAttribute, ok := attributes["quotas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quotas is missing from object`)

		return nil, diags
	}

	quotasVal, ok := quotasAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quotas expected to be basetypes.MapValue, was: %T`, quotasAttribute))
	}

	resourcesCountAttribute, ok := attributes["resources_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resources_count is missing from object`)

		return nil, diags
	}

	resourcesCountVal, ok := resourcesCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resources_count expected to be basetypes.Int64Value, was: %T`, resourcesCountAttribute))
	}

	switchPriceAttribute, ok := attributes["switch_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_price is missing from object`)

		return nil, diags
	}

	switchPriceVal, ok := switchPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_price expected to be basetypes.Float64Value, was: %T`, switchPriceAttribute))
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return nil, diags
	}

	unitVal, ok := unitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be basetypes.StringValue, was: %T`, unitAttribute))
	}

	unitPriceAttribute, ok := attributes["unit_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_price is missing from object`)

		return nil, diags
	}

	unitPriceVal, ok := unitPriceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_price expected to be basetypes.StringValue, was: %T`, unitPriceAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PlansValue{
		Archived:           archivedVal,
		ArticleCode:        articleCodeVal,
		BackendId:          backendIdVal,
		Description:        descriptionVal,
		FuturePrices:       futurePricesVal,
		InitPrice:          initPriceVal,
		IsActive:           isActiveVal,
		MaxAmount:          maxAmountVal,
		MinimalPrice:       minimalPriceVal,
		Name:               nameVal,
		OrganizationGroups: organizationGroupsVal,
		PlanType:           planTypeVal,
		Prices:             pricesVal,
		Quotas:             quotasVal,
		ResourcesCount:     resourcesCountVal,
		SwitchPrice:        switchPriceVal,
		Unit:               unitVal,
		UnitPrice:          unitPriceVal,
		Url:                urlVal,
		Uuid:               uuidVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPlansValueNull() PlansValue {
	return PlansValue{
		state: attr.ValueStateNull,
	}
}

func NewPlansValueUnknown() PlansValue {
	return PlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PlansValue Attribute Value",
				"While creating a PlansValue value, a missing attribute value was detected. "+
					"A PlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PlansValue Attribute Type",
				"While creating a PlansValue value, an invalid attribute value was detected. "+
					"A PlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PlansValue Attribute Value",
				"While creating a PlansValue value, an extra attribute value was detected. "+
					"A PlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPlansValueUnknown(), diags
	}

	archivedAttribute, ok := attributes["archived"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`archived is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	archivedVal, ok := archivedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`archived expected to be basetypes.BoolValue, was: %T`, archivedAttribute))
	}

	articleCodeAttribute, ok := attributes["article_code"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`article_code is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	articleCodeVal, ok := articleCodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`article_code expected to be basetypes.StringValue, was: %T`, articleCodeAttribute))
	}

	backendIdAttribute, ok := attributes["backend_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	backendIdVal, ok := backendIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id expected to be basetypes.StringValue, was: %T`, backendIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	futurePricesAttribute, ok := attributes["future_prices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`future_prices is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	futurePricesVal, ok := futurePricesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`future_prices expected to be basetypes.MapValue, was: %T`, futurePricesAttribute))
	}

	initPriceAttribute, ok := attributes["init_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`init_price is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	initPriceVal, ok := initPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`init_price expected to be basetypes.Float64Value, was: %T`, initPriceAttribute))
	}

	isActiveAttribute, ok := attributes["is_active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_active is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	isActiveVal, ok := isActiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_active expected to be basetypes.BoolValue, was: %T`, isActiveAttribute))
	}

	maxAmountAttribute, ok := attributes["max_amount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_amount is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	maxAmountVal, ok := maxAmountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_amount expected to be basetypes.Int64Value, was: %T`, maxAmountAttribute))
	}

	minimalPriceAttribute, ok := attributes["minimal_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimal_price is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	minimalPriceVal, ok := minimalPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimal_price expected to be basetypes.Float64Value, was: %T`, minimalPriceAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	organizationGroupsAttribute, ok := attributes["organization_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization_groups is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	organizationGroupsVal, ok := organizationGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization_groups expected to be basetypes.ListValue, was: %T`, organizationGroupsAttribute))
	}

	planTypeAttribute, ok := attributes["plan_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`plan_type is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	planTypeVal, ok := planTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`plan_type expected to be basetypes.StringValue, was: %T`, planTypeAttribute))
	}

	pricesAttribute, ok := attributes["prices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prices is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	pricesVal, ok := pricesAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prices expected to be basetypes.MapValue, was: %T`, pricesAttribute))
	}

	quotasAttribute, ok := attributes["quotas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`quotas is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	quotasVal, ok := quotasAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`quotas expected to be basetypes.MapValue, was: %T`, quotasAttribute))
	}

	resourcesCountAttribute, ok := attributes["resources_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resources_count is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	resourcesCountVal, ok := resourcesCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resources_count expected to be basetypes.Int64Value, was: %T`, resourcesCountAttribute))
	}

	switchPriceAttribute, ok := attributes["switch_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`switch_price is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	switchPriceVal, ok := switchPriceAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`switch_price expected to be basetypes.Float64Value, was: %T`, switchPriceAttribute))
	}

	unitAttribute, ok := attributes["unit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	unitVal, ok := unitAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit expected to be basetypes.StringValue, was: %T`, unitAttribute))
	}

	unitPriceAttribute, ok := attributes["unit_price"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_price is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	unitPriceVal, ok := unitPriceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_price expected to be basetypes.StringValue, was: %T`, unitPriceAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewPlansValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewPlansValueUnknown(), diags
	}

	return PlansValue{
		Archived:           archivedVal,
		ArticleCode:        articleCodeVal,
		BackendId:          backendIdVal,
		Description:        descriptionVal,
		FuturePrices:       futurePricesVal,
		InitPrice:          initPriceVal,
		IsActive:           isActiveVal,
		MaxAmount:          maxAmountVal,
		MinimalPrice:       minimalPriceVal,
		Name:               nameVal,
		OrganizationGroups: organizationGroupsVal,
		PlanType:           planTypeVal,
		Prices:             pricesVal,
		Quotas:             quotasVal,
		ResourcesCount:     resourcesCountVal,
		SwitchPrice:        switchPriceVal,
		Unit:               unitVal,
		UnitPrice:          unitPriceVal,
		Url:                urlVal,
		Uuid:               uuidVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PlansValue {
	object, diags := NewPlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPlansValueMust(PlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PlansType) ValueType(ctx context.Context) attr.Value {
	return PlansValue{}
}

var _ basetypes.ObjectValuable = PlansValue{}

type PlansValue struct {
	Archived           basetypes.BoolValue    `tfsdk:"archived"`
	ArticleCode        basetypes.StringValue  `tfsdk:"article_code"`
	BackendId          basetypes.StringValue  `tfsdk:"backend_id"`
	Description        basetypes.StringValue  `tfsdk:"description"`
	FuturePrices       basetypes.MapValue     `tfsdk:"future_prices"`
	InitPrice          basetypes.Float64Value `tfsdk:"init_price"`
	IsActive           basetypes.BoolValue    `tfsdk:"is_active"`
	MaxAmount          basetypes.Int64Value   `tfsdk:"max_amount"`
	MinimalPrice       basetypes.Float64Value `tfsdk:"minimal_price"`
	Name               basetypes.StringValue  `tfsdk:"name"`
	OrganizationGroups basetypes.ListValue    `tfsdk:"organization_groups"`
	PlanType           basetypes.StringValue  `tfsdk:"plan_type"`
	Prices             basetypes.MapValue     `tfsdk:"prices"`
	Quotas             basetypes.MapValue     `tfsdk:"quotas"`
	ResourcesCount     basetypes.Int64Value   `tfsdk:"resources_count"`
	SwitchPrice        basetypes.Float64Value `tfsdk:"switch_price"`
	Unit               basetypes.StringValue  `tfsdk:"unit"`
	UnitPrice          basetypes.StringValue  `tfsdk:"unit_price"`
	Url                basetypes.StringValue  `tfsdk:"url"`
	Uuid               basetypes.StringValue  `tfsdk:"uuid"`
	state              attr.ValueState
}

func (v PlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 20)

	var val tftypes.Value
	var err error

	attrTypes["archived"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["article_code"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["backend_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["future_prices"] = basetypes.MapType{
		ElemType: types.Float64Type,
	}.TerraformType(ctx)
	attrTypes["init_price"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["is_active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_amount"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimal_price"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["organization_groups"] = basetypes.ListType{
		ElemType: OrganizationGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["plan_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prices"] = basetypes.MapType{
		ElemType: types.Float64Type,
	}.TerraformType(ctx)
	attrTypes["quotas"] = basetypes.MapType{
		ElemType: types.Float64Type,
	}.TerraformType(ctx)
	attrTypes["resources_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["switch_price"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["unit"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unit_price"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 20)

		val, err = v.Archived.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["archived"] = val

		val, err = v.ArticleCode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["article_code"] = val

		val, err = v.BackendId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_id"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.FuturePrices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["future_prices"] = val

		val, err = v.InitPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["init_price"] = val

		val, err = v.IsActive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_active"] = val

		val, err = v.MaxAmount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_amount"] = val

		val, err = v.MinimalPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimal_price"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OrganizationGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["organization_groups"] = val

		val, err = v.PlanType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["plan_type"] = val

		val, err = v.Prices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prices"] = val

		val, err = v.Quotas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["quotas"] = val

		val, err = v.ResourcesCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resources_count"] = val

		val, err = v.SwitchPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["switch_price"] = val

		val, err = v.Unit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit"] = val

		val, err = v.UnitPrice.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit_price"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PlansValue) String() string {
	return "PlansValue"
}

func (v PlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	organizationGroups := types.ListValueMust(
		OrganizationGroupsType{
			basetypes.ObjectType{
				AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.OrganizationGroups.Elements(),
	)

	if v.OrganizationGroups.IsNull() {
		organizationGroups = types.ListNull(
			OrganizationGroupsType{
				basetypes.ObjectType{
					AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OrganizationGroups.IsUnknown() {
		organizationGroups = types.ListUnknown(
			OrganizationGroupsType{
				basetypes.ObjectType{
					AttrTypes: OrganizationGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var futurePricesVal basetypes.MapValue
	switch {
	case v.FuturePrices.IsUnknown():
		futurePricesVal = types.MapUnknown(types.Float64Type)
	case v.FuturePrices.IsNull():
		futurePricesVal = types.MapNull(types.Float64Type)
	default:
		var d diag.Diagnostics
		futurePricesVal, d = types.MapValue(types.Float64Type, v.FuturePrices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"archived":     basetypes.BoolType{},
			"article_code": basetypes.StringType{},
			"backend_id":   basetypes.StringType{},
			"description":  basetypes.StringType{},
			"future_prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"init_price":    basetypes.Float64Type{},
			"is_active":     basetypes.BoolType{},
			"max_amount":    basetypes.Int64Type{},
			"minimal_price": basetypes.Float64Type{},
			"name":          basetypes.StringType{},
			"organization_groups": basetypes.ListType{
				ElemType: OrganizationGroupsValue{}.Type(ctx),
			},
			"plan_type": basetypes.StringType{},
			"prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"quotas": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"resources_count": basetypes.Int64Type{},
			"switch_price":    basetypes.Float64Type{},
			"unit":            basetypes.StringType{},
			"unit_price":      basetypes.StringType{},
			"url":             basetypes.StringType{},
			"uuid":            basetypes.StringType{},
		}), diags
	}

	var pricesVal basetypes.MapValue
	switch {
	case v.Prices.IsUnknown():
		pricesVal = types.MapUnknown(types.Float64Type)
	case v.Prices.IsNull():
		pricesVal = types.MapNull(types.Float64Type)
	default:
		var d diag.Diagnostics
		pricesVal, d = types.MapValue(types.Float64Type, v.Prices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"archived":     basetypes.BoolType{},
			"article_code": basetypes.StringType{},
			"backend_id":   basetypes.StringType{},
			"description":  basetypes.StringType{},
			"future_prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"init_price":    basetypes.Float64Type{},
			"is_active":     basetypes.BoolType{},
			"max_amount":    basetypes.Int64Type{},
			"minimal_price": basetypes.Float64Type{},
			"name":          basetypes.StringType{},
			"organization_groups": basetypes.ListType{
				ElemType: OrganizationGroupsValue{}.Type(ctx),
			},
			"plan_type": basetypes.StringType{},
			"prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"quotas": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"resources_count": basetypes.Int64Type{},
			"switch_price":    basetypes.Float64Type{},
			"unit":            basetypes.StringType{},
			"unit_price":      basetypes.StringType{},
			"url":             basetypes.StringType{},
			"uuid":            basetypes.StringType{},
		}), diags
	}

	var quotasVal basetypes.MapValue
	switch {
	case v.Quotas.IsUnknown():
		quotasVal = types.MapUnknown(types.Float64Type)
	case v.Quotas.IsNull():
		quotasVal = types.MapNull(types.Float64Type)
	default:
		var d diag.Diagnostics
		quotasVal, d = types.MapValue(types.Float64Type, v.Quotas.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"archived":     basetypes.BoolType{},
			"article_code": basetypes.StringType{},
			"backend_id":   basetypes.StringType{},
			"description":  basetypes.StringType{},
			"future_prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"init_price":    basetypes.Float64Type{},
			"is_active":     basetypes.BoolType{},
			"max_amount":    basetypes.Int64Type{},
			"minimal_price": basetypes.Float64Type{},
			"name":          basetypes.StringType{},
			"organization_groups": basetypes.ListType{
				ElemType: OrganizationGroupsValue{}.Type(ctx),
			},
			"plan_type": basetypes.StringType{},
			"prices": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"quotas": basetypes.MapType{
				ElemType: types.Float64Type,
			},
			"resources_count": basetypes.Int64Type{},
			"switch_price":    basetypes.Float64Type{},
			"unit":            basetypes.StringType{},
			"unit_price":      basetypes.StringType{},
			"url":             basetypes.StringType{},
			"uuid":            basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"archived":     basetypes.BoolType{},
		"article_code": basetypes.StringType{},
		"backend_id":   basetypes.StringType{},
		"description":  basetypes.StringType{},
		"future_prices": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"init_price":    basetypes.Float64Type{},
		"is_active":     basetypes.BoolType{},
		"max_amount":    basetypes.Int64Type{},
		"minimal_price": basetypes.Float64Type{},
		"name":          basetypes.StringType{},
		"organization_groups": basetypes.ListType{
			ElemType: OrganizationGroupsValue{}.Type(ctx),
		},
		"plan_type": basetypes.StringType{},
		"prices": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"quotas": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"resources_count": basetypes.Int64Type{},
		"switch_price":    basetypes.Float64Type{},
		"unit":            basetypes.StringType{},
		"unit_price":      basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"archived":            v.Archived,
			"article_code":        v.ArticleCode,
			"backend_id":          v.BackendId,
			"description":         v.Description,
			"future_prices":       futurePricesVal,
			"init_price":          v.InitPrice,
			"is_active":           v.IsActive,
			"max_amount":          v.MaxAmount,
			"minimal_price":       v.MinimalPrice,
			"name":                v.Name,
			"organization_groups": organizationGroups,
			"plan_type":           v.PlanType,
			"prices":              pricesVal,
			"quotas":              quotasVal,
			"resources_count":     v.ResourcesCount,
			"switch_price":        v.SwitchPrice,
			"unit":                v.Unit,
			"unit_price":          v.UnitPrice,
			"url":                 v.Url,
			"uuid":                v.Uuid,
		})

	return objVal, diags
}

func (v PlansValue) Equal(o attr.Value) bool {
	other, ok := o.(PlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Archived.Equal(other.Archived) {
		return false
	}

	if !v.ArticleCode.Equal(other.ArticleCode) {
		return false
	}

	if !v.BackendId.Equal(other.BackendId) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.FuturePrices.Equal(other.FuturePrices) {
		return false
	}

	if !v.InitPrice.Equal(other.InitPrice) {
		return false
	}

	if !v.IsActive.Equal(other.IsActive) {
		return false
	}

	if !v.MaxAmount.Equal(other.MaxAmount) {
		return false
	}

	if !v.MinimalPrice.Equal(other.MinimalPrice) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OrganizationGroups.Equal(other.OrganizationGroups) {
		return false
	}

	if !v.PlanType.Equal(other.PlanType) {
		return false
	}

	if !v.Prices.Equal(other.Prices) {
		return false
	}

	if !v.Quotas.Equal(other.Quotas) {
		return false
	}

	if !v.ResourcesCount.Equal(other.ResourcesCount) {
		return false
	}

	if !v.SwitchPrice.Equal(other.SwitchPrice) {
		return false
	}

	if !v.Unit.Equal(other.Unit) {
		return false
	}

	if !v.UnitPrice.Equal(other.UnitPrice) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v PlansValue) Type(ctx context.Context) attr.Type {
	return PlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"archived":     basetypes.BoolType{},
		"article_code": basetypes.StringType{},
		"backend_id":   basetypes.StringType{},
		"description":  basetypes.StringType{},
		"future_prices": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"init_price":    basetypes.Float64Type{},
		"is_active":     basetypes.BoolType{},
		"max_amount":    basetypes.Int64Type{},
		"minimal_price": basetypes.Float64Type{},
		"name":          basetypes.StringType{},
		"organization_groups": basetypes.ListType{
			ElemType: OrganizationGroupsValue{}.Type(ctx),
		},
		"plan_type": basetypes.StringType{},
		"prices": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"quotas": basetypes.MapType{
			ElemType: types.Float64Type,
		},
		"resources_count": basetypes.Int64Type{},
		"switch_price":    basetypes.Float64Type{},
		"unit":            basetypes.StringType{},
		"unit_price":      basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OrganizationGroupsType{}

type OrganizationGroupsType struct {
	basetypes.ObjectType
}

func (t OrganizationGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(OrganizationGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrganizationGroupsType) String() string {
	return "OrganizationGroupsType"
}

func (t OrganizationGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	customersCountAttribute, ok := attributes["customers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customers_count is missing from object`)

		return nil, diags
	}

	customersCountVal, ok := customersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customers_count expected to be basetypes.Int64Value, was: %T`, customersCountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	parentAttribute, ok := attributes["parent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent is missing from object`)

		return nil, diags
	}

	parentVal, ok := parentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent expected to be basetypes.StringValue, was: %T`, parentAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return nil, diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return nil, diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrganizationGroupsValue{
		CustomersCount: customersCountVal,
		Name:           nameVal,
		Parent:         parentVal,
		ParentName:     parentNameVal,
		ParentUuid:     parentUuidVal,
		Url:            urlVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrganizationGroupsValueNull() OrganizationGroupsValue {
	return OrganizationGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewOrganizationGroupsValueUnknown() OrganizationGroupsValue {
	return OrganizationGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrganizationGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrganizationGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrganizationGroupsValue Attribute Value",
				"While creating a OrganizationGroupsValue value, a missing attribute value was detected. "+
					"A OrganizationGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrganizationGroupsValue Attribute Type",
				"While creating a OrganizationGroupsValue value, an invalid attribute value was detected. "+
					"A OrganizationGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrganizationGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrganizationGroupsValue Attribute Value",
				"While creating a OrganizationGroupsValue value, an extra attribute value was detected. "+
					"A OrganizationGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrganizationGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrganizationGroupsValueUnknown(), diags
	}

	customersCountAttribute, ok := attributes["customers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`customers_count is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	customersCountVal, ok := customersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`customers_count expected to be basetypes.Int64Value, was: %T`, customersCountAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	parentAttribute, ok := attributes["parent"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentVal, ok := parentAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent expected to be basetypes.StringValue, was: %T`, parentAttribute))
	}

	parentNameAttribute, ok := attributes["parent_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_name is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentNameVal, ok := parentNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_name expected to be basetypes.StringValue, was: %T`, parentNameAttribute))
	}

	parentUuidAttribute, ok := attributes["parent_uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`parent_uuid is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	parentUuidVal, ok := parentUuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`parent_uuid expected to be basetypes.StringValue, was: %T`, parentUuidAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewOrganizationGroupsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewOrganizationGroupsValueUnknown(), diags
	}

	return OrganizationGroupsValue{
		CustomersCount: customersCountVal,
		Name:           nameVal,
		Parent:         parentVal,
		ParentName:     parentNameVal,
		ParentUuid:     parentUuidVal,
		Url:            urlVal,
		Uuid:           uuidVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOrganizationGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrganizationGroupsValue {
	object, diags := NewOrganizationGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrganizationGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrganizationGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrganizationGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrganizationGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrganizationGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrganizationGroupsValueMust(OrganizationGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrganizationGroupsType) ValueType(ctx context.Context) attr.Value {
	return OrganizationGroupsValue{}
}

var _ basetypes.ObjectValuable = OrganizationGroupsValue{}

type OrganizationGroupsValue struct {
	CustomersCount basetypes.Int64Value  `tfsdk:"customers_count"`
	Name           basetypes.StringValue `tfsdk:"name"`
	Parent         basetypes.StringValue `tfsdk:"parent"`
	ParentName     basetypes.StringValue `tfsdk:"parent_name"`
	ParentUuid     basetypes.StringValue `tfsdk:"parent_uuid"`
	Url            basetypes.StringValue `tfsdk:"url"`
	Uuid           basetypes.StringValue `tfsdk:"uuid"`
	state          attr.ValueState
}

func (v OrganizationGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["customers_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["parent_uuid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.CustomersCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["customers_count"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Parent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent"] = val

		val, err = v.ParentName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_name"] = val

		val, err = v.ParentUuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["parent_uuid"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrganizationGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrganizationGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrganizationGroupsValue) String() string {
	return "OrganizationGroupsValue"
}

func (v OrganizationGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"customers_count": basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"parent":          basetypes.StringType{},
		"parent_name":     basetypes.StringType{},
		"parent_uuid":     basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"customers_count": v.CustomersCount,
			"name":            v.Name,
			"parent":          v.Parent,
			"parent_name":     v.ParentName,
			"parent_uuid":     v.ParentUuid,
			"url":             v.Url,
			"uuid":            v.Uuid,
		})

	return objVal, diags
}

func (v OrganizationGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(OrganizationGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CustomersCount.Equal(other.CustomersCount) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Parent.Equal(other.Parent) {
		return false
	}

	if !v.ParentName.Equal(other.ParentName) {
		return false
	}

	if !v.ParentUuid.Equal(other.ParentUuid) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v OrganizationGroupsValue) Type(ctx context.Context) attr.Type {
	return OrganizationGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrganizationGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"customers_count": basetypes.Int64Type{},
		"name":            basetypes.StringType{},
		"parent":          basetypes.StringType{},
		"parent_name":     basetypes.StringType{},
		"parent_uuid":     basetypes.StringType{},
		"url":             basetypes.StringType{},
		"uuid":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PluginOptionsType{}

type PluginOptionsType struct {
	basetypes.ObjectType
}

func (t PluginOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(PluginOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PluginOptionsType) String() string {
	return "PluginOptionsType"
}

func (t PluginOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autoApproveInServiceProviderProjectsAttribute, ok := attributes["auto_approve_in_service_provider_projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_in_service_provider_projects is missing from object`)

		return nil, diags
	}

	autoApproveInServiceProviderProjectsVal, ok := autoApproveInServiceProviderProjectsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_in_service_provider_projects expected to be basetypes.BoolValue, was: %T`, autoApproveInServiceProviderProjectsAttribute))
	}

	autoApproveRemoteOrdersAttribute, ok := attributes["auto_approve_remote_orders"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_remote_orders is missing from object`)

		return nil, diags
	}

	autoApproveRemoteOrdersVal, ok := autoApproveRemoteOrdersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_remote_orders expected to be basetypes.BoolValue, was: %T`, autoApproveRemoteOrdersAttribute))
	}

	backendIdDisplayLabelAttribute, ok := attributes["backend_id_display_label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id_display_label is missing from object`)

		return nil, diags
	}

	backendIdDisplayLabelVal, ok := backendIdDisplayLabelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id_display_label expected to be basetypes.StringValue, was: %T`, backendIdDisplayLabelAttribute))
	}

	concealBillingDataAttribute, ok := attributes["conceal_billing_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conceal_billing_data is missing from object`)

		return nil, diags
	}

	concealBillingDataVal, ok := concealBillingDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conceal_billing_data expected to be basetypes.BoolValue, was: %T`, concealBillingDataAttribute))
	}

	defaultInternalNetworkMtuAttribute, ok := attributes["default_internal_network_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_internal_network_mtu is missing from object`)

		return nil, diags
	}

	defaultInternalNetworkMtuVal, ok := defaultInternalNetworkMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_internal_network_mtu expected to be basetypes.Int64Value, was: %T`, defaultInternalNetworkMtuAttribute))
	}

	defaultResourceTerminationOffsetInDaysAttribute, ok := attributes["default_resource_termination_offset_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_resource_termination_offset_in_days is missing from object`)

		return nil, diags
	}

	defaultResourceTerminationOffsetInDaysVal, ok := defaultResourceTerminationOffsetInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_resource_termination_offset_in_days expected to be basetypes.Int64Value, was: %T`, defaultResourceTerminationOffsetInDaysAttribute))
	}

	deploymentModeAttribute, ok := attributes["deployment_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_mode is missing from object`)

		return nil, diags
	}

	deploymentModeVal, ok := deploymentModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_mode expected to be basetypes.StringValue, was: %T`, deploymentModeAttribute))
	}

	enableIssuesForMembershipChangesAttribute, ok := attributes["enable_issues_for_membership_changes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_issues_for_membership_changes is missing from object`)

		return nil, diags
	}

	enableIssuesForMembershipChangesVal, ok := enableIssuesForMembershipChangesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_issues_for_membership_changes expected to be basetypes.BoolValue, was: %T`, enableIssuesForMembershipChangesAttribute))
	}

	flavorsRegexAttribute, ok := attributes["flavors_regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavors_regex is missing from object`)

		return nil, diags
	}

	flavorsRegexVal, ok := flavorsRegexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavors_regex expected to be basetypes.StringValue, was: %T`, flavorsRegexAttribute))
	}

	heappeClusterIdAttribute, ok := attributes["heappe_cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_cluster_id is missing from object`)

		return nil, diags
	}

	heappeClusterIdVal, ok := heappeClusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_cluster_id expected to be basetypes.StringValue, was: %T`, heappeClusterIdAttribute))
	}

	heappeLocalBasePathAttribute, ok := attributes["heappe_local_base_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_local_base_path is missing from object`)

		return nil, diags
	}

	heappeLocalBasePathVal, ok := heappeLocalBasePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_local_base_path expected to be basetypes.StringValue, was: %T`, heappeLocalBasePathAttribute))
	}

	heappeUrlAttribute, ok := attributes["heappe_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_url is missing from object`)

		return nil, diags
	}

	heappeUrlVal, ok := heappeUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_url expected to be basetypes.StringValue, was: %T`, heappeUrlAttribute))
	}

	heappeUsernameAttribute, ok := attributes["heappe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_username is missing from object`)

		return nil, diags
	}

	heappeUsernameVal, ok := heappeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_username expected to be basetypes.StringValue, was: %T`, heappeUsernameAttribute))
	}

	highlightBackendIdDisplayAttribute, ok := attributes["highlight_backend_id_display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`highlight_backend_id_display is missing from object`)

		return nil, diags
	}

	highlightBackendIdDisplayVal, ok := highlightBackendIdDisplayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`highlight_backend_id_display expected to be basetypes.BoolValue, was: %T`, highlightBackendIdDisplayAttribute))
	}

	homedirPrefixAttribute, ok := attributes["homedir_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`homedir_prefix is missing from object`)

		return nil, diags
	}

	homedirPrefixVal, ok := homedirPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`homedir_prefix expected to be basetypes.StringValue, was: %T`, homedirPrefixAttribute))
	}

	initialPrimarygroupNumberAttribute, ok := attributes["initial_primarygroup_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_primarygroup_number is missing from object`)

		return nil, diags
	}

	initialPrimarygroupNumberVal, ok := initialPrimarygroupNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_primarygroup_number expected to be basetypes.Int64Value, was: %T`, initialPrimarygroupNumberAttribute))
	}

	initialUidnumberAttribute, ok := attributes["initial_uidnumber"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_uidnumber is missing from object`)

		return nil, diags
	}

	initialUidnumberVal, ok := initialUidnumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_uidnumber expected to be basetypes.Int64Value, was: %T`, initialUidnumberAttribute))
	}

	initialUsergroupNumberAttribute, ok := attributes["initial_usergroup_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_usergroup_number is missing from object`)

		return nil, diags
	}

	initialUsergroupNumberVal, ok := initialUsergroupNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_usergroup_number expected to be basetypes.Int64Value, was: %T`, initialUsergroupNumberAttribute))
	}

	isResourceTerminationDateRequiredAttribute, ok := attributes["is_resource_termination_date_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_resource_termination_date_required is missing from object`)

		return nil, diags
	}

	isResourceTerminationDateRequiredVal, ok := isResourceTerminationDateRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_resource_termination_date_required expected to be basetypes.BoolValue, was: %T`, isResourceTerminationDateRequiredAttribute))
	}

	latestDateForResourceTerminationAttribute, ok := attributes["latest_date_for_resource_termination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_date_for_resource_termination is missing from object`)

		return nil, diags
	}

	latestDateForResourceTerminationVal, ok := latestDateForResourceTerminationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_date_for_resource_termination expected to be basetypes.StringValue, was: %T`, latestDateForResourceTerminationAttribute))
	}

	managedRancherLoadBalancerDataVolumeSizeGbAttribute, ok := attributes["managed_rancher_load_balancer_data_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_data_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerDataVolumeSizeGbVal, ok := managedRancherLoadBalancerDataVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_data_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherLoadBalancerDataVolumeSizeGbAttribute))
	}

	managedRancherLoadBalancerDataVolumeTypeNameAttribute, ok := attributes["managed_rancher_load_balancer_data_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_data_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerDataVolumeTypeNameVal, ok := managedRancherLoadBalancerDataVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_data_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerDataVolumeTypeNameAttribute))
	}

	managedRancherLoadBalancerFlavorNameAttribute, ok := attributes["managed_rancher_load_balancer_flavor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_flavor_name is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerFlavorNameVal, ok := managedRancherLoadBalancerFlavorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_flavor_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerFlavorNameAttribute))
	}

	managedRancherLoadBalancerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_load_balancer_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_system_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerSystemVolumeSizeGbVal, ok := managedRancherLoadBalancerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherLoadBalancerSystemVolumeSizeGbAttribute))
	}

	managedRancherLoadBalancerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_load_balancer_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_system_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherLoadBalancerSystemVolumeTypeNameVal, ok := managedRancherLoadBalancerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerSystemVolumeTypeNameAttribute))
	}

	managedRancherServerDataVolumeSizeGbAttribute, ok := attributes["managed_rancher_server_data_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_data_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherServerDataVolumeSizeGbVal, ok := managedRancherServerDataVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_data_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherServerDataVolumeSizeGbAttribute))
	}

	managedRancherServerDataVolumeTypeNameAttribute, ok := attributes["managed_rancher_server_data_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_data_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherServerDataVolumeTypeNameVal, ok := managedRancherServerDataVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_data_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherServerDataVolumeTypeNameAttribute))
	}

	managedRancherServerFlavorNameAttribute, ok := attributes["managed_rancher_server_flavor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_flavor_name is missing from object`)

		return nil, diags
	}

	managedRancherServerFlavorNameVal, ok := managedRancherServerFlavorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_flavor_name expected to be basetypes.StringValue, was: %T`, managedRancherServerFlavorNameAttribute))
	}

	managedRancherServerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_server_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_system_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherServerSystemVolumeSizeGbVal, ok := managedRancherServerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherServerSystemVolumeSizeGbAttribute))
	}

	managedRancherServerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_server_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_system_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherServerSystemVolumeTypeNameVal, ok := managedRancherServerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherServerSystemVolumeTypeNameAttribute))
	}

	managedRancherTenantMaxCpuAttribute, ok := attributes["managed_rancher_tenant_max_cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_tenant_max_cpu is missing from object`)

		return nil, diags
	}

	managedRancherTenantMaxCpuVal, ok := managedRancherTenantMaxCpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_tenant_max_cpu expected to be basetypes.Int64Value, was: %T`, managedRancherTenantMaxCpuAttribute))
	}

	managedRancherTenantMaxDiskAttribute, ok := attributes["managed_rancher_tenant_max_disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_tenant_max_disk is missing from object`)

		return nil, diags
	}

	managedRancherTenantMaxDiskVal, ok := managedRancherTenantMaxDiskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_tenant_max_disk expected to be basetypes.Int64Value, was: %T`, managedRancherTenantMaxDiskAttribute))
	}

	managedRancherTenantMaxRamAttribute, ok := attributes["managed_rancher_tenant_max_ram"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_tenant_max_ram is missing from object`)

		return nil, diags
	}

	managedRancherTenantMaxRamVal, ok := managedRancherTenantMaxRamAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_tenant_max_ram expected to be basetypes.Int64Value, was: %T`, managedRancherTenantMaxRamAttribute))
	}

	managedRancherWorkerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_worker_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_worker_system_volume_size_gb is missing from object`)

		return nil, diags
	}

	managedRancherWorkerSystemVolumeSizeGbVal, ok := managedRancherWorkerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_worker_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherWorkerSystemVolumeSizeGbAttribute))
	}

	managedRancherWorkerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_worker_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_worker_system_volume_type_name is missing from object`)

		return nil, diags
	}

	managedRancherWorkerSystemVolumeTypeNameVal, ok := managedRancherWorkerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_worker_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherWorkerSystemVolumeTypeNameAttribute))
	}

	maxInstancesAttribute, ok := attributes["max_instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_instances is missing from object`)

		return nil, diags
	}

	maxInstancesVal, ok := maxInstancesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_instances expected to be basetypes.Int64Value, was: %T`, maxInstancesAttribute))
	}

	maxResourceTerminationOffsetInDaysAttribute, ok := attributes["max_resource_termination_offset_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_resource_termination_offset_in_days is missing from object`)

		return nil, diags
	}

	maxResourceTerminationOffsetInDaysVal, ok := maxResourceTerminationOffsetInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_resource_termination_offset_in_days expected to be basetypes.Int64Value, was: %T`, maxResourceTerminationOffsetInDaysAttribute))
	}

	maxVolumesAttribute, ok := attributes["max_volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_volumes is missing from object`)

		return nil, diags
	}

	maxVolumesVal, ok := maxVolumesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_volumes expected to be basetypes.Int64Value, was: %T`, maxVolumesAttribute))
	}

	maximalResourceCountPerProjectAttribute, ok := attributes["maximal_resource_count_per_project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maximal_resource_count_per_project is missing from object`)

		return nil, diags
	}

	maximalResourceCountPerProjectVal, ok := maximalResourceCountPerProjectAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maximal_resource_count_per_project expected to be basetypes.Int64Value, was: %T`, maximalResourceCountPerProjectAttribute))
	}

	minimalTeamCountForProvisioningAttribute, ok := attributes["minimal_team_count_for_provisioning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimal_team_count_for_provisioning is missing from object`)

		return nil, diags
	}

	minimalTeamCountForProvisioningVal, ok := minimalTeamCountForProvisioningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimal_team_count_for_provisioning expected to be basetypes.Int64Value, was: %T`, minimalTeamCountForProvisioningAttribute))
	}

	openstackOfferingUuidListAttribute, ok := attributes["openstack_offering_uuid_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`openstack_offering_uuid_list is missing from object`)

		return nil, diags
	}

	openstackOfferingUuidListVal, ok := openstackOfferingUuidListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`openstack_offering_uuid_list expected to be basetypes.ListValue, was: %T`, openstackOfferingUuidListAttribute))
	}

	orderSupportsCommentsAndMetadataAttribute, ok := attributes["order_supports_comments_and_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order_supports_comments_and_metadata is missing from object`)

		return nil, diags
	}

	orderSupportsCommentsAndMetadataVal, ok := orderSupportsCommentsAndMetadataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order_supports_comments_and_metadata expected to be basetypes.BoolValue, was: %T`, orderSupportsCommentsAndMetadataAttribute))
	}

	projectPermanentDirectoryAttribute, ok := attributes["project_permanent_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_permanent_directory is missing from object`)

		return nil, diags
	}

	projectPermanentDirectoryVal, ok := projectPermanentDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_permanent_directory expected to be basetypes.StringValue, was: %T`, projectPermanentDirectoryAttribute))
	}

	requiredTeamRoleForProvisioningAttribute, ok := attributes["required_team_role_for_provisioning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_team_role_for_provisioning is missing from object`)

		return nil, diags
	}

	requiredTeamRoleForProvisioningVal, ok := requiredTeamRoleForProvisioningAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_team_role_for_provisioning expected to be basetypes.StringValue, was: %T`, requiredTeamRoleForProvisioningAttribute))
	}

	scratchProjectDirectoryAttribute, ok := attributes["scratch_project_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scratch_project_directory is missing from object`)

		return nil, diags
	}

	scratchProjectDirectoryVal, ok := scratchProjectDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scratch_project_directory expected to be basetypes.StringValue, was: %T`, scratchProjectDirectoryAttribute))
	}

	serviceProviderCanCreateOfferingUserAttribute, ok := attributes["service_provider_can_create_offering_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_provider_can_create_offering_user is missing from object`)

		return nil, diags
	}

	serviceProviderCanCreateOfferingUserVal, ok := serviceProviderCanCreateOfferingUserAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_provider_can_create_offering_user expected to be basetypes.BoolValue, was: %T`, serviceProviderCanCreateOfferingUserAttribute))
	}

	snapshotSizeLimitGbAttribute, ok := attributes["snapshot_size_limit_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot_size_limit_gb is missing from object`)

		return nil, diags
	}

	snapshotSizeLimitGbVal, ok := snapshotSizeLimitGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot_size_limit_gb expected to be basetypes.Int64Value, was: %T`, snapshotSizeLimitGbAttribute))
	}

	storageModeAttribute, ok := attributes["storage_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_mode is missing from object`)

		return nil, diags
	}

	storageModeVal, ok := storageModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_mode expected to be basetypes.StringValue, was: %T`, storageModeAttribute))
	}

	supportsDownscalingAttribute, ok := attributes["supports_downscaling"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supports_downscaling is missing from object`)

		return nil, diags
	}

	supportsDownscalingVal, ok := supportsDownscalingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supports_downscaling expected to be basetypes.BoolValue, was: %T`, supportsDownscalingAttribute))
	}

	supportsPausingAttribute, ok := attributes["supports_pausing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supports_pausing is missing from object`)

		return nil, diags
	}

	supportsPausingVal, ok := supportsPausingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supports_pausing expected to be basetypes.BoolValue, was: %T`, supportsPausingAttribute))
	}

	usernameAnonymizedPrefixAttribute, ok := attributes["username_anonymized_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_anonymized_prefix is missing from object`)

		return nil, diags
	}

	usernameAnonymizedPrefixVal, ok := usernameAnonymizedPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_anonymized_prefix expected to be basetypes.StringValue, was: %T`, usernameAnonymizedPrefixAttribute))
	}

	usernameGenerationPolicyAttribute, ok := attributes["username_generation_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_generation_policy is missing from object`)

		return nil, diags
	}

	usernameGenerationPolicyVal, ok := usernameGenerationPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_generation_policy expected to be basetypes.StringValue, was: %T`, usernameGenerationPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PluginOptionsValue{
		AutoApproveInServiceProviderProjects:           autoApproveInServiceProviderProjectsVal,
		AutoApproveRemoteOrders:                        autoApproveRemoteOrdersVal,
		BackendIdDisplayLabel:                          backendIdDisplayLabelVal,
		ConcealBillingData:                             concealBillingDataVal,
		DefaultInternalNetworkMtu:                      defaultInternalNetworkMtuVal,
		DefaultResourceTerminationOffsetInDays:         defaultResourceTerminationOffsetInDaysVal,
		DeploymentMode:                                 deploymentModeVal,
		EnableIssuesForMembershipChanges:               enableIssuesForMembershipChangesVal,
		FlavorsRegex:                                   flavorsRegexVal,
		HeappeClusterId:                                heappeClusterIdVal,
		HeappeLocalBasePath:                            heappeLocalBasePathVal,
		HeappeUrl:                                      heappeUrlVal,
		HeappeUsername:                                 heappeUsernameVal,
		HighlightBackendIdDisplay:                      highlightBackendIdDisplayVal,
		HomedirPrefix:                                  homedirPrefixVal,
		InitialPrimarygroupNumber:                      initialPrimarygroupNumberVal,
		InitialUidnumber:                               initialUidnumberVal,
		InitialUsergroupNumber:                         initialUsergroupNumberVal,
		IsResourceTerminationDateRequired:              isResourceTerminationDateRequiredVal,
		LatestDateForResourceTermination:               latestDateForResourceTerminationVal,
		ManagedRancherLoadBalancerDataVolumeSizeGb:     managedRancherLoadBalancerDataVolumeSizeGbVal,
		ManagedRancherLoadBalancerDataVolumeTypeName:   managedRancherLoadBalancerDataVolumeTypeNameVal,
		ManagedRancherLoadBalancerFlavorName:           managedRancherLoadBalancerFlavorNameVal,
		ManagedRancherLoadBalancerSystemVolumeSizeGb:   managedRancherLoadBalancerSystemVolumeSizeGbVal,
		ManagedRancherLoadBalancerSystemVolumeTypeName: managedRancherLoadBalancerSystemVolumeTypeNameVal,
		ManagedRancherServerDataVolumeSizeGb:           managedRancherServerDataVolumeSizeGbVal,
		ManagedRancherServerDataVolumeTypeName:         managedRancherServerDataVolumeTypeNameVal,
		ManagedRancherServerFlavorName:                 managedRancherServerFlavorNameVal,
		ManagedRancherServerSystemVolumeSizeGb:         managedRancherServerSystemVolumeSizeGbVal,
		ManagedRancherServerSystemVolumeTypeName:       managedRancherServerSystemVolumeTypeNameVal,
		ManagedRancherTenantMaxCpu:                     managedRancherTenantMaxCpuVal,
		ManagedRancherTenantMaxDisk:                    managedRancherTenantMaxDiskVal,
		ManagedRancherTenantMaxRam:                     managedRancherTenantMaxRamVal,
		ManagedRancherWorkerSystemVolumeSizeGb:         managedRancherWorkerSystemVolumeSizeGbVal,
		ManagedRancherWorkerSystemVolumeTypeName:       managedRancherWorkerSystemVolumeTypeNameVal,
		MaxInstances:                                   maxInstancesVal,
		MaxResourceTerminationOffsetInDays:             maxResourceTerminationOffsetInDaysVal,
		MaxVolumes:                                     maxVolumesVal,
		MaximalResourceCountPerProject:                 maximalResourceCountPerProjectVal,
		MinimalTeamCountForProvisioning:                minimalTeamCountForProvisioningVal,
		OpenstackOfferingUuidList:                      openstackOfferingUuidListVal,
		OrderSupportsCommentsAndMetadata:               orderSupportsCommentsAndMetadataVal,
		ProjectPermanentDirectory:                      projectPermanentDirectoryVal,
		RequiredTeamRoleForProvisioning:                requiredTeamRoleForProvisioningVal,
		ScratchProjectDirectory:                        scratchProjectDirectoryVal,
		ServiceProviderCanCreateOfferingUser:           serviceProviderCanCreateOfferingUserVal,
		SnapshotSizeLimitGb:                            snapshotSizeLimitGbVal,
		StorageMode:                                    storageModeVal,
		SupportsDownscaling:                            supportsDownscalingVal,
		SupportsPausing:                                supportsPausingVal,
		UsernameAnonymizedPrefix:                       usernameAnonymizedPrefixVal,
		UsernameGenerationPolicy:                       usernameGenerationPolicyVal,
		state:                                          attr.ValueStateKnown,
	}, diags
}

func NewPluginOptionsValueNull() PluginOptionsValue {
	return PluginOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewPluginOptionsValueUnknown() PluginOptionsValue {
	return PluginOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPluginOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PluginOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PluginOptionsValue Attribute Value",
				"While creating a PluginOptionsValue value, a missing attribute value was detected. "+
					"A PluginOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PluginOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PluginOptionsValue Attribute Type",
				"While creating a PluginOptionsValue value, an invalid attribute value was detected. "+
					"A PluginOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PluginOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PluginOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PluginOptionsValue Attribute Value",
				"While creating a PluginOptionsValue value, an extra attribute value was detected. "+
					"A PluginOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PluginOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPluginOptionsValueUnknown(), diags
	}

	autoApproveInServiceProviderProjectsAttribute, ok := attributes["auto_approve_in_service_provider_projects"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_in_service_provider_projects is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	autoApproveInServiceProviderProjectsVal, ok := autoApproveInServiceProviderProjectsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_in_service_provider_projects expected to be basetypes.BoolValue, was: %T`, autoApproveInServiceProviderProjectsAttribute))
	}

	autoApproveRemoteOrdersAttribute, ok := attributes["auto_approve_remote_orders"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`auto_approve_remote_orders is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	autoApproveRemoteOrdersVal, ok := autoApproveRemoteOrdersAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`auto_approve_remote_orders expected to be basetypes.BoolValue, was: %T`, autoApproveRemoteOrdersAttribute))
	}

	backendIdDisplayLabelAttribute, ok := attributes["backend_id_display_label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`backend_id_display_label is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	backendIdDisplayLabelVal, ok := backendIdDisplayLabelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`backend_id_display_label expected to be basetypes.StringValue, was: %T`, backendIdDisplayLabelAttribute))
	}

	concealBillingDataAttribute, ok := attributes["conceal_billing_data"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`conceal_billing_data is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	concealBillingDataVal, ok := concealBillingDataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`conceal_billing_data expected to be basetypes.BoolValue, was: %T`, concealBillingDataAttribute))
	}

	defaultInternalNetworkMtuAttribute, ok := attributes["default_internal_network_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_internal_network_mtu is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	defaultInternalNetworkMtuVal, ok := defaultInternalNetworkMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_internal_network_mtu expected to be basetypes.Int64Value, was: %T`, defaultInternalNetworkMtuAttribute))
	}

	defaultResourceTerminationOffsetInDaysAttribute, ok := attributes["default_resource_termination_offset_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_resource_termination_offset_in_days is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	defaultResourceTerminationOffsetInDaysVal, ok := defaultResourceTerminationOffsetInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_resource_termination_offset_in_days expected to be basetypes.Int64Value, was: %T`, defaultResourceTerminationOffsetInDaysAttribute))
	}

	deploymentModeAttribute, ok := attributes["deployment_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deployment_mode is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	deploymentModeVal, ok := deploymentModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deployment_mode expected to be basetypes.StringValue, was: %T`, deploymentModeAttribute))
	}

	enableIssuesForMembershipChangesAttribute, ok := attributes["enable_issues_for_membership_changes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_issues_for_membership_changes is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	enableIssuesForMembershipChangesVal, ok := enableIssuesForMembershipChangesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_issues_for_membership_changes expected to be basetypes.BoolValue, was: %T`, enableIssuesForMembershipChangesAttribute))
	}

	flavorsRegexAttribute, ok := attributes["flavors_regex"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`flavors_regex is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	flavorsRegexVal, ok := flavorsRegexAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`flavors_regex expected to be basetypes.StringValue, was: %T`, flavorsRegexAttribute))
	}

	heappeClusterIdAttribute, ok := attributes["heappe_cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_cluster_id is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	heappeClusterIdVal, ok := heappeClusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_cluster_id expected to be basetypes.StringValue, was: %T`, heappeClusterIdAttribute))
	}

	heappeLocalBasePathAttribute, ok := attributes["heappe_local_base_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_local_base_path is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	heappeLocalBasePathVal, ok := heappeLocalBasePathAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_local_base_path expected to be basetypes.StringValue, was: %T`, heappeLocalBasePathAttribute))
	}

	heappeUrlAttribute, ok := attributes["heappe_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_url is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	heappeUrlVal, ok := heappeUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_url expected to be basetypes.StringValue, was: %T`, heappeUrlAttribute))
	}

	heappeUsernameAttribute, ok := attributes["heappe_username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`heappe_username is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	heappeUsernameVal, ok := heappeUsernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`heappe_username expected to be basetypes.StringValue, was: %T`, heappeUsernameAttribute))
	}

	highlightBackendIdDisplayAttribute, ok := attributes["highlight_backend_id_display"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`highlight_backend_id_display is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	highlightBackendIdDisplayVal, ok := highlightBackendIdDisplayAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`highlight_backend_id_display expected to be basetypes.BoolValue, was: %T`, highlightBackendIdDisplayAttribute))
	}

	homedirPrefixAttribute, ok := attributes["homedir_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`homedir_prefix is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	homedirPrefixVal, ok := homedirPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`homedir_prefix expected to be basetypes.StringValue, was: %T`, homedirPrefixAttribute))
	}

	initialPrimarygroupNumberAttribute, ok := attributes["initial_primarygroup_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_primarygroup_number is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	initialPrimarygroupNumberVal, ok := initialPrimarygroupNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_primarygroup_number expected to be basetypes.Int64Value, was: %T`, initialPrimarygroupNumberAttribute))
	}

	initialUidnumberAttribute, ok := attributes["initial_uidnumber"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_uidnumber is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	initialUidnumberVal, ok := initialUidnumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_uidnumber expected to be basetypes.Int64Value, was: %T`, initialUidnumberAttribute))
	}

	initialUsergroupNumberAttribute, ok := attributes["initial_usergroup_number"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_usergroup_number is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	initialUsergroupNumberVal, ok := initialUsergroupNumberAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_usergroup_number expected to be basetypes.Int64Value, was: %T`, initialUsergroupNumberAttribute))
	}

	isResourceTerminationDateRequiredAttribute, ok := attributes["is_resource_termination_date_required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_resource_termination_date_required is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	isResourceTerminationDateRequiredVal, ok := isResourceTerminationDateRequiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_resource_termination_date_required expected to be basetypes.BoolValue, was: %T`, isResourceTerminationDateRequiredAttribute))
	}

	latestDateForResourceTerminationAttribute, ok := attributes["latest_date_for_resource_termination"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`latest_date_for_resource_termination is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	latestDateForResourceTerminationVal, ok := latestDateForResourceTerminationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`latest_date_for_resource_termination expected to be basetypes.StringValue, was: %T`, latestDateForResourceTerminationAttribute))
	}

	managedRancherLoadBalancerDataVolumeSizeGbAttribute, ok := attributes["managed_rancher_load_balancer_data_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_data_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerDataVolumeSizeGbVal, ok := managedRancherLoadBalancerDataVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_data_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherLoadBalancerDataVolumeSizeGbAttribute))
	}

	managedRancherLoadBalancerDataVolumeTypeNameAttribute, ok := attributes["managed_rancher_load_balancer_data_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_data_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerDataVolumeTypeNameVal, ok := managedRancherLoadBalancerDataVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_data_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerDataVolumeTypeNameAttribute))
	}

	managedRancherLoadBalancerFlavorNameAttribute, ok := attributes["managed_rancher_load_balancer_flavor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_flavor_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerFlavorNameVal, ok := managedRancherLoadBalancerFlavorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_flavor_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerFlavorNameAttribute))
	}

	managedRancherLoadBalancerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_load_balancer_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_system_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerSystemVolumeSizeGbVal, ok := managedRancherLoadBalancerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherLoadBalancerSystemVolumeSizeGbAttribute))
	}

	managedRancherLoadBalancerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_load_balancer_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_load_balancer_system_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherLoadBalancerSystemVolumeTypeNameVal, ok := managedRancherLoadBalancerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_load_balancer_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherLoadBalancerSystemVolumeTypeNameAttribute))
	}

	managedRancherServerDataVolumeSizeGbAttribute, ok := attributes["managed_rancher_server_data_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_data_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerDataVolumeSizeGbVal, ok := managedRancherServerDataVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_data_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherServerDataVolumeSizeGbAttribute))
	}

	managedRancherServerDataVolumeTypeNameAttribute, ok := attributes["managed_rancher_server_data_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_data_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerDataVolumeTypeNameVal, ok := managedRancherServerDataVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_data_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherServerDataVolumeTypeNameAttribute))
	}

	managedRancherServerFlavorNameAttribute, ok := attributes["managed_rancher_server_flavor_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_flavor_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerFlavorNameVal, ok := managedRancherServerFlavorNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_flavor_name expected to be basetypes.StringValue, was: %T`, managedRancherServerFlavorNameAttribute))
	}

	managedRancherServerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_server_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_system_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerSystemVolumeSizeGbVal, ok := managedRancherServerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherServerSystemVolumeSizeGbAttribute))
	}

	managedRancherServerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_server_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_server_system_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherServerSystemVolumeTypeNameVal, ok := managedRancherServerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_server_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherServerSystemVolumeTypeNameAttribute))
	}

	managedRancherTenantMaxCpuAttribute, ok := attributes["managed_rancher_tenant_max_cpu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_tenant_max_cpu is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherTenantMaxCpuVal, ok := managedRancherTenantMaxCpuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_tenant_max_cpu expected to be basetypes.Int64Value, was: %T`, managedRancherTenantMaxCpuAttribute))
	}

	managedRancherTenantMaxDiskAttribute, ok := attributes["managed_rancher_tenant_max_disk"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_tenant_max_disk is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherTenantMaxDiskVal, ok := managedRancherTenantMaxDiskAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_tenant_max_disk expected to be basetypes.Int64Value, was: %T`, managedRancherTenantMaxDiskAttribute))
	}

	managedRancherTenantMaxRamAttribute, ok := attributes["managed_rancher_tenant_max_ram"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_tenant_max_ram is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherTenantMaxRamVal, ok := managedRancherTenantMaxRamAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_tenant_max_ram expected to be basetypes.Int64Value, was: %T`, managedRancherTenantMaxRamAttribute))
	}

	managedRancherWorkerSystemVolumeSizeGbAttribute, ok := attributes["managed_rancher_worker_system_volume_size_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_worker_system_volume_size_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherWorkerSystemVolumeSizeGbVal, ok := managedRancherWorkerSystemVolumeSizeGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_worker_system_volume_size_gb expected to be basetypes.Int64Value, was: %T`, managedRancherWorkerSystemVolumeSizeGbAttribute))
	}

	managedRancherWorkerSystemVolumeTypeNameAttribute, ok := attributes["managed_rancher_worker_system_volume_type_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_rancher_worker_system_volume_type_name is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	managedRancherWorkerSystemVolumeTypeNameVal, ok := managedRancherWorkerSystemVolumeTypeNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_rancher_worker_system_volume_type_name expected to be basetypes.StringValue, was: %T`, managedRancherWorkerSystemVolumeTypeNameAttribute))
	}

	maxInstancesAttribute, ok := attributes["max_instances"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_instances is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	maxInstancesVal, ok := maxInstancesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_instances expected to be basetypes.Int64Value, was: %T`, maxInstancesAttribute))
	}

	maxResourceTerminationOffsetInDaysAttribute, ok := attributes["max_resource_termination_offset_in_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_resource_termination_offset_in_days is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	maxResourceTerminationOffsetInDaysVal, ok := maxResourceTerminationOffsetInDaysAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_resource_termination_offset_in_days expected to be basetypes.Int64Value, was: %T`, maxResourceTerminationOffsetInDaysAttribute))
	}

	maxVolumesAttribute, ok := attributes["max_volumes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_volumes is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	maxVolumesVal, ok := maxVolumesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_volumes expected to be basetypes.Int64Value, was: %T`, maxVolumesAttribute))
	}

	maximalResourceCountPerProjectAttribute, ok := attributes["maximal_resource_count_per_project"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`maximal_resource_count_per_project is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	maximalResourceCountPerProjectVal, ok := maximalResourceCountPerProjectAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`maximal_resource_count_per_project expected to be basetypes.Int64Value, was: %T`, maximalResourceCountPerProjectAttribute))
	}

	minimalTeamCountForProvisioningAttribute, ok := attributes["minimal_team_count_for_provisioning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimal_team_count_for_provisioning is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	minimalTeamCountForProvisioningVal, ok := minimalTeamCountForProvisioningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimal_team_count_for_provisioning expected to be basetypes.Int64Value, was: %T`, minimalTeamCountForProvisioningAttribute))
	}

	openstackOfferingUuidListAttribute, ok := attributes["openstack_offering_uuid_list"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`openstack_offering_uuid_list is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	openstackOfferingUuidListVal, ok := openstackOfferingUuidListAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`openstack_offering_uuid_list expected to be basetypes.ListValue, was: %T`, openstackOfferingUuidListAttribute))
	}

	orderSupportsCommentsAndMetadataAttribute, ok := attributes["order_supports_comments_and_metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order_supports_comments_and_metadata is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	orderSupportsCommentsAndMetadataVal, ok := orderSupportsCommentsAndMetadataAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order_supports_comments_and_metadata expected to be basetypes.BoolValue, was: %T`, orderSupportsCommentsAndMetadataAttribute))
	}

	projectPermanentDirectoryAttribute, ok := attributes["project_permanent_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`project_permanent_directory is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	projectPermanentDirectoryVal, ok := projectPermanentDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`project_permanent_directory expected to be basetypes.StringValue, was: %T`, projectPermanentDirectoryAttribute))
	}

	requiredTeamRoleForProvisioningAttribute, ok := attributes["required_team_role_for_provisioning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_team_role_for_provisioning is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	requiredTeamRoleForProvisioningVal, ok := requiredTeamRoleForProvisioningAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_team_role_for_provisioning expected to be basetypes.StringValue, was: %T`, requiredTeamRoleForProvisioningAttribute))
	}

	scratchProjectDirectoryAttribute, ok := attributes["scratch_project_directory"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`scratch_project_directory is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	scratchProjectDirectoryVal, ok := scratchProjectDirectoryAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`scratch_project_directory expected to be basetypes.StringValue, was: %T`, scratchProjectDirectoryAttribute))
	}

	serviceProviderCanCreateOfferingUserAttribute, ok := attributes["service_provider_can_create_offering_user"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_provider_can_create_offering_user is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	serviceProviderCanCreateOfferingUserVal, ok := serviceProviderCanCreateOfferingUserAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_provider_can_create_offering_user expected to be basetypes.BoolValue, was: %T`, serviceProviderCanCreateOfferingUserAttribute))
	}

	snapshotSizeLimitGbAttribute, ok := attributes["snapshot_size_limit_gb"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`snapshot_size_limit_gb is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	snapshotSizeLimitGbVal, ok := snapshotSizeLimitGbAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`snapshot_size_limit_gb expected to be basetypes.Int64Value, was: %T`, snapshotSizeLimitGbAttribute))
	}

	storageModeAttribute, ok := attributes["storage_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_mode is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	storageModeVal, ok := storageModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_mode expected to be basetypes.StringValue, was: %T`, storageModeAttribute))
	}

	supportsDownscalingAttribute, ok := attributes["supports_downscaling"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supports_downscaling is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	supportsDownscalingVal, ok := supportsDownscalingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supports_downscaling expected to be basetypes.BoolValue, was: %T`, supportsDownscalingAttribute))
	}

	supportsPausingAttribute, ok := attributes["supports_pausing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`supports_pausing is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	supportsPausingVal, ok := supportsPausingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`supports_pausing expected to be basetypes.BoolValue, was: %T`, supportsPausingAttribute))
	}

	usernameAnonymizedPrefixAttribute, ok := attributes["username_anonymized_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_anonymized_prefix is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	usernameAnonymizedPrefixVal, ok := usernameAnonymizedPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_anonymized_prefix expected to be basetypes.StringValue, was: %T`, usernameAnonymizedPrefixAttribute))
	}

	usernameGenerationPolicyAttribute, ok := attributes["username_generation_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username_generation_policy is missing from object`)

		return NewPluginOptionsValueUnknown(), diags
	}

	usernameGenerationPolicyVal, ok := usernameGenerationPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username_generation_policy expected to be basetypes.StringValue, was: %T`, usernameGenerationPolicyAttribute))
	}

	if diags.HasError() {
		return NewPluginOptionsValueUnknown(), diags
	}

	return PluginOptionsValue{
		AutoApproveInServiceProviderProjects:           autoApproveInServiceProviderProjectsVal,
		AutoApproveRemoteOrders:                        autoApproveRemoteOrdersVal,
		BackendIdDisplayLabel:                          backendIdDisplayLabelVal,
		ConcealBillingData:                             concealBillingDataVal,
		DefaultInternalNetworkMtu:                      defaultInternalNetworkMtuVal,
		DefaultResourceTerminationOffsetInDays:         defaultResourceTerminationOffsetInDaysVal,
		DeploymentMode:                                 deploymentModeVal,
		EnableIssuesForMembershipChanges:               enableIssuesForMembershipChangesVal,
		FlavorsRegex:                                   flavorsRegexVal,
		HeappeClusterId:                                heappeClusterIdVal,
		HeappeLocalBasePath:                            heappeLocalBasePathVal,
		HeappeUrl:                                      heappeUrlVal,
		HeappeUsername:                                 heappeUsernameVal,
		HighlightBackendIdDisplay:                      highlightBackendIdDisplayVal,
		HomedirPrefix:                                  homedirPrefixVal,
		InitialPrimarygroupNumber:                      initialPrimarygroupNumberVal,
		InitialUidnumber:                               initialUidnumberVal,
		InitialUsergroupNumber:                         initialUsergroupNumberVal,
		IsResourceTerminationDateRequired:              isResourceTerminationDateRequiredVal,
		LatestDateForResourceTermination:               latestDateForResourceTerminationVal,
		ManagedRancherLoadBalancerDataVolumeSizeGb:     managedRancherLoadBalancerDataVolumeSizeGbVal,
		ManagedRancherLoadBalancerDataVolumeTypeName:   managedRancherLoadBalancerDataVolumeTypeNameVal,
		ManagedRancherLoadBalancerFlavorName:           managedRancherLoadBalancerFlavorNameVal,
		ManagedRancherLoadBalancerSystemVolumeSizeGb:   managedRancherLoadBalancerSystemVolumeSizeGbVal,
		ManagedRancherLoadBalancerSystemVolumeTypeName: managedRancherLoadBalancerSystemVolumeTypeNameVal,
		ManagedRancherServerDataVolumeSizeGb:           managedRancherServerDataVolumeSizeGbVal,
		ManagedRancherServerDataVolumeTypeName:         managedRancherServerDataVolumeTypeNameVal,
		ManagedRancherServerFlavorName:                 managedRancherServerFlavorNameVal,
		ManagedRancherServerSystemVolumeSizeGb:         managedRancherServerSystemVolumeSizeGbVal,
		ManagedRancherServerSystemVolumeTypeName:       managedRancherServerSystemVolumeTypeNameVal,
		ManagedRancherTenantMaxCpu:                     managedRancherTenantMaxCpuVal,
		ManagedRancherTenantMaxDisk:                    managedRancherTenantMaxDiskVal,
		ManagedRancherTenantMaxRam:                     managedRancherTenantMaxRamVal,
		ManagedRancherWorkerSystemVolumeSizeGb:         managedRancherWorkerSystemVolumeSizeGbVal,
		ManagedRancherWorkerSystemVolumeTypeName:       managedRancherWorkerSystemVolumeTypeNameVal,
		MaxInstances:                                   maxInstancesVal,
		MaxResourceTerminationOffsetInDays:             maxResourceTerminationOffsetInDaysVal,
		MaxVolumes:                                     maxVolumesVal,
		MaximalResourceCountPerProject:                 maximalResourceCountPerProjectVal,
		MinimalTeamCountForProvisioning:                minimalTeamCountForProvisioningVal,
		OpenstackOfferingUuidList:                      openstackOfferingUuidListVal,
		OrderSupportsCommentsAndMetadata:               orderSupportsCommentsAndMetadataVal,
		ProjectPermanentDirectory:                      projectPermanentDirectoryVal,
		RequiredTeamRoleForProvisioning:                requiredTeamRoleForProvisioningVal,
		ScratchProjectDirectory:                        scratchProjectDirectoryVal,
		ServiceProviderCanCreateOfferingUser:           serviceProviderCanCreateOfferingUserVal,
		SnapshotSizeLimitGb:                            snapshotSizeLimitGbVal,
		StorageMode:                                    storageModeVal,
		SupportsDownscaling:                            supportsDownscalingVal,
		SupportsPausing:                                supportsPausingVal,
		UsernameAnonymizedPrefix:                       usernameAnonymizedPrefixVal,
		UsernameGenerationPolicy:                       usernameGenerationPolicyVal,
		state:                                          attr.ValueStateKnown,
	}, diags
}

func NewPluginOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PluginOptionsValue {
	object, diags := NewPluginOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPluginOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PluginOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPluginOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPluginOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPluginOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPluginOptionsValueMust(PluginOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PluginOptionsType) ValueType(ctx context.Context) attr.Value {
	return PluginOptionsValue{}
}

var _ basetypes.ObjectValuable = PluginOptionsValue{}

type PluginOptionsValue struct {
	AutoApproveInServiceProviderProjects           basetypes.BoolValue   `tfsdk:"auto_approve_in_service_provider_projects"`
	AutoApproveRemoteOrders                        basetypes.BoolValue   `tfsdk:"auto_approve_remote_orders"`
	BackendIdDisplayLabel                          basetypes.StringValue `tfsdk:"backend_id_display_label"`
	ConcealBillingData                             basetypes.BoolValue   `tfsdk:"conceal_billing_data"`
	DefaultInternalNetworkMtu                      basetypes.Int64Value  `tfsdk:"default_internal_network_mtu"`
	DefaultResourceTerminationOffsetInDays         basetypes.Int64Value  `tfsdk:"default_resource_termination_offset_in_days"`
	DeploymentMode                                 basetypes.StringValue `tfsdk:"deployment_mode"`
	EnableIssuesForMembershipChanges               basetypes.BoolValue   `tfsdk:"enable_issues_for_membership_changes"`
	FlavorsRegex                                   basetypes.StringValue `tfsdk:"flavors_regex"`
	HeappeClusterId                                basetypes.StringValue `tfsdk:"heappe_cluster_id"`
	HeappeLocalBasePath                            basetypes.StringValue `tfsdk:"heappe_local_base_path"`
	HeappeUrl                                      basetypes.StringValue `tfsdk:"heappe_url"`
	HeappeUsername                                 basetypes.StringValue `tfsdk:"heappe_username"`
	HighlightBackendIdDisplay                      basetypes.BoolValue   `tfsdk:"highlight_backend_id_display"`
	HomedirPrefix                                  basetypes.StringValue `tfsdk:"homedir_prefix"`
	InitialPrimarygroupNumber                      basetypes.Int64Value  `tfsdk:"initial_primarygroup_number"`
	InitialUidnumber                               basetypes.Int64Value  `tfsdk:"initial_uidnumber"`
	InitialUsergroupNumber                         basetypes.Int64Value  `tfsdk:"initial_usergroup_number"`
	IsResourceTerminationDateRequired              basetypes.BoolValue   `tfsdk:"is_resource_termination_date_required"`
	LatestDateForResourceTermination               basetypes.StringValue `tfsdk:"latest_date_for_resource_termination"`
	ManagedRancherLoadBalancerDataVolumeSizeGb     basetypes.Int64Value  `tfsdk:"managed_rancher_load_balancer_data_volume_size_gb"`
	ManagedRancherLoadBalancerDataVolumeTypeName   basetypes.StringValue `tfsdk:"managed_rancher_load_balancer_data_volume_type_name"`
	ManagedRancherLoadBalancerFlavorName           basetypes.StringValue `tfsdk:"managed_rancher_load_balancer_flavor_name"`
	ManagedRancherLoadBalancerSystemVolumeSizeGb   basetypes.Int64Value  `tfsdk:"managed_rancher_load_balancer_system_volume_size_gb"`
	ManagedRancherLoadBalancerSystemVolumeTypeName basetypes.StringValue `tfsdk:"managed_rancher_load_balancer_system_volume_type_name"`
	ManagedRancherServerDataVolumeSizeGb           basetypes.Int64Value  `tfsdk:"managed_rancher_server_data_volume_size_gb"`
	ManagedRancherServerDataVolumeTypeName         basetypes.StringValue `tfsdk:"managed_rancher_server_data_volume_type_name"`
	ManagedRancherServerFlavorName                 basetypes.StringValue `tfsdk:"managed_rancher_server_flavor_name"`
	ManagedRancherServerSystemVolumeSizeGb         basetypes.Int64Value  `tfsdk:"managed_rancher_server_system_volume_size_gb"`
	ManagedRancherServerSystemVolumeTypeName       basetypes.StringValue `tfsdk:"managed_rancher_server_system_volume_type_name"`
	ManagedRancherTenantMaxCpu                     basetypes.Int64Value  `tfsdk:"managed_rancher_tenant_max_cpu"`
	ManagedRancherTenantMaxDisk                    basetypes.Int64Value  `tfsdk:"managed_rancher_tenant_max_disk"`
	ManagedRancherTenantMaxRam                     basetypes.Int64Value  `tfsdk:"managed_rancher_tenant_max_ram"`
	ManagedRancherWorkerSystemVolumeSizeGb         basetypes.Int64Value  `tfsdk:"managed_rancher_worker_system_volume_size_gb"`
	ManagedRancherWorkerSystemVolumeTypeName       basetypes.StringValue `tfsdk:"managed_rancher_worker_system_volume_type_name"`
	MaxInstances                                   basetypes.Int64Value  `tfsdk:"max_instances"`
	MaxResourceTerminationOffsetInDays             basetypes.Int64Value  `tfsdk:"max_resource_termination_offset_in_days"`
	MaxVolumes                                     basetypes.Int64Value  `tfsdk:"max_volumes"`
	MaximalResourceCountPerProject                 basetypes.Int64Value  `tfsdk:"maximal_resource_count_per_project"`
	MinimalTeamCountForProvisioning                basetypes.Int64Value  `tfsdk:"minimal_team_count_for_provisioning"`
	OpenstackOfferingUuidList                      basetypes.ListValue   `tfsdk:"openstack_offering_uuid_list"`
	OrderSupportsCommentsAndMetadata               basetypes.BoolValue   `tfsdk:"order_supports_comments_and_metadata"`
	ProjectPermanentDirectory                      basetypes.StringValue `tfsdk:"project_permanent_directory"`
	RequiredTeamRoleForProvisioning                basetypes.StringValue `tfsdk:"required_team_role_for_provisioning"`
	ScratchProjectDirectory                        basetypes.StringValue `tfsdk:"scratch_project_directory"`
	ServiceProviderCanCreateOfferingUser           basetypes.BoolValue   `tfsdk:"service_provider_can_create_offering_user"`
	SnapshotSizeLimitGb                            basetypes.Int64Value  `tfsdk:"snapshot_size_limit_gb"`
	StorageMode                                    basetypes.StringValue `tfsdk:"storage_mode"`
	SupportsDownscaling                            basetypes.BoolValue   `tfsdk:"supports_downscaling"`
	SupportsPausing                                basetypes.BoolValue   `tfsdk:"supports_pausing"`
	UsernameAnonymizedPrefix                       basetypes.StringValue `tfsdk:"username_anonymized_prefix"`
	UsernameGenerationPolicy                       basetypes.StringValue `tfsdk:"username_generation_policy"`
	state                                          attr.ValueState
}

func (v PluginOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 52)

	var val tftypes.Value
	var err error

	attrTypes["auto_approve_in_service_provider_projects"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["auto_approve_remote_orders"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["backend_id_display_label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["conceal_billing_data"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["default_internal_network_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["default_resource_termination_offset_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["deployment_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enable_issues_for_membership_changes"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["flavors_regex"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["heappe_cluster_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["heappe_local_base_path"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["heappe_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["heappe_username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["highlight_backend_id_display"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["homedir_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["initial_primarygroup_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["initial_uidnumber"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["initial_usergroup_number"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_resource_termination_date_required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["latest_date_for_resource_termination"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_data_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_data_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_flavor_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_system_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_load_balancer_system_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_data_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_data_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_flavor_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_system_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_server_system_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["managed_rancher_tenant_max_cpu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_tenant_max_disk"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_tenant_max_ram"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_worker_system_volume_size_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_rancher_worker_system_volume_type_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max_instances"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_resource_termination_offset_in_days"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_volumes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["maximal_resource_count_per_project"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimal_team_count_for_provisioning"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["openstack_offering_uuid_list"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["order_supports_comments_and_metadata"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["project_permanent_directory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["required_team_role_for_provisioning"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["scratch_project_directory"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_provider_can_create_offering_user"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["snapshot_size_limit_gb"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["supports_downscaling"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["supports_pausing"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["username_anonymized_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["username_generation_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 52)

		val, err = v.AutoApproveInServiceProviderProjects.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_approve_in_service_provider_projects"] = val

		val, err = v.AutoApproveRemoteOrders.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["auto_approve_remote_orders"] = val

		val, err = v.BackendIdDisplayLabel.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["backend_id_display_label"] = val

		val, err = v.ConcealBillingData.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["conceal_billing_data"] = val

		val, err = v.DefaultInternalNetworkMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_internal_network_mtu"] = val

		val, err = v.DefaultResourceTerminationOffsetInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_resource_termination_offset_in_days"] = val

		val, err = v.DeploymentMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deployment_mode"] = val

		val, err = v.EnableIssuesForMembershipChanges.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_issues_for_membership_changes"] = val

		val, err = v.FlavorsRegex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["flavors_regex"] = val

		val, err = v.HeappeClusterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["heappe_cluster_id"] = val

		val, err = v.HeappeLocalBasePath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["heappe_local_base_path"] = val

		val, err = v.HeappeUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["heappe_url"] = val

		val, err = v.HeappeUsername.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["heappe_username"] = val

		val, err = v.HighlightBackendIdDisplay.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["highlight_backend_id_display"] = val

		val, err = v.HomedirPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["homedir_prefix"] = val

		val, err = v.InitialPrimarygroupNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initial_primarygroup_number"] = val

		val, err = v.InitialUidnumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initial_uidnumber"] = val

		val, err = v.InitialUsergroupNumber.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initial_usergroup_number"] = val

		val, err = v.IsResourceTerminationDateRequired.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_resource_termination_date_required"] = val

		val, err = v.LatestDateForResourceTermination.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["latest_date_for_resource_termination"] = val

		val, err = v.ManagedRancherLoadBalancerDataVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_data_volume_size_gb"] = val

		val, err = v.ManagedRancherLoadBalancerDataVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_data_volume_type_name"] = val

		val, err = v.ManagedRancherLoadBalancerFlavorName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_flavor_name"] = val

		val, err = v.ManagedRancherLoadBalancerSystemVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_system_volume_size_gb"] = val

		val, err = v.ManagedRancherLoadBalancerSystemVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_load_balancer_system_volume_type_name"] = val

		val, err = v.ManagedRancherServerDataVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_data_volume_size_gb"] = val

		val, err = v.ManagedRancherServerDataVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_data_volume_type_name"] = val

		val, err = v.ManagedRancherServerFlavorName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_flavor_name"] = val

		val, err = v.ManagedRancherServerSystemVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_system_volume_size_gb"] = val

		val, err = v.ManagedRancherServerSystemVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_server_system_volume_type_name"] = val

		val, err = v.ManagedRancherTenantMaxCpu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_tenant_max_cpu"] = val

		val, err = v.ManagedRancherTenantMaxDisk.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_tenant_max_disk"] = val

		val, err = v.ManagedRancherTenantMaxRam.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_tenant_max_ram"] = val

		val, err = v.ManagedRancherWorkerSystemVolumeSizeGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_worker_system_volume_size_gb"] = val

		val, err = v.ManagedRancherWorkerSystemVolumeTypeName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_rancher_worker_system_volume_type_name"] = val

		val, err = v.MaxInstances.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_instances"] = val

		val, err = v.MaxResourceTerminationOffsetInDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_resource_termination_offset_in_days"] = val

		val, err = v.MaxVolumes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_volumes"] = val

		val, err = v.MaximalResourceCountPerProject.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["maximal_resource_count_per_project"] = val

		val, err = v.MinimalTeamCountForProvisioning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimal_team_count_for_provisioning"] = val

		val, err = v.OpenstackOfferingUuidList.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["openstack_offering_uuid_list"] = val

		val, err = v.OrderSupportsCommentsAndMetadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["order_supports_comments_and_metadata"] = val

		val, err = v.ProjectPermanentDirectory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["project_permanent_directory"] = val

		val, err = v.RequiredTeamRoleForProvisioning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_team_role_for_provisioning"] = val

		val, err = v.ScratchProjectDirectory.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["scratch_project_directory"] = val

		val, err = v.ServiceProviderCanCreateOfferingUser.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_provider_can_create_offering_user"] = val

		val, err = v.SnapshotSizeLimitGb.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["snapshot_size_limit_gb"] = val

		val, err = v.StorageMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_mode"] = val

		val, err = v.SupportsDownscaling.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["supports_downscaling"] = val

		val, err = v.SupportsPausing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["supports_pausing"] = val

		val, err = v.UsernameAnonymizedPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username_anonymized_prefix"] = val

		val, err = v.UsernameGenerationPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username_generation_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PluginOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PluginOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PluginOptionsValue) String() string {
	return "PluginOptionsValue"
}

func (v PluginOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var openstackOfferingUuidListVal basetypes.ListValue
	switch {
	case v.OpenstackOfferingUuidList.IsUnknown():
		openstackOfferingUuidListVal = types.ListUnknown(types.StringType)
	case v.OpenstackOfferingUuidList.IsNull():
		openstackOfferingUuidListVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		openstackOfferingUuidListVal, d = types.ListValue(types.StringType, v.OpenstackOfferingUuidList.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"auto_approve_in_service_provider_projects":             basetypes.BoolType{},
			"auto_approve_remote_orders":                            basetypes.BoolType{},
			"backend_id_display_label":                              basetypes.StringType{},
			"conceal_billing_data":                                  basetypes.BoolType{},
			"default_internal_network_mtu":                          basetypes.Int64Type{},
			"default_resource_termination_offset_in_days":           basetypes.Int64Type{},
			"deployment_mode":                                       basetypes.StringType{},
			"enable_issues_for_membership_changes":                  basetypes.BoolType{},
			"flavors_regex":                                         basetypes.StringType{},
			"heappe_cluster_id":                                     basetypes.StringType{},
			"heappe_local_base_path":                                basetypes.StringType{},
			"heappe_url":                                            basetypes.StringType{},
			"heappe_username":                                       basetypes.StringType{},
			"highlight_backend_id_display":                          basetypes.BoolType{},
			"homedir_prefix":                                        basetypes.StringType{},
			"initial_primarygroup_number":                           basetypes.Int64Type{},
			"initial_uidnumber":                                     basetypes.Int64Type{},
			"initial_usergroup_number":                              basetypes.Int64Type{},
			"is_resource_termination_date_required":                 basetypes.BoolType{},
			"latest_date_for_resource_termination":                  basetypes.StringType{},
			"managed_rancher_load_balancer_data_volume_size_gb":     basetypes.Int64Type{},
			"managed_rancher_load_balancer_data_volume_type_name":   basetypes.StringType{},
			"managed_rancher_load_balancer_flavor_name":             basetypes.StringType{},
			"managed_rancher_load_balancer_system_volume_size_gb":   basetypes.Int64Type{},
			"managed_rancher_load_balancer_system_volume_type_name": basetypes.StringType{},
			"managed_rancher_server_data_volume_size_gb":            basetypes.Int64Type{},
			"managed_rancher_server_data_volume_type_name":          basetypes.StringType{},
			"managed_rancher_server_flavor_name":                    basetypes.StringType{},
			"managed_rancher_server_system_volume_size_gb":          basetypes.Int64Type{},
			"managed_rancher_server_system_volume_type_name":        basetypes.StringType{},
			"managed_rancher_tenant_max_cpu":                        basetypes.Int64Type{},
			"managed_rancher_tenant_max_disk":                       basetypes.Int64Type{},
			"managed_rancher_tenant_max_ram":                        basetypes.Int64Type{},
			"managed_rancher_worker_system_volume_size_gb":          basetypes.Int64Type{},
			"managed_rancher_worker_system_volume_type_name":        basetypes.StringType{},
			"max_instances":                                         basetypes.Int64Type{},
			"max_resource_termination_offset_in_days":               basetypes.Int64Type{},
			"max_volumes":                                           basetypes.Int64Type{},
			"maximal_resource_count_per_project":                    basetypes.Int64Type{},
			"minimal_team_count_for_provisioning":                   basetypes.Int64Type{},
			"openstack_offering_uuid_list": basetypes.ListType{
				ElemType: types.StringType,
			},
			"order_supports_comments_and_metadata":      basetypes.BoolType{},
			"project_permanent_directory":               basetypes.StringType{},
			"required_team_role_for_provisioning":       basetypes.StringType{},
			"scratch_project_directory":                 basetypes.StringType{},
			"service_provider_can_create_offering_user": basetypes.BoolType{},
			"snapshot_size_limit_gb":                    basetypes.Int64Type{},
			"storage_mode":                              basetypes.StringType{},
			"supports_downscaling":                      basetypes.BoolType{},
			"supports_pausing":                          basetypes.BoolType{},
			"username_anonymized_prefix":                basetypes.StringType{},
			"username_generation_policy":                basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"auto_approve_in_service_provider_projects":             basetypes.BoolType{},
		"auto_approve_remote_orders":                            basetypes.BoolType{},
		"backend_id_display_label":                              basetypes.StringType{},
		"conceal_billing_data":                                  basetypes.BoolType{},
		"default_internal_network_mtu":                          basetypes.Int64Type{},
		"default_resource_termination_offset_in_days":           basetypes.Int64Type{},
		"deployment_mode":                                       basetypes.StringType{},
		"enable_issues_for_membership_changes":                  basetypes.BoolType{},
		"flavors_regex":                                         basetypes.StringType{},
		"heappe_cluster_id":                                     basetypes.StringType{},
		"heappe_local_base_path":                                basetypes.StringType{},
		"heappe_url":                                            basetypes.StringType{},
		"heappe_username":                                       basetypes.StringType{},
		"highlight_backend_id_display":                          basetypes.BoolType{},
		"homedir_prefix":                                        basetypes.StringType{},
		"initial_primarygroup_number":                           basetypes.Int64Type{},
		"initial_uidnumber":                                     basetypes.Int64Type{},
		"initial_usergroup_number":                              basetypes.Int64Type{},
		"is_resource_termination_date_required":                 basetypes.BoolType{},
		"latest_date_for_resource_termination":                  basetypes.StringType{},
		"managed_rancher_load_balancer_data_volume_size_gb":     basetypes.Int64Type{},
		"managed_rancher_load_balancer_data_volume_type_name":   basetypes.StringType{},
		"managed_rancher_load_balancer_flavor_name":             basetypes.StringType{},
		"managed_rancher_load_balancer_system_volume_size_gb":   basetypes.Int64Type{},
		"managed_rancher_load_balancer_system_volume_type_name": basetypes.StringType{},
		"managed_rancher_server_data_volume_size_gb":            basetypes.Int64Type{},
		"managed_rancher_server_data_volume_type_name":          basetypes.StringType{},
		"managed_rancher_server_flavor_name":                    basetypes.StringType{},
		"managed_rancher_server_system_volume_size_gb":          basetypes.Int64Type{},
		"managed_rancher_server_system_volume_type_name":        basetypes.StringType{},
		"managed_rancher_tenant_max_cpu":                        basetypes.Int64Type{},
		"managed_rancher_tenant_max_disk":                       basetypes.Int64Type{},
		"managed_rancher_tenant_max_ram":                        basetypes.Int64Type{},
		"managed_rancher_worker_system_volume_size_gb":          basetypes.Int64Type{},
		"managed_rancher_worker_system_volume_type_name":        basetypes.StringType{},
		"max_instances":                                         basetypes.Int64Type{},
		"max_resource_termination_offset_in_days":               basetypes.Int64Type{},
		"max_volumes":                                           basetypes.Int64Type{},
		"maximal_resource_count_per_project":                    basetypes.Int64Type{},
		"minimal_team_count_for_provisioning":                   basetypes.Int64Type{},
		"openstack_offering_uuid_list": basetypes.ListType{
			ElemType: types.StringType,
		},
		"order_supports_comments_and_metadata":      basetypes.BoolType{},
		"project_permanent_directory":               basetypes.StringType{},
		"required_team_role_for_provisioning":       basetypes.StringType{},
		"scratch_project_directory":                 basetypes.StringType{},
		"service_provider_can_create_offering_user": basetypes.BoolType{},
		"snapshot_size_limit_gb":                    basetypes.Int64Type{},
		"storage_mode":                              basetypes.StringType{},
		"supports_downscaling":                      basetypes.BoolType{},
		"supports_pausing":                          basetypes.BoolType{},
		"username_anonymized_prefix":                basetypes.StringType{},
		"username_generation_policy":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"auto_approve_in_service_provider_projects":             v.AutoApproveInServiceProviderProjects,
			"auto_approve_remote_orders":                            v.AutoApproveRemoteOrders,
			"backend_id_display_label":                              v.BackendIdDisplayLabel,
			"conceal_billing_data":                                  v.ConcealBillingData,
			"default_internal_network_mtu":                          v.DefaultInternalNetworkMtu,
			"default_resource_termination_offset_in_days":           v.DefaultResourceTerminationOffsetInDays,
			"deployment_mode":                                       v.DeploymentMode,
			"enable_issues_for_membership_changes":                  v.EnableIssuesForMembershipChanges,
			"flavors_regex":                                         v.FlavorsRegex,
			"heappe_cluster_id":                                     v.HeappeClusterId,
			"heappe_local_base_path":                                v.HeappeLocalBasePath,
			"heappe_url":                                            v.HeappeUrl,
			"heappe_username":                                       v.HeappeUsername,
			"highlight_backend_id_display":                          v.HighlightBackendIdDisplay,
			"homedir_prefix":                                        v.HomedirPrefix,
			"initial_primarygroup_number":                           v.InitialPrimarygroupNumber,
			"initial_uidnumber":                                     v.InitialUidnumber,
			"initial_usergroup_number":                              v.InitialUsergroupNumber,
			"is_resource_termination_date_required":                 v.IsResourceTerminationDateRequired,
			"latest_date_for_resource_termination":                  v.LatestDateForResourceTermination,
			"managed_rancher_load_balancer_data_volume_size_gb":     v.ManagedRancherLoadBalancerDataVolumeSizeGb,
			"managed_rancher_load_balancer_data_volume_type_name":   v.ManagedRancherLoadBalancerDataVolumeTypeName,
			"managed_rancher_load_balancer_flavor_name":             v.ManagedRancherLoadBalancerFlavorName,
			"managed_rancher_load_balancer_system_volume_size_gb":   v.ManagedRancherLoadBalancerSystemVolumeSizeGb,
			"managed_rancher_load_balancer_system_volume_type_name": v.ManagedRancherLoadBalancerSystemVolumeTypeName,
			"managed_rancher_server_data_volume_size_gb":            v.ManagedRancherServerDataVolumeSizeGb,
			"managed_rancher_server_data_volume_type_name":          v.ManagedRancherServerDataVolumeTypeName,
			"managed_rancher_server_flavor_name":                    v.ManagedRancherServerFlavorName,
			"managed_rancher_server_system_volume_size_gb":          v.ManagedRancherServerSystemVolumeSizeGb,
			"managed_rancher_server_system_volume_type_name":        v.ManagedRancherServerSystemVolumeTypeName,
			"managed_rancher_tenant_max_cpu":                        v.ManagedRancherTenantMaxCpu,
			"managed_rancher_tenant_max_disk":                       v.ManagedRancherTenantMaxDisk,
			"managed_rancher_tenant_max_ram":                        v.ManagedRancherTenantMaxRam,
			"managed_rancher_worker_system_volume_size_gb":          v.ManagedRancherWorkerSystemVolumeSizeGb,
			"managed_rancher_worker_system_volume_type_name":        v.ManagedRancherWorkerSystemVolumeTypeName,
			"max_instances":                                         v.MaxInstances,
			"max_resource_termination_offset_in_days":               v.MaxResourceTerminationOffsetInDays,
			"max_volumes":                                           v.MaxVolumes,
			"maximal_resource_count_per_project":                    v.MaximalResourceCountPerProject,
			"minimal_team_count_for_provisioning":                   v.MinimalTeamCountForProvisioning,
			"openstack_offering_uuid_list":                          openstackOfferingUuidListVal,
			"order_supports_comments_and_metadata":                  v.OrderSupportsCommentsAndMetadata,
			"project_permanent_directory":                           v.ProjectPermanentDirectory,
			"required_team_role_for_provisioning":                   v.RequiredTeamRoleForProvisioning,
			"scratch_project_directory":                             v.ScratchProjectDirectory,
			"service_provider_can_create_offering_user":             v.ServiceProviderCanCreateOfferingUser,
			"snapshot_size_limit_gb":                                v.SnapshotSizeLimitGb,
			"storage_mode":                                          v.StorageMode,
			"supports_downscaling":                                  v.SupportsDownscaling,
			"supports_pausing":                                      v.SupportsPausing,
			"username_anonymized_prefix":                            v.UsernameAnonymizedPrefix,
			"username_generation_policy":                            v.UsernameGenerationPolicy,
		})

	return objVal, diags
}

func (v PluginOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(PluginOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutoApproveInServiceProviderProjects.Equal(other.AutoApproveInServiceProviderProjects) {
		return false
	}

	if !v.AutoApproveRemoteOrders.Equal(other.AutoApproveRemoteOrders) {
		return false
	}

	if !v.BackendIdDisplayLabel.Equal(other.BackendIdDisplayLabel) {
		return false
	}

	if !v.ConcealBillingData.Equal(other.ConcealBillingData) {
		return false
	}

	if !v.DefaultInternalNetworkMtu.Equal(other.DefaultInternalNetworkMtu) {
		return false
	}

	if !v.DefaultResourceTerminationOffsetInDays.Equal(other.DefaultResourceTerminationOffsetInDays) {
		return false
	}

	if !v.DeploymentMode.Equal(other.DeploymentMode) {
		return false
	}

	if !v.EnableIssuesForMembershipChanges.Equal(other.EnableIssuesForMembershipChanges) {
		return false
	}

	if !v.FlavorsRegex.Equal(other.FlavorsRegex) {
		return false
	}

	if !v.HeappeClusterId.Equal(other.HeappeClusterId) {
		return false
	}

	if !v.HeappeLocalBasePath.Equal(other.HeappeLocalBasePath) {
		return false
	}

	if !v.HeappeUrl.Equal(other.HeappeUrl) {
		return false
	}

	if !v.HeappeUsername.Equal(other.HeappeUsername) {
		return false
	}

	if !v.HighlightBackendIdDisplay.Equal(other.HighlightBackendIdDisplay) {
		return false
	}

	if !v.HomedirPrefix.Equal(other.HomedirPrefix) {
		return false
	}

	if !v.InitialPrimarygroupNumber.Equal(other.InitialPrimarygroupNumber) {
		return false
	}

	if !v.InitialUidnumber.Equal(other.InitialUidnumber) {
		return false
	}

	if !v.InitialUsergroupNumber.Equal(other.InitialUsergroupNumber) {
		return false
	}

	if !v.IsResourceTerminationDateRequired.Equal(other.IsResourceTerminationDateRequired) {
		return false
	}

	if !v.LatestDateForResourceTermination.Equal(other.LatestDateForResourceTermination) {
		return false
	}

	if !v.ManagedRancherLoadBalancerDataVolumeSizeGb.Equal(other.ManagedRancherLoadBalancerDataVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherLoadBalancerDataVolumeTypeName.Equal(other.ManagedRancherLoadBalancerDataVolumeTypeName) {
		return false
	}

	if !v.ManagedRancherLoadBalancerFlavorName.Equal(other.ManagedRancherLoadBalancerFlavorName) {
		return false
	}

	if !v.ManagedRancherLoadBalancerSystemVolumeSizeGb.Equal(other.ManagedRancherLoadBalancerSystemVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherLoadBalancerSystemVolumeTypeName.Equal(other.ManagedRancherLoadBalancerSystemVolumeTypeName) {
		return false
	}

	if !v.ManagedRancherServerDataVolumeSizeGb.Equal(other.ManagedRancherServerDataVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherServerDataVolumeTypeName.Equal(other.ManagedRancherServerDataVolumeTypeName) {
		return false
	}

	if !v.ManagedRancherServerFlavorName.Equal(other.ManagedRancherServerFlavorName) {
		return false
	}

	if !v.ManagedRancherServerSystemVolumeSizeGb.Equal(other.ManagedRancherServerSystemVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherServerSystemVolumeTypeName.Equal(other.ManagedRancherServerSystemVolumeTypeName) {
		return false
	}

	if !v.ManagedRancherTenantMaxCpu.Equal(other.ManagedRancherTenantMaxCpu) {
		return false
	}

	if !v.ManagedRancherTenantMaxDisk.Equal(other.ManagedRancherTenantMaxDisk) {
		return false
	}

	if !v.ManagedRancherTenantMaxRam.Equal(other.ManagedRancherTenantMaxRam) {
		return false
	}

	if !v.ManagedRancherWorkerSystemVolumeSizeGb.Equal(other.ManagedRancherWorkerSystemVolumeSizeGb) {
		return false
	}

	if !v.ManagedRancherWorkerSystemVolumeTypeName.Equal(other.ManagedRancherWorkerSystemVolumeTypeName) {
		return false
	}

	if !v.MaxInstances.Equal(other.MaxInstances) {
		return false
	}

	if !v.MaxResourceTerminationOffsetInDays.Equal(other.MaxResourceTerminationOffsetInDays) {
		return false
	}

	if !v.MaxVolumes.Equal(other.MaxVolumes) {
		return false
	}

	if !v.MaximalResourceCountPerProject.Equal(other.MaximalResourceCountPerProject) {
		return false
	}

	if !v.MinimalTeamCountForProvisioning.Equal(other.MinimalTeamCountForProvisioning) {
		return false
	}

	if !v.OpenstackOfferingUuidList.Equal(other.OpenstackOfferingUuidList) {
		return false
	}

	if !v.OrderSupportsCommentsAndMetadata.Equal(other.OrderSupportsCommentsAndMetadata) {
		return false
	}

	if !v.ProjectPermanentDirectory.Equal(other.ProjectPermanentDirectory) {
		return false
	}

	if !v.RequiredTeamRoleForProvisioning.Equal(other.RequiredTeamRoleForProvisioning) {
		return false
	}

	if !v.ScratchProjectDirectory.Equal(other.ScratchProjectDirectory) {
		return false
	}

	if !v.ServiceProviderCanCreateOfferingUser.Equal(other.ServiceProviderCanCreateOfferingUser) {
		return false
	}

	if !v.SnapshotSizeLimitGb.Equal(other.SnapshotSizeLimitGb) {
		return false
	}

	if !v.StorageMode.Equal(other.StorageMode) {
		return false
	}

	if !v.SupportsDownscaling.Equal(other.SupportsDownscaling) {
		return false
	}

	if !v.SupportsPausing.Equal(other.SupportsPausing) {
		return false
	}

	if !v.UsernameAnonymizedPrefix.Equal(other.UsernameAnonymizedPrefix) {
		return false
	}

	if !v.UsernameGenerationPolicy.Equal(other.UsernameGenerationPolicy) {
		return false
	}

	return true
}

func (v PluginOptionsValue) Type(ctx context.Context) attr.Type {
	return PluginOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PluginOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"auto_approve_in_service_provider_projects":             basetypes.BoolType{},
		"auto_approve_remote_orders":                            basetypes.BoolType{},
		"backend_id_display_label":                              basetypes.StringType{},
		"conceal_billing_data":                                  basetypes.BoolType{},
		"default_internal_network_mtu":                          basetypes.Int64Type{},
		"default_resource_termination_offset_in_days":           basetypes.Int64Type{},
		"deployment_mode":                                       basetypes.StringType{},
		"enable_issues_for_membership_changes":                  basetypes.BoolType{},
		"flavors_regex":                                         basetypes.StringType{},
		"heappe_cluster_id":                                     basetypes.StringType{},
		"heappe_local_base_path":                                basetypes.StringType{},
		"heappe_url":                                            basetypes.StringType{},
		"heappe_username":                                       basetypes.StringType{},
		"highlight_backend_id_display":                          basetypes.BoolType{},
		"homedir_prefix":                                        basetypes.StringType{},
		"initial_primarygroup_number":                           basetypes.Int64Type{},
		"initial_uidnumber":                                     basetypes.Int64Type{},
		"initial_usergroup_number":                              basetypes.Int64Type{},
		"is_resource_termination_date_required":                 basetypes.BoolType{},
		"latest_date_for_resource_termination":                  basetypes.StringType{},
		"managed_rancher_load_balancer_data_volume_size_gb":     basetypes.Int64Type{},
		"managed_rancher_load_balancer_data_volume_type_name":   basetypes.StringType{},
		"managed_rancher_load_balancer_flavor_name":             basetypes.StringType{},
		"managed_rancher_load_balancer_system_volume_size_gb":   basetypes.Int64Type{},
		"managed_rancher_load_balancer_system_volume_type_name": basetypes.StringType{},
		"managed_rancher_server_data_volume_size_gb":            basetypes.Int64Type{},
		"managed_rancher_server_data_volume_type_name":          basetypes.StringType{},
		"managed_rancher_server_flavor_name":                    basetypes.StringType{},
		"managed_rancher_server_system_volume_size_gb":          basetypes.Int64Type{},
		"managed_rancher_server_system_volume_type_name":        basetypes.StringType{},
		"managed_rancher_tenant_max_cpu":                        basetypes.Int64Type{},
		"managed_rancher_tenant_max_disk":                       basetypes.Int64Type{},
		"managed_rancher_tenant_max_ram":                        basetypes.Int64Type{},
		"managed_rancher_worker_system_volume_size_gb":          basetypes.Int64Type{},
		"managed_rancher_worker_system_volume_type_name":        basetypes.StringType{},
		"max_instances":                                         basetypes.Int64Type{},
		"max_resource_termination_offset_in_days":               basetypes.Int64Type{},
		"max_volumes":                                           basetypes.Int64Type{},
		"maximal_resource_count_per_project":                    basetypes.Int64Type{},
		"minimal_team_count_for_provisioning":                   basetypes.Int64Type{},
		"openstack_offering_uuid_list": basetypes.ListType{
			ElemType: types.StringType,
		},
		"order_supports_comments_and_metadata":      basetypes.BoolType{},
		"project_permanent_directory":               basetypes.StringType{},
		"required_team_role_for_provisioning":       basetypes.StringType{},
		"scratch_project_directory":                 basetypes.StringType{},
		"service_provider_can_create_offering_user": basetypes.BoolType{},
		"snapshot_size_limit_gb":                    basetypes.Int64Type{},
		"storage_mode":                              basetypes.StringType{},
		"supports_downscaling":                      basetypes.BoolType{},
		"supports_pausing":                          basetypes.BoolType{},
		"username_anonymized_prefix":                basetypes.StringType{},
		"username_generation_policy":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PromotionCampaignsType{}

type PromotionCampaignsType struct {
	basetypes.ObjectType
}

func (t PromotionCampaignsType) Equal(o attr.Type) bool {
	other, ok := o.(PromotionCampaignsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PromotionCampaignsType) String() string {
	return "PromotionCampaignsType"
}

func (t PromotionCampaignsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	discountAttribute, ok := attributes["discount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount is missing from object`)

		return nil, diags
	}

	discountVal, ok := discountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount expected to be basetypes.Int64Value, was: %T`, discountAttribute))
	}

	discountTypeAttribute, ok := attributes["discount_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount_type is missing from object`)

		return nil, diags
	}

	discountTypeVal, ok := discountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount_type expected to be basetypes.StringValue, was: %T`, discountTypeAttribute))
	}

	endDateAttribute, ok := attributes["end_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_date is missing from object`)

		return nil, diags
	}

	endDateVal, ok := endDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_date expected to be basetypes.StringValue, was: %T`, endDateAttribute))
	}

	monthsAttribute, ok := attributes["months"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`months is missing from object`)

		return nil, diags
	}

	monthsVal, ok := monthsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`months expected to be basetypes.Int64Value, was: %T`, monthsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	serviceProviderAttribute, ok := attributes["service_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_provider is missing from object`)

		return nil, diags
	}

	serviceProviderVal, ok := serviceProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_provider expected to be basetypes.StringValue, was: %T`, serviceProviderAttribute))
	}

	startDateAttribute, ok := attributes["start_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_date is missing from object`)

		return nil, diags
	}

	startDateVal, ok := startDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_date expected to be basetypes.StringValue, was: %T`, startDateAttribute))
	}

	stockAttribute, ok := attributes["stock"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stock is missing from object`)

		return nil, diags
	}

	stockVal, ok := stockAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stock expected to be basetypes.Int64Value, was: %T`, stockAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PromotionCampaignsValue{
		Description:     descriptionVal,
		Discount:        discountVal,
		DiscountType:    discountTypeVal,
		EndDate:         endDateVal,
		Months:          monthsVal,
		Name:            nameVal,
		ServiceProvider: serviceProviderVal,
		StartDate:       startDateVal,
		Stock:           stockVal,
		Uuid:            uuidVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewPromotionCampaignsValueNull() PromotionCampaignsValue {
	return PromotionCampaignsValue{
		state: attr.ValueStateNull,
	}
}

func NewPromotionCampaignsValueUnknown() PromotionCampaignsValue {
	return PromotionCampaignsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPromotionCampaignsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PromotionCampaignsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PromotionCampaignsValue Attribute Value",
				"While creating a PromotionCampaignsValue value, a missing attribute value was detected. "+
					"A PromotionCampaignsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PromotionCampaignsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PromotionCampaignsValue Attribute Type",
				"While creating a PromotionCampaignsValue value, an invalid attribute value was detected. "+
					"A PromotionCampaignsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PromotionCampaignsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PromotionCampaignsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PromotionCampaignsValue Attribute Value",
				"While creating a PromotionCampaignsValue value, an extra attribute value was detected. "+
					"A PromotionCampaignsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PromotionCampaignsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPromotionCampaignsValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	discountAttribute, ok := attributes["discount"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	discountVal, ok := discountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount expected to be basetypes.Int64Value, was: %T`, discountAttribute))
	}

	discountTypeAttribute, ok := attributes["discount_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`discount_type is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	discountTypeVal, ok := discountTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`discount_type expected to be basetypes.StringValue, was: %T`, discountTypeAttribute))
	}

	endDateAttribute, ok := attributes["end_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_date is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	endDateVal, ok := endDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_date expected to be basetypes.StringValue, was: %T`, endDateAttribute))
	}

	monthsAttribute, ok := attributes["months"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`months is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	monthsVal, ok := monthsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`months expected to be basetypes.Int64Value, was: %T`, monthsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	serviceProviderAttribute, ok := attributes["service_provider"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`service_provider is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	serviceProviderVal, ok := serviceProviderAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`service_provider expected to be basetypes.StringValue, was: %T`, serviceProviderAttribute))
	}

	startDateAttribute, ok := attributes["start_date"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_date is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	startDateVal, ok := startDateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_date expected to be basetypes.StringValue, was: %T`, startDateAttribute))
	}

	stockAttribute, ok := attributes["stock"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`stock is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	stockVal, ok := stockAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`stock expected to be basetypes.Int64Value, was: %T`, stockAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewPromotionCampaignsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewPromotionCampaignsValueUnknown(), diags
	}

	return PromotionCampaignsValue{
		Description:     descriptionVal,
		Discount:        discountVal,
		DiscountType:    discountTypeVal,
		EndDate:         endDateVal,
		Months:          monthsVal,
		Name:            nameVal,
		ServiceProvider: serviceProviderVal,
		StartDate:       startDateVal,
		Stock:           stockVal,
		Uuid:            uuidVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewPromotionCampaignsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PromotionCampaignsValue {
	object, diags := NewPromotionCampaignsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPromotionCampaignsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PromotionCampaignsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPromotionCampaignsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPromotionCampaignsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPromotionCampaignsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPromotionCampaignsValueMust(PromotionCampaignsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PromotionCampaignsType) ValueType(ctx context.Context) attr.Value {
	return PromotionCampaignsValue{}
}

var _ basetypes.ObjectValuable = PromotionCampaignsValue{}

type PromotionCampaignsValue struct {
	Description     basetypes.StringValue `tfsdk:"description"`
	Discount        basetypes.Int64Value  `tfsdk:"discount"`
	DiscountType    basetypes.StringValue `tfsdk:"discount_type"`
	EndDate         basetypes.StringValue `tfsdk:"end_date"`
	Months          basetypes.Int64Value  `tfsdk:"months"`
	Name            basetypes.StringValue `tfsdk:"name"`
	ServiceProvider basetypes.StringValue `tfsdk:"service_provider"`
	StartDate       basetypes.StringValue `tfsdk:"start_date"`
	Stock           basetypes.Int64Value  `tfsdk:"stock"`
	Uuid            basetypes.StringValue `tfsdk:"uuid"`
	state           attr.ValueState
}

func (v PromotionCampaignsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["discount"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["discount_type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["end_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["months"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["service_provider"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["start_date"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["stock"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Discount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discount"] = val

		val, err = v.DiscountType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["discount_type"] = val

		val, err = v.EndDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end_date"] = val

		val, err = v.Months.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["months"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.ServiceProvider.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["service_provider"] = val

		val, err = v.StartDate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_date"] = val

		val, err = v.Stock.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["stock"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PromotionCampaignsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PromotionCampaignsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PromotionCampaignsValue) String() string {
	return "PromotionCampaignsValue"
}

func (v PromotionCampaignsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"description":      basetypes.StringType{},
		"discount":         basetypes.Int64Type{},
		"discount_type":    basetypes.StringType{},
		"end_date":         basetypes.StringType{},
		"months":           basetypes.Int64Type{},
		"name":             basetypes.StringType{},
		"service_provider": basetypes.StringType{},
		"start_date":       basetypes.StringType{},
		"stock":            basetypes.Int64Type{},
		"uuid":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":      v.Description,
			"discount":         v.Discount,
			"discount_type":    v.DiscountType,
			"end_date":         v.EndDate,
			"months":           v.Months,
			"name":             v.Name,
			"service_provider": v.ServiceProvider,
			"start_date":       v.StartDate,
			"stock":            v.Stock,
			"uuid":             v.Uuid,
		})

	return objVal, diags
}

func (v PromotionCampaignsValue) Equal(o attr.Value) bool {
	other, ok := o.(PromotionCampaignsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Discount.Equal(other.Discount) {
		return false
	}

	if !v.DiscountType.Equal(other.DiscountType) {
		return false
	}

	if !v.EndDate.Equal(other.EndDate) {
		return false
	}

	if !v.Months.Equal(other.Months) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.ServiceProvider.Equal(other.ServiceProvider) {
		return false
	}

	if !v.StartDate.Equal(other.StartDate) {
		return false
	}

	if !v.Stock.Equal(other.Stock) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v PromotionCampaignsValue) Type(ctx context.Context) attr.Type {
	return PromotionCampaignsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PromotionCampaignsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":      basetypes.StringType{},
		"discount":         basetypes.Int64Type{},
		"discount_type":    basetypes.StringType{},
		"end_date":         basetypes.StringType{},
		"months":           basetypes.Int64Type{},
		"name":             basetypes.StringType{},
		"service_provider": basetypes.StringType{},
		"start_date":       basetypes.StringType{},
		"stock":            basetypes.Int64Type{},
		"uuid":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = QuotasType{}

type QuotasType struct {
	basetypes.ObjectType
}

func (t QuotasType) Equal(o attr.Type) bool {
	other, ok := o.(QuotasType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t QuotasType) String() string {
	return "QuotasType"
}

func (t QuotasType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	limitAttribute, ok := attributes["limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit is missing from object`)

		return nil, diags
	}

	limitVal, ok := limitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit expected to be basetypes.Int64Value, was: %T`, limitAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return nil, diags
	}

	usageVal, ok := usageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.Int64Value, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return QuotasValue{
		Limit: limitVal,
		Name:  nameVal,
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewQuotasValueNull() QuotasValue {
	return QuotasValue{
		state: attr.ValueStateNull,
	}
}

func NewQuotasValueUnknown() QuotasValue {
	return QuotasValue{
		state: attr.ValueStateUnknown,
	}
}

func NewQuotasValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (QuotasValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing QuotasValue Attribute Value",
				"While creating a QuotasValue value, a missing attribute value was detected. "+
					"A QuotasValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QuotasValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid QuotasValue Attribute Type",
				"While creating a QuotasValue value, an invalid attribute value was detected. "+
					"A QuotasValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("QuotasValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("QuotasValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra QuotasValue Attribute Value",
				"While creating a QuotasValue value, an extra attribute value was detected. "+
					"A QuotasValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra QuotasValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewQuotasValueUnknown(), diags
	}

	limitAttribute, ok := attributes["limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`limit is missing from object`)

		return NewQuotasValueUnknown(), diags
	}

	limitVal, ok := limitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`limit expected to be basetypes.Int64Value, was: %T`, limitAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewQuotasValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	usageAttribute, ok := attributes["usage"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`usage is missing from object`)

		return NewQuotasValueUnknown(), diags
	}

	usageVal, ok := usageAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`usage expected to be basetypes.Int64Value, was: %T`, usageAttribute))
	}

	if diags.HasError() {
		return NewQuotasValueUnknown(), diags
	}

	return QuotasValue{
		Limit: limitVal,
		Name:  nameVal,
		Usage: usageVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewQuotasValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) QuotasValue {
	object, diags := NewQuotasValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewQuotasValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t QuotasType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewQuotasValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewQuotasValueUnknown(), nil
	}

	if in.IsNull() {
		return NewQuotasValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewQuotasValueMust(QuotasValue{}.AttributeTypes(ctx), attributes), nil
}

func (t QuotasType) ValueType(ctx context.Context) attr.Value {
	return QuotasValue{}
}

var _ basetypes.ObjectValuable = QuotasValue{}

type QuotasValue struct {
	Limit basetypes.Int64Value  `tfsdk:"limit"`
	Name  basetypes.StringValue `tfsdk:"name"`
	Usage basetypes.Int64Value  `tfsdk:"usage"`
	state attr.ValueState
}

func (v QuotasValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["usage"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Limit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["limit"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Usage.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["usage"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v QuotasValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v QuotasValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v QuotasValue) String() string {
	return "QuotasValue"
}

func (v QuotasValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"limit": basetypes.Int64Type{},
		"name":  basetypes.StringType{},
		"usage": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"limit": v.Limit,
			"name":  v.Name,
			"usage": v.Usage,
		})

	return objVal, diags
}

func (v QuotasValue) Equal(o attr.Value) bool {
	other, ok := o.(QuotasValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Limit.Equal(other.Limit) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Usage.Equal(other.Usage) {
		return false
	}

	return true
}

func (v QuotasValue) Type(ctx context.Context) attr.Type {
	return QuotasType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v QuotasValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"limit": basetypes.Int64Type{},
		"name":  basetypes.StringType{},
		"usage": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = ResourceOptionsType{}

type ResourceOptionsType struct {
	basetypes.ObjectType
}

func (t ResourceOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(ResourceOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ResourceOptionsType) String() string {
	return "ResourceOptionsType"
}

func (t ResourceOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return nil, diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	orderAttribute, ok := attributes["order"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order is missing from object`)

		return nil, diags
	}

	orderVal, ok := orderAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order expected to be basetypes.ListValue, was: %T`, orderAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ResourceOptionsValue{
		Options: optionsVal,
		Order:   orderVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewResourceOptionsValueNull() ResourceOptionsValue {
	return ResourceOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewResourceOptionsValueUnknown() ResourceOptionsValue {
	return ResourceOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewResourceOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ResourceOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ResourceOptionsValue Attribute Value",
				"While creating a ResourceOptionsValue value, a missing attribute value was detected. "+
					"A ResourceOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ResourceOptionsValue Attribute Type",
				"While creating a ResourceOptionsValue value, an invalid attribute value was detected. "+
					"A ResourceOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ResourceOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ResourceOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ResourceOptionsValue Attribute Value",
				"While creating a ResourceOptionsValue value, an extra attribute value was detected. "+
					"A ResourceOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ResourceOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewResourceOptionsValueUnknown(), diags
	}

	optionsAttribute, ok := attributes["options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`options is missing from object`)

		return NewResourceOptionsValueUnknown(), diags
	}

	optionsVal, ok := optionsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`options expected to be basetypes.MapValue, was: %T`, optionsAttribute))
	}

	orderAttribute, ok := attributes["order"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`order is missing from object`)

		return NewResourceOptionsValueUnknown(), diags
	}

	orderVal, ok := orderAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`order expected to be basetypes.ListValue, was: %T`, orderAttribute))
	}

	if diags.HasError() {
		return NewResourceOptionsValueUnknown(), diags
	}

	return ResourceOptionsValue{
		Options: optionsVal,
		Order:   orderVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewResourceOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ResourceOptionsValue {
	object, diags := NewResourceOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewResourceOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ResourceOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewResourceOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewResourceOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewResourceOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewResourceOptionsValueMust(ResourceOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ResourceOptionsType) ValueType(ctx context.Context) attr.Value {
	return ResourceOptionsValue{}
}

var _ basetypes.ObjectValuable = ResourceOptionsValue{}

type ResourceOptionsValue struct {
	Options basetypes.MapValue  `tfsdk:"options"`
	Order   basetypes.ListValue `tfsdk:"order"`
	state   attr.ValueState
}

func (v ResourceOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["options"] = basetypes.MapType{
		ElemType: OptionsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["order"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Options.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["options"] = val

		val, err = v.Order.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["order"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ResourceOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ResourceOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ResourceOptionsValue) String() string {
	return "ResourceOptionsValue"
}

func (v ResourceOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	options := types.MapValueMust(
		OptionsType{
			basetypes.ObjectType{
				AttrTypes: OptionsValue{}.AttributeTypes(ctx),
			},
		},
		v.Options.Elements(),
	)

	if v.Options.IsNull() {
		options = types.MapNull(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Options.IsUnknown() {
		options = types.MapUnknown(
			OptionsType{
				basetypes.ObjectType{
					AttrTypes: OptionsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var orderVal basetypes.ListValue
	switch {
	case v.Order.IsUnknown():
		orderVal = types.ListUnknown(types.StringType)
	case v.Order.IsNull():
		orderVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		orderVal, d = types.ListValue(types.StringType, v.Order.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"options": basetypes.MapType{
				ElemType: OptionsValue{}.Type(ctx),
			},
			"order": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"order": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"options": options,
			"order":   orderVal,
		})

	return objVal, diags
}

func (v ResourceOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(ResourceOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Options.Equal(other.Options) {
		return false
	}

	if !v.Order.Equal(other.Order) {
		return false
	}

	return true
}

func (v ResourceOptionsValue) Type(ctx context.Context) attr.Type {
	return ResourceOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ResourceOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"options": basetypes.MapType{
			ElemType: OptionsValue{}.Type(ctx),
		},
		"order": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = OptionsType{}

type OptionsType struct {
	basetypes.ObjectType
}

func (t OptionsType) Equal(o attr.Type) bool {
	other, ok := o.(OptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OptionsType) String() string {
	return "OptionsType"
}

func (t OptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	choicesAttribute, ok := attributes["choices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`choices is missing from object`)

		return nil, diags
	}

	choicesVal, ok := choicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`choices expected to be basetypes.ListValue, was: %T`, choicesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return nil, diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	helpTextAttribute, ok := attributes["help_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`help_text is missing from object`)

		return nil, diags
	}

	helpTextVal, ok := helpTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`help_text expected to be basetypes.StringValue, was: %T`, helpTextAttribute))
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return nil, diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return nil, diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return nil, diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return nil, diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OptionsValue{
		Choices:     choicesVal,
		Default:     defaultVal,
		HelpText:    helpTextVal,
		Label:       labelVal,
		Max:         maxVal,
		Min:         minVal,
		Required:    requiredVal,
		OptionsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueNull() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewOptionsValueUnknown() OptionsValue {
	return OptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OptionsValue Attribute Value",
				"While creating a OptionsValue value, a missing attribute value was detected. "+
					"A OptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OptionsValue Attribute Type",
				"While creating a OptionsValue value, an invalid attribute value was detected. "+
					"A OptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OptionsValue Attribute Value",
				"While creating a OptionsValue value, an extra attribute value was detected. "+
					"A OptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	choicesAttribute, ok := attributes["choices"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`choices is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	choicesVal, ok := choicesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`choices expected to be basetypes.ListValue, was: %T`, choicesAttribute))
	}

	defaultAttribute, ok := attributes["default"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	defaultVal, ok := defaultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default expected to be basetypes.StringValue, was: %T`, defaultAttribute))
	}

	helpTextAttribute, ok := attributes["help_text"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`help_text is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	helpTextVal, ok := helpTextAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`help_text expected to be basetypes.StringValue, was: %T`, helpTextAttribute))
	}

	labelAttribute, ok := attributes["label"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	labelVal, ok := labelAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label expected to be basetypes.StringValue, was: %T`, labelAttribute))
	}

	maxAttribute, ok := attributes["max"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	maxVal, ok := maxAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max expected to be basetypes.Int64Value, was: %T`, maxAttribute))
	}

	minAttribute, ok := attributes["min"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	minVal, ok := minAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min expected to be basetypes.Int64Value, was: %T`, minAttribute))
	}

	requiredAttribute, ok := attributes["required"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	requiredVal, ok := requiredAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required expected to be basetypes.BoolValue, was: %T`, requiredAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewOptionsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewOptionsValueUnknown(), diags
	}

	return OptionsValue{
		Choices:     choicesVal,
		Default:     defaultVal,
		HelpText:    helpTextVal,
		Label:       labelVal,
		Max:         maxVal,
		Min:         minVal,
		Required:    requiredVal,
		OptionsType: typeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OptionsValue {
	object, diags := NewOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOptionsValueMust(OptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OptionsType) ValueType(ctx context.Context) attr.Value {
	return OptionsValue{}
}

var _ basetypes.ObjectValuable = OptionsValue{}

type OptionsValue struct {
	Choices     basetypes.ListValue   `tfsdk:"choices"`
	Default     basetypes.StringValue `tfsdk:"default"`
	HelpText    basetypes.StringValue `tfsdk:"help_text"`
	Label       basetypes.StringValue `tfsdk:"label"`
	Max         basetypes.Int64Value  `tfsdk:"max"`
	Min         basetypes.Int64Value  `tfsdk:"min"`
	Required    basetypes.BoolValue   `tfsdk:"required"`
	OptionsType basetypes.StringValue `tfsdk:"type"`
	state       attr.ValueState
}

func (v OptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["choices"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["default"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["help_text"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["label"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["max"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Choices.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["choices"] = val

		val, err = v.Default.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default"] = val

		val, err = v.HelpText.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["help_text"] = val

		val, err = v.Label.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label"] = val

		val, err = v.Max.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max"] = val

		val, err = v.Min.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min"] = val

		val, err = v.Required.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required"] = val

		val, err = v.OptionsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OptionsValue) String() string {
	return "OptionsValue"
}

func (v OptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var choicesVal basetypes.ListValue
	switch {
	case v.Choices.IsUnknown():
		choicesVal = types.ListUnknown(types.StringType)
	case v.Choices.IsNull():
		choicesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		choicesVal, d = types.ListValue(types.StringType, v.Choices.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"choices": basetypes.ListType{
				ElemType: types.StringType,
			},
			"default":   basetypes.StringType{},
			"help_text": basetypes.StringType{},
			"label":     basetypes.StringType{},
			"max":       basetypes.Int64Type{},
			"min":       basetypes.Int64Type{},
			"required":  basetypes.BoolType{},
			"type":      basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"choices": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default":   basetypes.StringType{},
		"help_text": basetypes.StringType{},
		"label":     basetypes.StringType{},
		"max":       basetypes.Int64Type{},
		"min":       basetypes.Int64Type{},
		"required":  basetypes.BoolType{},
		"type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"choices":   choicesVal,
			"default":   v.Default,
			"help_text": v.HelpText,
			"label":     v.Label,
			"max":       v.Max,
			"min":       v.Min,
			"required":  v.Required,
			"type":      v.OptionsType,
		})

	return objVal, diags
}

func (v OptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(OptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Choices.Equal(other.Choices) {
		return false
	}

	if !v.Default.Equal(other.Default) {
		return false
	}

	if !v.HelpText.Equal(other.HelpText) {
		return false
	}

	if !v.Label.Equal(other.Label) {
		return false
	}

	if !v.Max.Equal(other.Max) {
		return false
	}

	if !v.Min.Equal(other.Min) {
		return false
	}

	if !v.Required.Equal(other.Required) {
		return false
	}

	if !v.OptionsType.Equal(other.OptionsType) {
		return false
	}

	return true
}

func (v OptionsValue) Type(ctx context.Context) attr.Type {
	return OptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"choices": basetypes.ListType{
			ElemType: types.StringType,
		},
		"default":   basetypes.StringType{},
		"help_text": basetypes.StringType{},
		"label":     basetypes.StringType{},
		"max":       basetypes.Int64Type{},
		"min":       basetypes.Int64Type{},
		"required":  basetypes.BoolType{},
		"type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RolesType{}

type RolesType struct {
	basetypes.ObjectType
}

func (t RolesType) Equal(o attr.Type) bool {
	other, ok := o.(RolesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RolesType) String() string {
	return "RolesType"
}

func (t RolesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return nil, diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RolesValue{
		Name:  nameVal,
		Url:   urlVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRolesValueNull() RolesValue {
	return RolesValue{
		state: attr.ValueStateNull,
	}
}

func NewRolesValueUnknown() RolesValue {
	return RolesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRolesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RolesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RolesValue Attribute Value",
				"While creating a RolesValue value, a missing attribute value was detected. "+
					"A RolesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RolesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RolesValue Attribute Type",
				"While creating a RolesValue value, an invalid attribute value was detected. "+
					"A RolesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RolesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RolesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RolesValue Attribute Value",
				"While creating a RolesValue value, an extra attribute value was detected. "+
					"A RolesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RolesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRolesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	urlAttribute, ok := attributes["url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`url is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	urlVal, ok := urlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`url expected to be basetypes.StringValue, was: %T`, urlAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewRolesValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewRolesValueUnknown(), diags
	}

	return RolesValue{
		Name:  nameVal,
		Url:   urlVal,
		Uuid:  uuidVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewRolesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RolesValue {
	object, diags := NewRolesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRolesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RolesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRolesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRolesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRolesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRolesValueMust(RolesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RolesType) ValueType(ctx context.Context) attr.Value {
	return RolesValue{}
}

var _ basetypes.ObjectValuable = RolesValue{}

type RolesValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Url   basetypes.StringValue `tfsdk:"url"`
	Uuid  basetypes.StringValue `tfsdk:"uuid"`
	state attr.ValueState
}

func (v RolesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Url.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["url"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RolesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RolesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RolesValue) String() string {
	return "RolesValue"
}

func (v RolesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"url":  basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"url":  v.Url,
			"uuid": v.Uuid,
		})

	return objVal, diags
}

func (v RolesValue) Equal(o attr.Value) bool {
	other, ok := o.(RolesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Url.Equal(other.Url) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v RolesValue) Type(ctx context.Context) attr.Type {
	return RolesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RolesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"url":  basetypes.StringType{},
		"uuid": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ScreenshotsType{}

type ScreenshotsType struct {
	basetypes.ObjectType
}

func (t ScreenshotsType) Equal(o attr.Type) bool {
	other, ok := o.(ScreenshotsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ScreenshotsType) String() string {
	return "ScreenshotsType"
}

func (t ScreenshotsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return nil, diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	thumbnailAttribute, ok := attributes["thumbnail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thumbnail is missing from object`)

		return nil, diags
	}

	thumbnailVal, ok := thumbnailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thumbnail expected to be basetypes.StringValue, was: %T`, thumbnailAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return nil, diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ScreenshotsValue{
		Created:     createdVal,
		Description: descriptionVal,
		Image:       imageVal,
		Name:        nameVal,
		Thumbnail:   thumbnailVal,
		Uuid:        uuidVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewScreenshotsValueNull() ScreenshotsValue {
	return ScreenshotsValue{
		state: attr.ValueStateNull,
	}
}

func NewScreenshotsValueUnknown() ScreenshotsValue {
	return ScreenshotsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewScreenshotsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ScreenshotsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ScreenshotsValue Attribute Value",
				"While creating a ScreenshotsValue value, a missing attribute value was detected. "+
					"A ScreenshotsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScreenshotsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ScreenshotsValue Attribute Type",
				"While creating a ScreenshotsValue value, an invalid attribute value was detected. "+
					"A ScreenshotsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ScreenshotsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ScreenshotsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ScreenshotsValue Attribute Value",
				"While creating a ScreenshotsValue value, an extra attribute value was detected. "+
					"A ScreenshotsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ScreenshotsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewScreenshotsValueUnknown(), diags
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	imageAttribute, ok := attributes["image"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`image is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	imageVal, ok := imageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`image expected to be basetypes.StringValue, was: %T`, imageAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	thumbnailAttribute, ok := attributes["thumbnail"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`thumbnail is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	thumbnailVal, ok := thumbnailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`thumbnail expected to be basetypes.StringValue, was: %T`, thumbnailAttribute))
	}

	uuidAttribute, ok := attributes["uuid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uuid is missing from object`)

		return NewScreenshotsValueUnknown(), diags
	}

	uuidVal, ok := uuidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uuid expected to be basetypes.StringValue, was: %T`, uuidAttribute))
	}

	if diags.HasError() {
		return NewScreenshotsValueUnknown(), diags
	}

	return ScreenshotsValue{
		Created:     createdVal,
		Description: descriptionVal,
		Image:       imageVal,
		Name:        nameVal,
		Thumbnail:   thumbnailVal,
		Uuid:        uuidVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewScreenshotsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ScreenshotsValue {
	object, diags := NewScreenshotsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewScreenshotsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ScreenshotsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewScreenshotsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewScreenshotsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewScreenshotsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewScreenshotsValueMust(ScreenshotsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ScreenshotsType) ValueType(ctx context.Context) attr.Value {
	return ScreenshotsValue{}
}

var _ basetypes.ObjectValuable = ScreenshotsValue{}

type ScreenshotsValue struct {
	Created     basetypes.StringValue `tfsdk:"created"`
	Description basetypes.StringValue `tfsdk:"description"`
	Image       basetypes.StringValue `tfsdk:"image"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Thumbnail   basetypes.StringValue `tfsdk:"thumbnail"`
	Uuid        basetypes.StringValue `tfsdk:"uuid"`
	state       attr.ValueState
}

func (v ScreenshotsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["image"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["thumbnail"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uuid"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Image.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["image"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Thumbnail.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["thumbnail"] = val

		val, err = v.Uuid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uuid"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ScreenshotsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ScreenshotsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ScreenshotsValue) String() string {
	return "ScreenshotsValue"
}

func (v ScreenshotsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"created":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"image":       basetypes.StringType{},
		"name":        basetypes.StringType{},
		"thumbnail":   basetypes.StringType{},
		"uuid":        basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"created":     v.Created,
			"description": v.Description,
			"image":       v.Image,
			"name":        v.Name,
			"thumbnail":   v.Thumbnail,
			"uuid":        v.Uuid,
		})

	return objVal, diags
}

func (v ScreenshotsValue) Equal(o attr.Value) bool {
	other, ok := o.(ScreenshotsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Image.Equal(other.Image) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Thumbnail.Equal(other.Thumbnail) {
		return false
	}

	if !v.Uuid.Equal(other.Uuid) {
		return false
	}

	return true
}

func (v ScreenshotsValue) Type(ctx context.Context) attr.Type {
	return ScreenshotsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ScreenshotsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"created":     basetypes.StringType{},
		"description": basetypes.StringType{},
		"image":       basetypes.StringType{},
		"name":        basetypes.StringType{},
		"thumbnail":   basetypes.StringType{},
		"uuid":        basetypes.StringType{},
	}
}
